// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"dafvh":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "4c74fe43c064fd94";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws;
    try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        if (e.message) console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"f2QDv":[function(require,module,exports) {
/* eslint-disable */ var _login = require("./login");
var _leaflet = require("./leaflet");
var _updateSettings = require("./updateSettings");
var _tourModel = require("../../models/tourModel");
// console.log('running index.js');
const logOutBtn = document.querySelector(".nav__el--logoutbtn");
const userDataForm = document.querySelector(".form-user-data");
const locData = document.getElementById("map");
if (locData) {
    const locations = JSON.parse(locData.dataset.locations);
    (0, _leaflet.displayMap)(locations);
}
const loginForm = document.querySelector(".form--login");
if (loginForm) loginForm.addEventListener("submit", (e)=>{
    e.preventDefault();
    const email = document.getElementById("email").value;
    const password = document.getElementById("password").value;
    (0, _login.login)(email, password);
});
if (logOutBtn) logOutBtn.addEventListener("click", (0, _login.logout));
if (userDataForm) userDataForm.addEventListener("submit", (e)=>{
    e.preventDefault();
    const name = document.getElementById("name").value;
    const email = document.getElementById("email").value;
    (0, _updateSettings.updateData)(name, email);
});

},{"./login":"7yHem","./leaflet":"xvuTT","./updateSettings":"l3cGY","../../models/tourModel":"7FL8t"}],"7yHem":[function(require,module,exports) {
/*eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "login", ()=>login);
parcelHelpers.export(exports, "logout", ()=>logout);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _alerts = require("./alerts");
const login = async (email, password)=>{
    try {
        const res = await (0, _axiosDefault.default)({
            method: "POST",
            url: "http://127.0.0.1:3000/api/v1/users/login",
            data: {
                email,
                password
            }
        });
        if (res.data.status === "Success") {
            (0, _alerts.showAlert)("success", "Logged in successfuly!");
            window.setTimeout(()=>{
                location.assign("/");
            }, 1500);
        }
    } catch (error) {
        (0, _alerts.showAlert)("error", error.response.data.message);
    }
};
const logout = async ()=>{
    console.log("logout");
    try {
        const res = await (0, _axiosDefault.default)({
            method: "GET",
            url: "http://127.0.0.1:3000/api/v1/users/logout"
        });
        if (res.data.status === "success") location.reload(true);
    } catch (error) {
        (0, _alerts.showAlert)("error", "Error logging out! Try again.");
    }
};

},{"axios":"jo6P5","./alerts":"6Mcnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jo6P5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _axiosJsDefault.default));
parcelHelpers.export(exports, "Axios", ()=>Axios);
parcelHelpers.export(exports, "AxiosError", ()=>AxiosError);
parcelHelpers.export(exports, "CanceledError", ()=>CanceledError);
parcelHelpers.export(exports, "isCancel", ()=>isCancel);
parcelHelpers.export(exports, "CancelToken", ()=>CancelToken);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "Cancel", ()=>Cancel);
parcelHelpers.export(exports, "isAxiosError", ()=>isAxiosError);
parcelHelpers.export(exports, "spread", ()=>spread);
parcelHelpers.export(exports, "toFormData", ()=>toFormData);
parcelHelpers.export(exports, "AxiosHeaders", ()=>AxiosHeaders);
parcelHelpers.export(exports, "HttpStatusCode", ()=>HttpStatusCode);
parcelHelpers.export(exports, "formToJSON", ()=>formToJSON);
parcelHelpers.export(exports, "getAdapter", ()=>getAdapter);
parcelHelpers.export(exports, "mergeConfig", ()=>mergeConfig);
var _axiosJs = require("./lib/axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const { Axios, AxiosError, CanceledError, isCancel, CancelToken, VERSION, all, Cancel, isAxiosError, spread, toFormData, AxiosHeaders, HttpStatusCode, formToJSON, getAdapter, mergeConfig } = (0, _axiosJsDefault.default);

},{"./lib/axios.js":"63MyY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"63MyY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var _axiosJs = require("./core/Axios.js");
var _axiosJsDefault = parcelHelpers.interopDefault(_axiosJs);
var _mergeConfigJs = require("./core/mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _indexJs = require("./defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("./helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
var _canceledErrorJs = require("./cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _cancelTokenJs = require("./cancel/CancelToken.js");
var _cancelTokenJsDefault = parcelHelpers.interopDefault(_cancelTokenJs);
var _isCancelJs = require("./cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _dataJs = require("./env/data.js");
var _toFormDataJs = require("./helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _axiosErrorJs = require("./core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _spreadJs = require("./helpers/spread.js");
var _spreadJsDefault = parcelHelpers.interopDefault(_spreadJs);
var _isAxiosErrorJs = require("./helpers/isAxiosError.js");
var _isAxiosErrorJsDefault = parcelHelpers.interopDefault(_isAxiosErrorJs);
var _axiosHeadersJs = require("./core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("./adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
var _httpStatusCodeJs = require("./helpers/HttpStatusCode.js");
var _httpStatusCodeJsDefault = parcelHelpers.interopDefault(_httpStatusCodeJs);
"use strict";
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */ function createInstance(defaultConfig) {
    const context = new (0, _axiosJsDefault.default)(defaultConfig);
    const instance = (0, _bindJsDefault.default)((0, _axiosJsDefault.default).prototype.request, context);
    // Copy axios.prototype to instance
    (0, _utilsJsDefault.default).extend(instance, (0, _axiosJsDefault.default).prototype, context, {
        allOwnKeys: true
    });
    // Copy context to instance
    (0, _utilsJsDefault.default).extend(instance, context, null, {
        allOwnKeys: true
    });
    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
        return createInstance((0, _mergeConfigJsDefault.default)(defaultConfig, instanceConfig));
    };
    return instance;
}
// Create the default instance to be exported
const axios = createInstance((0, _indexJsDefault.default));
// Expose Axios class to allow class inheritance
axios.Axios = (0, _axiosJsDefault.default);
// Expose Cancel & CancelToken
axios.CanceledError = (0, _canceledErrorJsDefault.default);
axios.CancelToken = (0, _cancelTokenJsDefault.default);
axios.isCancel = (0, _isCancelJsDefault.default);
axios.VERSION = (0, _dataJs.VERSION);
axios.toFormData = (0, _toFormDataJsDefault.default);
// Expose AxiosError class
axios.AxiosError = (0, _axiosErrorJsDefault.default);
// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;
// Expose all/spread
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = (0, _spreadJsDefault.default);
// Expose isAxiosError
axios.isAxiosError = (0, _isAxiosErrorJsDefault.default);
// Expose mergeConfig
axios.mergeConfig = (0, _mergeConfigJsDefault.default);
axios.AxiosHeaders = (0, _axiosHeadersJsDefault.default);
axios.formToJSON = (thing)=>(0, _formDataToJSONJsDefault.default)((0, _utilsJsDefault.default).isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = (0, _adaptersJsDefault.default).getAdapter;
axios.HttpStatusCode = (0, _httpStatusCodeJsDefault.default);
axios.default = axios;
// this module should only have a default export
exports.default = axios;

},{"./utils.js":"5By4s","./helpers/bind.js":"haRQb","./core/Axios.js":"cpqD8","./core/mergeConfig.js":"b85oP","./defaults/index.js":"hXfHM","./helpers/formDataToJSON.js":"01RfH","./cancel/CanceledError.js":"9PwCG","./cancel/CancelToken.js":"45wzn","./cancel/isCancel.js":"a0VmF","./env/data.js":"h29L9","./helpers/toFormData.js":"ajoez","./core/AxiosError.js":"3u8Tl","./helpers/spread.js":"dyQ8N","./helpers/isAxiosError.js":"eyiLq","./core/AxiosHeaders.js":"cgSSx","./adapters/adapters.js":"d7JxI","./helpers/HttpStatusCode.js":"fdR61","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5By4s":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bindJs = require("./helpers/bind.js");
var _bindJsDefault = parcelHelpers.interopDefault(_bindJs);
var global = arguments[3];
"use strict";
// utils is a library of generic helper functions non-specific to axios
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache)=>(thing)=>{
        const str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(Object.create(null));
const kindOfTest = (type)=>{
    type = type.toLowerCase();
    return (thing)=>kindOf(thing) === type;
};
const typeOfTest = (type)=>(thing)=>typeof thing === type;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */ const { isArray } = Array;
/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */ const isUndefined = typeOfTest("undefined");
/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */ function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */ const isArrayBuffer = kindOfTest("ArrayBuffer");
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */ function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) result = ArrayBuffer.isView(val);
    else result = val && val.buffer && isArrayBuffer(val.buffer);
    return result;
}
/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */ const isString = typeOfTest("string");
/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */ const isFunction = typeOfTest("function");
/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */ const isNumber = typeOfTest("number");
/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */ const isObject = (thing)=>thing !== null && typeof thing === "object";
/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */ const isBoolean = (thing)=>thing === true || thing === false;
/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */ const isPlainObject = (val)=>{
    if (kindOf(val) !== "object") return false;
    const prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */ const isDate = kindOfTest("Date");
/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFile = kindOfTest("File");
/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */ const isBlob = kindOfTest("Blob");
/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */ const isFileList = kindOfTest("FileList");
/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */ const isStream = (val)=>isObject(val) && isFunction(val.pipe);
/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */ const isFormData = (thing)=>{
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */ const isURLSearchParams = kindOfTest("URLSearchParams");
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */ const trim = (str)=>str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */ function forEach(obj, fn, { allOwnKeys = false } = {}) {
    // Don't bother if no value provided
    if (obj === null || typeof obj === "undefined") return;
    let i;
    let l;
    // Force an array if not already something iterable
    if (typeof obj !== "object") /*eslint no-param-reassign:0*/ obj = [
        obj
    ];
    if (isArray(obj)) // Iterate over array values
    for(i = 0, l = obj.length; i < l; i++)fn.call(null, obj[i], i, obj);
    else {
        // Iterate over object keys
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for(i = 0; i < len; i++){
            key = keys[i];
            fn.call(null, obj[key], key, obj);
        }
    }
}
function findKey(obj, key) {
    key = key.toLowerCase();
    const keys = Object.keys(obj);
    let i = keys.length;
    let _key;
    while(i-- > 0){
        _key = keys[i];
        if (key === _key.toLowerCase()) return _key;
    }
    return null;
}
const _global = (()=>{
    /*eslint no-undef:0*/ if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context)=>!isUndefined(context) && context !== _global;
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */ function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key)=>{
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) result[targetKey] = merge(result[targetKey], val);
        else if (isPlainObject(val)) result[targetKey] = merge({}, val);
        else if (isArray(val)) result[targetKey] = val.slice();
        else result[targetKey] = val;
    };
    for(let i = 0, l = arguments.length; i < l; i++)arguments[i] && forEach(arguments[i], assignValue);
    return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */ const extend = (a, b, thisArg, { allOwnKeys } = {})=>{
    forEach(b, (val, key)=>{
        if (thisArg && isFunction(val)) a[key] = (0, _bindJsDefault.default)(val, thisArg);
        else a[key] = val;
    }, {
        allOwnKeys
    });
    return a;
};
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */ const stripBOM = (content)=>{
    if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1);
    return content;
};
/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */ const inherits = (constructor, superConstructor, props, descriptors)=>{
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
};
/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */ const toFlatObject = (sourceObj, destObj, filter, propFilter)=>{
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;
    do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while(i-- > 0){
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
            }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
    }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
};
/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */ const endsWith = (str, searchString, position)=>{
    str = String(str);
    if (position === undefined || position > str.length) position = str.length;
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
};
/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */ const toArray = (thing)=>{
    if (!thing) return null;
    if (isArray(thing)) return thing;
    let i = thing.length;
    if (!isNumber(i)) return null;
    const arr = new Array(i);
    while(i-- > 0)arr[i] = thing[i];
    return arr;
};
/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */ // eslint-disable-next-line func-names
const isTypedArray = ((TypedArray)=>{
    // eslint-disable-next-line func-names
    return (thing)=>{
        return TypedArray && thing instanceof TypedArray;
    };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */ const forEachEntry = (obj, fn)=>{
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while((result = iterator.next()) && !result.done){
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
    }
};
/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */ const matchAll = (regExp, str)=>{
    let matches;
    const arr = [];
    while((matches = regExp.exec(str)) !== null)arr.push(matches);
    return arr;
};
/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */ const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str)=>{
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
    });
};
/* Creating a function that will check if an object has a property. */ const hasOwnProperty = (({ hasOwnProperty })=>(obj, prop)=>hasOwnProperty.call(obj, prop))(Object.prototype);
/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */ const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer)=>{
    const descriptors = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors, (descriptor, name)=>{
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) reducedDescriptors[name] = ret || descriptor;
    });
    Object.defineProperties(obj, reducedDescriptors);
};
/**
 * Makes all methods read-only
 * @param {Object} obj
 */ const freezeMethods = (obj)=>{
    reduceDescriptors(obj, (descriptor, name)=>{
        // skip restricted props in strict mode
        if (isFunction(obj) && [
            "arguments",
            "caller",
            "callee"
        ].indexOf(name) !== -1) return false;
        const value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
        }
        if (!descriptor.set) descriptor.set = ()=>{
            throw Error("Can not rewrite read-only method '" + name + "'");
        };
    });
};
const toObjectSet = (arrayOrString, delimiter)=>{
    const obj = {};
    const define = (arr)=>{
        arr.forEach((value)=>{
            obj[value] = true;
        });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
};
const noop = ()=>{};
const toFiniteNumber = (value, defaultValue)=>{
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT)=>{
    let str = "";
    const { length } = alphabet;
    while(size--)str += alphabet[Math.random() * length | 0];
    return str;
};
/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */ function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj)=>{
    const stack = new Array(10);
    const visit = (source, i)=>{
        if (isObject(source)) {
            if (stack.indexOf(source) >= 0) return;
            if (!("toJSON" in source)) {
                stack[i] = source;
                const target = isArray(source) ? [] : {};
                forEach(source, (value, key)=>{
                    const reducedValue = visit(value, i + 1);
                    !isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = undefined;
                return target;
            }
        }
        return source;
    };
    return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing)=>thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
exports.default = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
};

},{"./helpers/bind.js":"haRQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"haRQb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>bind);
"use strict";
function bind(fn, thisArg) {
    return function wrap() {
        return fn.apply(thisArg, arguments);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"cpqD8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _buildURLJs = require("../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _interceptorManagerJs = require("./InterceptorManager.js");
var _interceptorManagerJsDefault = parcelHelpers.interopDefault(_interceptorManagerJs);
var _dispatchRequestJs = require("./dispatchRequest.js");
var _dispatchRequestJsDefault = parcelHelpers.interopDefault(_dispatchRequestJs);
var _mergeConfigJs = require("./mergeConfig.js");
var _mergeConfigJsDefault = parcelHelpers.interopDefault(_mergeConfigJs);
var _buildFullPathJs = require("./buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _validatorJs = require("../helpers/validator.js");
var _validatorJsDefault = parcelHelpers.interopDefault(_validatorJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
const validators = (0, _validatorJsDefault.default).validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */ class Axios {
    constructor(instanceConfig){
        this.defaults = instanceConfig;
        this.interceptors = {
            request: new (0, _interceptorManagerJsDefault.default)(),
            response: new (0, _interceptorManagerJsDefault.default)()
        };
    }
    /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/ // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === "string") {
            config = config || {};
            config.url = configOrUrl;
        } else config = configOrUrl || {};
        config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== undefined) (0, _validatorJsDefault.default).assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
        if (paramsSerializer != null) {
            if ((0, _utilsJsDefault.default).isFunction(paramsSerializer)) config.paramsSerializer = {
                serialize: paramsSerializer
            };
            else (0, _validatorJsDefault.default).assertOptions(paramsSerializer, {
                encode: validators.function,
                serialize: validators.function
            }, true);
        }
        // Set config.method
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        // Flatten headers
        let contextHeaders = headers && (0, _utilsJsDefault.default).merge(headers.common, headers[config.method]);
        headers && (0, _utilsJsDefault.default).forEach([
            "delete",
            "get",
            "head",
            "post",
            "put",
            "patch",
            "common"
        ], (method)=>{
            delete headers[method];
        });
        config.headers = (0, _axiosHeadersJsDefault.default).concat(contextHeaders, headers);
        // filter out skipped interceptors
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) return;
            synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
            requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
            const chain = [
                (0, _dispatchRequestJsDefault.default).bind(this),
                undefined
            ];
            chain.unshift.apply(chain, requestInterceptorChain);
            chain.push.apply(chain, responseInterceptorChain);
            len = chain.length;
            promise = Promise.resolve(config);
            while(i < len)promise = promise.then(chain[i++], chain[i++]);
            return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while(i < len){
            const onFulfilled = requestInterceptorChain[i++];
            const onRejected = requestInterceptorChain[i++];
            try {
                newConfig = onFulfilled(newConfig);
            } catch (error) {
                onRejected.call(this, error);
                break;
            }
        }
        try {
            promise = (0, _dispatchRequestJsDefault.default).call(this, newConfig);
        } catch (error) {
            return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while(i < len)promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        return promise;
    }
    getUri(config) {
        config = (0, _mergeConfigJsDefault.default)(this.defaults, config);
        const fullPath = (0, _buildFullPathJsDefault.default)(config.baseURL, config.url);
        return (0, _buildURLJsDefault.default)(fullPath, config.params, config.paramsSerializer);
    }
}
// Provide aliases for supported request methods
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "options"
], function forEachMethodNoData(method) {
    /*eslint func-names:0*/ Axios.prototype[method] = function(url, config) {
        return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
            method,
            url,
            data: (config || {}).data
        }));
    };
});
(0, _utilsJsDefault.default).forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    /*eslint func-names:0*/ function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
            return this.request((0, _mergeConfigJsDefault.default)(config || {}, {
                method,
                headers: isForm ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url,
                data
            }));
        };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
exports.default = Axios;

},{"./../utils.js":"5By4s","../helpers/buildURL.js":"3bwC2","./InterceptorManager.js":"1VRIM","./dispatchRequest.js":"6sjJ6","./mergeConfig.js":"b85oP","./buildFullPath.js":"1I5TW","../helpers/validator.js":"9vgkY","./AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3bwC2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildURL);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosURLSearchParamsJs = require("../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */ function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/ if (!params) return url;
    const _encode = options && options.encode || encode;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) serializedParams = serializeFn(params, options);
    else serializedParams = (0, _utilsJsDefault.default).isURLSearchParams(params) ? params.toString() : new (0, _axiosURLSearchParamsJsDefault.default)(params, options).toString(_encode);
    if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) url = url.slice(0, hashmarkIndex);
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
}

},{"../utils.js":"5By4s","../helpers/AxiosURLSearchParams.js":"hz84m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hz84m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
"use strict";
/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */ function encode(str) {
    const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\x00"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
    });
}
/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */ function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && (0, _toFormDataJsDefault.default)(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
    this._pairs.push([
        name,
        value
    ]);
};
prototype.toString = function toString(encoder) {
    const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
};
exports.default = AxiosURLSearchParams;

},{"./toFormData.js":"ajoez","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ajoez":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored
var _formDataJs = require("../platform/node/classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var Buffer = require("adfd9b103875c2dd").Buffer;
"use strict";
/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */ function isVisitable(thing) {
    return (0, _utilsJsDefault.default).isPlainObject(thing) || (0, _utilsJsDefault.default).isArray(thing);
}
/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */ function removeBrackets(key) {
    return (0, _utilsJsDefault.default).endsWith(key, "[]") ? key.slice(0, -2) : key;
}
/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */ function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
}
/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */ function isFlatArray(arr) {
    return (0, _utilsJsDefault.default).isArray(arr) && !arr.some(isVisitable);
}
const predicates = (0, _utilsJsDefault.default).toFlatObject((0, _utilsJsDefault.default), {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
});
/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/ /**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */ function toFormData(obj, formData, options) {
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("target must be an object");
    // eslint-disable-next-line no-param-reassign
    formData = formData || new ((0, _formDataJsDefault.default) || FormData)();
    // eslint-disable-next-line no-param-reassign
    options = (0, _utilsJsDefault.default).toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
    }, false, function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !(0, _utilsJsDefault.default).isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && (0, _utilsJsDefault.default).isSpecCompliantForm(formData);
    if (!(0, _utilsJsDefault.default).isFunction(visitor)) throw new TypeError("visitor must be a function");
    function convertValue(value) {
        if (value === null) return "";
        if ((0, _utilsJsDefault.default).isDate(value)) return value.toISOString();
        if (!useBlob && (0, _utilsJsDefault.default).isBlob(value)) throw new (0, _axiosErrorJsDefault.default)("Blob is not supported. Use a Buffer instead.");
        if ((0, _utilsJsDefault.default).isArrayBuffer(value) || (0, _utilsJsDefault.default).isTypedArray(value)) return useBlob && typeof Blob === "function" ? new Blob([
            value
        ]) : Buffer.from(value);
        return value;
    }
    /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */ function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
            if ((0, _utilsJsDefault.default).endsWith(key, "{}")) {
                // eslint-disable-next-line no-param-reassign
                key = metaTokens ? key : key.slice(0, -2);
                // eslint-disable-next-line no-param-reassign
                value = JSON.stringify(value);
            } else if ((0, _utilsJsDefault.default).isArray(value) && isFlatArray(value) || ((0, _utilsJsDefault.default).isFileList(value) || (0, _utilsJsDefault.default).endsWith(key, "[]")) && (arr = (0, _utilsJsDefault.default).toArray(value))) {
                // eslint-disable-next-line no-param-reassign
                key = removeBrackets(key);
                arr.forEach(function each(el, index) {
                    !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && formData.append(// eslint-disable-next-line no-nested-ternary
                    indexes === true ? renderKey([
                        key
                    ], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
                });
                return false;
            }
        }
        if (isVisitable(value)) return true;
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
    });
    function build(value, path) {
        if ((0, _utilsJsDefault.default).isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) throw Error("Circular reference detected in " + path.join("."));
        stack.push(value);
        (0, _utilsJsDefault.default).forEach(value, function each(el, key) {
            const result = !((0, _utilsJsDefault.default).isUndefined(el) || el === null) && visitor.call(formData, el, (0, _utilsJsDefault.default).isString(key) ? key.trim() : key, path, exposedHelpers);
            if (result === true) build(el, path ? path.concat(key) : [
                key
            ]);
        });
        stack.pop();
    }
    if (!(0, _utilsJsDefault.default).isObject(obj)) throw new TypeError("data must be an object");
    build(obj);
    return formData;
}
exports.default = toFormData;

},{"adfd9b103875c2dd":"fCgem","../utils.js":"5By4s","../core/AxiosError.js":"3u8Tl","../platform/node/classes/FormData.js":"aFlee","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"9c62938f1dccc73c":"eIiSV","aceacb6a4531a9d2":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"3u8Tl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */ function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
    else this.stack = new Error().stack;
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
}
(0, _utilsJsDefault.default).inherits(AxiosError, Error, {
    toJSON: function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: (0, _utilsJsDefault.default).toJSONObject(this.config),
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
        };
    }
});
const prototype = AxiosError.prototype;
const descriptors = {};
[
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
].forEach((code)=>{
    descriptors[code] = {
        value: code
    };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", {
    value: true
});
// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps)=>{
    const axiosError = Object.create(prototype);
    (0, _utilsJsDefault.default).toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
    }, (prop)=>{
        return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
};
exports.default = AxiosError;

},{"../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aFlee":[function(require,module,exports) {
// eslint-disable-next-line strict
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1VRIM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
class InterceptorManager {
    constructor(){
        this.handlers = [];
    }
    /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ use(fulfilled, rejected, options) {
        this.handlers.push({
            fulfilled,
            rejected,
            synchronous: options ? options.synchronous : false,
            runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
    }
    /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ eject(id) {
        if (this.handlers[id]) this.handlers[id] = null;
    }
    /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ clear() {
        if (this.handlers) this.handlers = [];
    }
    /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ forEach(fn) {
        (0, _utilsJsDefault.default).forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) fn(h);
        });
    }
}
exports.default = InterceptorManager;

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6sjJ6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>dispatchRequest);
var _transformDataJs = require("./transformData.js");
var _transformDataJsDefault = parcelHelpers.interopDefault(_transformDataJs);
var _isCancelJs = require("../cancel/isCancel.js");
var _isCancelJsDefault = parcelHelpers.interopDefault(_isCancelJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _adaptersJs = require("../adapters/adapters.js");
var _adaptersJsDefault = parcelHelpers.interopDefault(_adaptersJs);
"use strict";
/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */ function throwIfCancellationRequested(config) {
    if (config.cancelToken) config.cancelToken.throwIfRequested();
    if (config.signal && config.signal.aborted) throw new (0, _canceledErrorJsDefault.default)(null, config);
}
function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = (0, _axiosHeadersJsDefault.default).from(config.headers);
    // Transform request data
    config.data = (0, _transformDataJsDefault.default).call(config, config.transformRequest);
    if ([
        "post",
        "put",
        "patch"
    ].indexOf(config.method) !== -1) config.headers.setContentType("application/x-www-form-urlencoded", false);
    const adapter = (0, _adaptersJsDefault.default).getAdapter(config.adapter || (0, _indexJsDefault.default).adapter);
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        // Transform response data
        response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, response);
        response.headers = (0, _axiosHeadersJsDefault.default).from(response.headers);
        return response;
    }, function onAdapterRejection(reason) {
        if (!(0, _isCancelJsDefault.default)(reason)) {
            throwIfCancellationRequested(config);
            // Transform response data
            if (reason && reason.response) {
                reason.response.data = (0, _transformDataJsDefault.default).call(config, config.transformResponse, reason.response);
                reason.response.headers = (0, _axiosHeadersJsDefault.default).from(reason.response.headers);
            }
        }
        return Promise.reject(reason);
    });
}

},{"./transformData.js":"eRqJY","../cancel/isCancel.js":"a0VmF","../defaults/index.js":"hXfHM","../cancel/CanceledError.js":"9PwCG","../core/AxiosHeaders.js":"cgSSx","../adapters/adapters.js":"d7JxI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eRqJY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>transformData);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../defaults/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
function transformData(fns, response) {
    const config = this || (0, _indexJsDefault.default);
    const context = response || config;
    const headers = (0, _axiosHeadersJsDefault.default).from(context.headers);
    let data = context.data;
    (0, _utilsJsDefault.default).forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });
    headers.normalize();
    return data;
}

},{"./../utils.js":"5By4s","../defaults/index.js":"hXfHM","../core/AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hXfHM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _transitionalJs = require("./transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _toFormDataJs = require("../helpers/toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _toURLEncodedFormJs = require("../helpers/toURLEncodedForm.js");
var _toURLEncodedFormJsDefault = parcelHelpers.interopDefault(_toURLEncodedFormJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _formDataToJSONJs = require("../helpers/formDataToJSON.js");
var _formDataToJSONJsDefault = parcelHelpers.interopDefault(_formDataToJSONJs);
"use strict";
/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */ function stringifySafely(rawValue, parser, encoder) {
    if ((0, _utilsJsDefault.default).isString(rawValue)) try {
        (parser || JSON.parse)(rawValue);
        return (0, _utilsJsDefault.default).trim(rawValue);
    } catch (e) {
        if (e.name !== "SyntaxError") throw e;
    }
    return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
    transitional: (0, _transitionalJsDefault.default),
    adapter: (0, _indexJsDefault.default).isNode ? "http" : "xhr",
    transformRequest: [
        function transformRequest(data, headers) {
            const contentType = headers.getContentType() || "";
            const hasJSONContentType = contentType.indexOf("application/json") > -1;
            const isObjectPayload = (0, _utilsJsDefault.default).isObject(data);
            if (isObjectPayload && (0, _utilsJsDefault.default).isHTMLForm(data)) data = new FormData(data);
            const isFormData = (0, _utilsJsDefault.default).isFormData(data);
            if (isFormData) {
                if (!hasJSONContentType) return data;
                return hasJSONContentType ? JSON.stringify((0, _formDataToJSONJsDefault.default)(data)) : data;
            }
            if ((0, _utilsJsDefault.default).isArrayBuffer(data) || (0, _utilsJsDefault.default).isBuffer(data) || (0, _utilsJsDefault.default).isStream(data) || (0, _utilsJsDefault.default).isFile(data) || (0, _utilsJsDefault.default).isBlob(data)) return data;
            if ((0, _utilsJsDefault.default).isArrayBufferView(data)) return data.buffer;
            if ((0, _utilsJsDefault.default).isURLSearchParams(data)) {
                headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
                return data.toString();
            }
            let isFileList;
            if (isObjectPayload) {
                if (contentType.indexOf("application/x-www-form-urlencoded") > -1) return (0, _toURLEncodedFormJsDefault.default)(data, this.formSerializer).toString();
                if ((isFileList = (0, _utilsJsDefault.default).isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
                    const _FormData = this.env && this.env.FormData;
                    return (0, _toFormDataJsDefault.default)(isFileList ? {
                        "files[]": data
                    } : data, _FormData && new _FormData(), this.formSerializer);
                }
            }
            if (isObjectPayload || hasJSONContentType) {
                headers.setContentType("application/json", false);
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            const transitional = this.transitional || defaults.transitional;
            const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
            const JSONRequested = this.responseType === "json";
            if (data && (0, _utilsJsDefault.default).isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
                const silentJSONParsing = transitional && transitional.silentJSONParsing;
                const strictJSONParsing = !silentJSONParsing && JSONRequested;
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === "SyntaxError") throw (0, _axiosErrorJsDefault.default).from(e, (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE, this, null, this.response);
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: (0, _indexJsDefault.default).classes.FormData,
        Blob: (0, _indexJsDefault.default).classes.Blob
    },
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": undefined
        }
    }
};
(0, _utilsJsDefault.default).forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
], (method)=>{
    defaults.headers[method] = {};
});
exports.default = defaults;

},{"../utils.js":"5By4s","../core/AxiosError.js":"3u8Tl","./transitional.js":"lM32f","../helpers/toFormData.js":"ajoez","../helpers/toURLEncodedForm.js":"9hjry","../platform/index.js":"7tDev","../helpers/formDataToJSON.js":"01RfH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lM32f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9hjry":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>toURLEncodedForm);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _toFormDataJs = require("./toFormData.js");
var _toFormDataJsDefault = parcelHelpers.interopDefault(_toFormDataJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
function toURLEncodedForm(data, options) {
    return (0, _toFormDataJsDefault.default)(data, new (0, _indexJsDefault.default).classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
            if ((0, _indexJsDefault.default).isNode && (0, _utilsJsDefault.default).isBuffer(value)) {
                this.append(key, value.toString("base64"));
                return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
        }
    }, options));
}

},{"../utils.js":"5By4s","./toFormData.js":"ajoez","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7tDev":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _indexJsDefault.default));
var _indexJs = require("./node/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);

},{"./node/index.js":"cVeqE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cVeqE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _urlsearchParamsJs = require("./classes/URLSearchParams.js");
var _urlsearchParamsJsDefault = parcelHelpers.interopDefault(_urlsearchParamsJs);
var _formDataJs = require("./classes/FormData.js");
var _formDataJsDefault = parcelHelpers.interopDefault(_formDataJs);
var _blobJs = require("./classes/Blob.js");
var _blobJsDefault = parcelHelpers.interopDefault(_blobJs);
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */ const isStandardBrowserEnv = (()=>{
    let product;
    if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) return false;
    return typeof window !== "undefined" && typeof document !== "undefined";
})();
/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */ const isStandardBrowserWebWorkerEnv = (()=>{
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
exports.default = {
    isBrowser: true,
    classes: {
        URLSearchParams: (0, _urlsearchParamsJsDefault.default),
        FormData: (0, _formDataJsDefault.default),
        Blob: (0, _blobJsDefault.default)
    },
    isStandardBrowserEnv,
    isStandardBrowserWebWorkerEnv,
    protocols: [
        "http",
        "https",
        "file",
        "blob",
        "url",
        "data"
    ]
};

},{"./classes/URLSearchParams.js":"5cIHE","./classes/FormData.js":"7i1jd","./classes/Blob.js":"8chF6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5cIHE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosURLSearchParamsJs = require("../../../helpers/AxiosURLSearchParams.js");
var _axiosURLSearchParamsJsDefault = parcelHelpers.interopDefault(_axiosURLSearchParamsJs);
"use strict";
exports.default = typeof URLSearchParams !== "undefined" ? URLSearchParams : (0, _axiosURLSearchParamsJsDefault.default);

},{"../../../helpers/AxiosURLSearchParams.js":"hz84m","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7i1jd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof FormData !== "undefined" ? FormData : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8chF6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
exports.default = typeof Blob !== "undefined" ? Blob : null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"01RfH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */ function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return (0, _utilsJsDefault.default).matchAll(/\w+|\[(\w*)]/g, name).map((match)=>{
        return match[0] === "[]" ? "" : match[1] || match[0];
    });
}
/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */ function arrayToObject(arr) {
    const obj = {};
    const keys = Object.keys(arr);
    let i;
    const len = keys.length;
    let key;
    for(i = 0; i < len; i++){
        key = keys[i];
        obj[key] = arr[key];
    }
    return obj;
}
/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */ function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
        let name = path[index++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && (0, _utilsJsDefault.default).isArray(target) ? target.length : name;
        if (isLast) {
            if ((0, _utilsJsDefault.default).hasOwnProp(target, name)) target[name] = [
                target[name],
                value
            ];
            else target[name] = value;
            return !isNumericKey;
        }
        if (!target[name] || !(0, _utilsJsDefault.default).isObject(target[name])) target[name] = [];
        const result = buildPath(path, value, target[name], index);
        if (result && (0, _utilsJsDefault.default).isArray(target[name])) target[name] = arrayToObject(target[name]);
        return !isNumericKey;
    }
    if ((0, _utilsJsDefault.default).isFormData(formData) && (0, _utilsJsDefault.default).isFunction(formData.entries)) {
        const obj = {};
        (0, _utilsJsDefault.default).forEachEntry(formData, (name, value)=>{
            buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
    }
    return null;
}
exports.default = formDataToJSON;

},{"../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cgSSx":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _parseHeadersJs = require("../helpers/parseHeaders.js");
var _parseHeadersJsDefault = parcelHelpers.interopDefault(_parseHeadersJs);
"use strict";
const $internals = Symbol("internals");
function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
    if (value === false || value == null) return value;
    return (0, _utilsJsDefault.default).isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
    const tokens = Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while(match = tokensRE.exec(str))tokens[match[1]] = match[2];
    return tokens;
}
const isValidHeaderName = (str)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if ((0, _utilsJsDefault.default).isFunction(filter)) return filter.call(this, value, header);
    if (isHeaderNameFilter) value = header;
    if (!(0, _utilsJsDefault.default).isString(value)) return;
    if ((0, _utilsJsDefault.default).isString(filter)) return value.indexOf(filter) !== -1;
    if ((0, _utilsJsDefault.default).isRegExp(filter)) return filter.test(value);
}
function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str)=>{
        return char.toUpperCase() + str;
    });
}
function buildAccessors(obj, header) {
    const accessorName = (0, _utilsJsDefault.default).toCamelCase(" " + header);
    [
        "get",
        "set",
        "has"
    ].forEach((methodName)=>{
        Object.defineProperty(obj, methodName + accessorName, {
            value: function(arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
        });
    });
}
class AxiosHeaders {
    constructor(headers){
        headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
        const self = this;
        function setHeader(_value, _header, _rewrite) {
            const lHeader = normalizeHeader(_header);
            if (!lHeader) throw new Error("header name must be a non-empty string");
            const key = (0, _utilsJsDefault.default).findKey(self, lHeader);
            if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) self[key || _header] = normalizeValue(_value);
        }
        const setHeaders = (headers, _rewrite)=>(0, _utilsJsDefault.default).forEach(headers, (_value, _header)=>setHeader(_value, _header, _rewrite));
        if ((0, _utilsJsDefault.default).isPlainObject(header) || header instanceof this.constructor) setHeaders(header, valueOrRewrite);
        else if ((0, _utilsJsDefault.default).isString(header) && (header = header.trim()) && !isValidHeaderName(header)) setHeaders((0, _parseHeadersJsDefault.default)(header), valueOrRewrite);
        else header != null && setHeader(valueOrRewrite, header, rewrite);
        return this;
    }
    get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
            const key = (0, _utilsJsDefault.default).findKey(this, header);
            if (key) {
                const value = this[key];
                if (!parser) return value;
                if (parser === true) return parseTokens(value);
                if ((0, _utilsJsDefault.default).isFunction(parser)) return parser.call(this, value, key);
                if ((0, _utilsJsDefault.default).isRegExp(parser)) return parser.exec(value);
                throw new TypeError("parser must be boolean|regexp|function");
            }
        }
    }
    has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
            const key = (0, _utilsJsDefault.default).findKey(this, header);
            return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
    }
    delete(header, matcher) {
        const self = this;
        let deleted = false;
        function deleteHeader(_header) {
            _header = normalizeHeader(_header);
            if (_header) {
                const key = (0, _utilsJsDefault.default).findKey(self, _header);
                if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
                    delete self[key];
                    deleted = true;
                }
            }
        }
        if ((0, _utilsJsDefault.default).isArray(header)) header.forEach(deleteHeader);
        else deleteHeader(header);
        return deleted;
    }
    clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while(i--){
            const key = keys[i];
            if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
                delete this[key];
                deleted = true;
            }
        }
        return deleted;
    }
    normalize(format) {
        const self = this;
        const headers = {};
        (0, _utilsJsDefault.default).forEach(this, (value, header)=>{
            const key = (0, _utilsJsDefault.default).findKey(headers, header);
            if (key) {
                self[key] = normalizeValue(value);
                delete self[header];
                return;
            }
            const normalized = format ? formatHeader(header) : String(header).trim();
            if (normalized !== header) delete self[header];
            self[normalized] = normalizeValue(value);
            headers[normalized] = true;
        });
        return this;
    }
    concat(...targets) {
        return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
        const obj = Object.create(null);
        (0, _utilsJsDefault.default).forEach(this, (value, header)=>{
            value != null && value !== false && (obj[header] = asStrings && (0, _utilsJsDefault.default).isArray(value) ? value.join(", ") : value);
        });
        return obj;
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
        return Object.entries(this.toJSON()).map(([header, value])=>header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
        return "AxiosHeaders";
    }
    static from(thing) {
        return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target)=>computed.set(target));
        return computed;
    }
    static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
            accessors: {}
        };
        const accessors = internals.accessors;
        const prototype = this.prototype;
        function defineAccessor(_header) {
            const lHeader = normalizeHeader(_header);
            if (!accessors[lHeader]) {
                buildAccessors(prototype, _header);
                accessors[lHeader] = true;
            }
        }
        (0, _utilsJsDefault.default).isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
    }
}
AxiosHeaders.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
]);
// reserved names hotfix
(0, _utilsJsDefault.default).reduceDescriptors(AxiosHeaders.prototype, ({ value }, key)=>{
    let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
        get: ()=>value,
        set (headerValue) {
            this[mapped] = headerValue;
        }
    };
});
(0, _utilsJsDefault.default).freezeMethods(AxiosHeaders);
exports.default = AxiosHeaders;

},{"../utils.js":"5By4s","../helpers/parseHeaders.js":"kqDd5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqDd5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = (0, _utilsJsDefault.default).toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
]);
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */ exports.default = (rawHeaders)=>{
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) return;
        if (key === "set-cookie") {
            if (parsed[key]) parsed[key].push(val);
            else parsed[key] = [
                val
            ];
        } else parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    });
    return parsed;
};

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a0VmF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isCancel);
"use strict";
function isCancel(value) {
    return !!(value && value.__CANCEL__);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9PwCG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */ function CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    (0, _axiosErrorJsDefault.default).call(this, message == null ? "canceled" : message, (0, _axiosErrorJsDefault.default).ERR_CANCELED, config, request);
    this.name = "CanceledError";
}
(0, _utilsJsDefault.default).inherits(CanceledError, (0, _axiosErrorJsDefault.default), {
    __CANCEL__: true
});
exports.default = CanceledError;

},{"../core/AxiosError.js":"3u8Tl","../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7JxI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _httpJs = require("./http.js");
var _httpJsDefault = parcelHelpers.interopDefault(_httpJs);
var _xhrJs = require("./xhr.js");
var _xhrJsDefault = parcelHelpers.interopDefault(_xhrJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
const knownAdapters = {
    http: (0, _httpJsDefault.default),
    xhr: (0, _xhrJsDefault.default)
};
(0, _utilsJsDefault.default).forEach(knownAdapters, (fn, value)=>{
    if (fn) {
        try {
            Object.defineProperty(fn, "name", {
                value
            });
        } catch (e) {
        // eslint-disable-next-line no-empty
        }
        Object.defineProperty(fn, "adapterName", {
            value
        });
    }
});
exports.default = {
    getAdapter: (adapters)=>{
        adapters = (0, _utilsJsDefault.default).isArray(adapters) ? adapters : [
            adapters
        ];
        const { length } = adapters;
        let nameOrAdapter;
        let adapter;
        for(let i = 0; i < length; i++){
            nameOrAdapter = adapters[i];
            if (adapter = (0, _utilsJsDefault.default).isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) break;
        }
        if (!adapter) {
            if (adapter === false) throw new (0, _axiosErrorJsDefault.default)(`Adapter ${nameOrAdapter} is not supported by the environment`, "ERR_NOT_SUPPORT");
            throw new Error((0, _utilsJsDefault.default).hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`);
        }
        if (!(0, _utilsJsDefault.default).isFunction(adapter)) throw new TypeError("adapter is not a function");
        return adapter;
    },
    adapters: knownAdapters
};

},{"../utils.js":"5By4s","./http.js":"aFlee","./xhr.js":"ldm57","../core/AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ldm57":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _settleJs = require("./../core/settle.js");
var _settleJsDefault = parcelHelpers.interopDefault(_settleJs);
var _cookiesJs = require("./../helpers/cookies.js");
var _cookiesJsDefault = parcelHelpers.interopDefault(_cookiesJs);
var _buildURLJs = require("./../helpers/buildURL.js");
var _buildURLJsDefault = parcelHelpers.interopDefault(_buildURLJs);
var _buildFullPathJs = require("../core/buildFullPath.js");
var _buildFullPathJsDefault = parcelHelpers.interopDefault(_buildFullPathJs);
var _isURLSameOriginJs = require("./../helpers/isURLSameOrigin.js");
var _isURLSameOriginJsDefault = parcelHelpers.interopDefault(_isURLSameOriginJs);
var _transitionalJs = require("../defaults/transitional.js");
var _transitionalJsDefault = parcelHelpers.interopDefault(_transitionalJs);
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
var _canceledErrorJs = require("../cancel/CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
var _parseProtocolJs = require("../helpers/parseProtocol.js");
var _parseProtocolJsDefault = parcelHelpers.interopDefault(_parseProtocolJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
var _axiosHeadersJs = require("../core/AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
var _speedometerJs = require("../helpers/speedometer.js");
var _speedometerJsDefault = parcelHelpers.interopDefault(_speedometerJs);
"use strict";
function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = (0, _speedometerJsDefault.default)(50, 250);
    return (e)=>{
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : undefined;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
            loaded,
            total,
            progress: total ? loaded / total : undefined,
            bytes: progressBytes,
            rate: rate ? rate : undefined,
            estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
            event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
    };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
exports.default = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = (0, _axiosHeadersJsDefault.default).from(config.headers).normalize();
        const responseType = config.responseType;
        let onCanceled;
        function done() {
            if (config.cancelToken) config.cancelToken.unsubscribe(onCanceled);
            if (config.signal) config.signal.removeEventListener("abort", onCanceled);
        }
        if ((0, _utilsJsDefault.default).isFormData(requestData)) {
            if ((0, _indexJsDefault.default).isStandardBrowserEnv || (0, _indexJsDefault.default).isStandardBrowserWebWorkerEnv) requestHeaders.setContentType(false); // Let the browser set it
            else requestHeaders.setContentType("multipart/form-data;", false); // mobile/desktop app frameworks
        }
        let request = new XMLHttpRequest();
        // HTTP basic authentication
        if (config.auth) {
            const username = config.auth.username || "";
            const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = (0, _buildFullPathJsDefault.default)(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), (0, _buildURLJsDefault.default)(fullPath, config.params, config.paramsSerializer), true);
        // Set the request timeout in MS
        request.timeout = config.timeout;
        function onloadend() {
            if (!request) return;
            // Prepare the response
            const responseHeaders = (0, _axiosHeadersJsDefault.default).from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
            const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            const response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config,
                request
            };
            (0, _settleJsDefault.default)(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            // Clean up request
            request = null;
        }
        if ("onloadend" in request) // Use onloadend if available
        request.onloadend = onloadend;
        else // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) return;
            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) return;
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
        };
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
            if (!request) return;
            reject(new (0, _axiosErrorJsDefault.default)("Request aborted", (0, _axiosErrorJsDefault.default).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Handle low level network errors
        request.onerror = function handleError() {
            // Real errors are hidden from us by the browser
            // onerror should only fire if it's a network error
            reject(new (0, _axiosErrorJsDefault.default)("Network Error", (0, _axiosErrorJsDefault.default).ERR_NETWORK, config, request));
            // Clean up request
            request = null;
        };
        // Handle timeout
        request.ontimeout = function handleTimeout() {
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || (0, _transitionalJsDefault.default);
            if (config.timeoutErrorMessage) timeoutErrorMessage = config.timeoutErrorMessage;
            reject(new (0, _axiosErrorJsDefault.default)(timeoutErrorMessage, transitional.clarifyTimeoutError ? (0, _axiosErrorJsDefault.default).ETIMEDOUT : (0, _axiosErrorJsDefault.default).ECONNABORTED, config, request));
            // Clean up request
            request = null;
        };
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if ((0, _indexJsDefault.default).isStandardBrowserEnv) {
            // Add xsrf header
            const xsrfValue = (config.withCredentials || (0, _isURLSameOriginJsDefault.default)(fullPath)) && config.xsrfCookieName && (0, _cookiesJsDefault.default).read(config.xsrfCookieName);
            if (xsrfValue) requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);
        // Add headers to the request
        if ("setRequestHeader" in request) (0, _utilsJsDefault.default).forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
        });
        // Add withCredentials to request if needed
        if (!(0, _utilsJsDefault.default).isUndefined(config.withCredentials)) request.withCredentials = !!config.withCredentials;
        // Add responseType to request if needed
        if (responseType && responseType !== "json") request.responseType = config.responseType;
        // Handle progress if needed
        if (typeof config.onDownloadProgress === "function") request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === "function" && request.upload) request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        if (config.cancelToken || config.signal) {
            // Handle cancellation
            // eslint-disable-next-line func-names
            onCanceled = (cancel)=>{
                if (!request) return;
                reject(!cancel || cancel.type ? new (0, _canceledErrorJsDefault.default)(null, config, request) : cancel);
                request.abort();
                request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
        const protocol = (0, _parseProtocolJsDefault.default)(fullPath);
        if (protocol && (0, _indexJsDefault.default).protocols.indexOf(protocol) === -1) {
            reject(new (0, _axiosErrorJsDefault.default)("Unsupported protocol " + protocol + ":", (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST, config));
            return;
        }
        // Send the request
        request.send(requestData || null);
    });
};

},{"./../utils.js":"5By4s","./../core/settle.js":"dD9aC","./../helpers/cookies.js":"4WJjt","./../helpers/buildURL.js":"3bwC2","../core/buildFullPath.js":"1I5TW","./../helpers/isURLSameOrigin.js":"lxXtv","../defaults/transitional.js":"lM32f","../core/AxiosError.js":"3u8Tl","../cancel/CanceledError.js":"9PwCG","../helpers/parseProtocol.js":"7NfWU","../platform/index.js":"7tDev","../core/AxiosHeaders.js":"cgSSx","../helpers/speedometer.js":"gQeo1","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dD9aC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>settle);
var _axiosErrorJs = require("./AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
function settle(resolve, reject, response) {
    const validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) resolve(response);
    else reject(new (0, _axiosErrorJsDefault.default)("Request failed with status code " + response.status, [
        (0, _axiosErrorJsDefault.default).ERR_BAD_REQUEST,
        (0, _axiosErrorJsDefault.default).ERR_BAD_RESPONSE
    ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
}

},{"./AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4WJjt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
exports.default = (0, _indexJsDefault.default).isStandardBrowserEnv ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
    return {
        write: function write(name, value, expires, path, domain, secure) {
            const cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if ((0, _utilsJsDefault.default).isNumber(expires)) cookie.push("expires=" + new Date(expires).toGMTString());
            if ((0, _utilsJsDefault.default).isString(path)) cookie.push("path=" + path);
            if ((0, _utilsJsDefault.default).isString(domain)) cookie.push("domain=" + domain);
            if (secure === true) cookie.push("secure");
            document.cookie = cookie.join("; ");
        },
        read: function read(name) {
            const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
            this.write(name, "", Date.now() - 86400000);
        }
    };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return {
        write: function write() {},
        read: function read() {
            return null;
        },
        remove: function remove() {}
    };
}();

},{"./../utils.js":"5By4s","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1I5TW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>buildFullPath);
var _isAbsoluteURLJs = require("../helpers/isAbsoluteURL.js");
var _isAbsoluteURLJsDefault = parcelHelpers.interopDefault(_isAbsoluteURLJs);
var _combineURLsJs = require("../helpers/combineURLs.js");
var _combineURLsJsDefault = parcelHelpers.interopDefault(_combineURLsJs);
"use strict";
function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !(0, _isAbsoluteURLJsDefault.default)(requestedURL)) return (0, _combineURLsJsDefault.default)(baseURL, requestedURL);
    return requestedURL;
}

},{"../helpers/isAbsoluteURL.js":"jD6NM","../helpers/combineURLs.js":"brOWK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jD6NM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isAbsoluteURL);
"use strict";
function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"brOWK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>combineURLs);
"use strict";
function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lxXtv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _indexJs = require("../platform/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
"use strict";
exports.default = (0, _indexJsDefault.default).isStandardBrowserEnv ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */ function resolveURL(url) {
        let href = url;
        if (msie) {
            // IE needs attribute set twice to normalize properties
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    originURL = resolveURL(window.location.href);
    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */ return function isURLSameOrigin(requestURL) {
        const parsed = (0, _utilsJsDefault.default).isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
        return true;
    };
}();

},{"./../utils.js":"5By4s","../platform/index.js":"7tDev","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7NfWU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parseProtocol);
"use strict";
function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQeo1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
"use strict";
/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */ function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== undefined ? min : 1000;
    return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) firstSampleTS = now;
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while(i !== head){
            bytesCount += bytes[i++];
            i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) tail = (tail + 1) % samplesCount;
        if (now - firstSampleTS < min) return;
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
}
exports.default = speedometer;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b85oP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mergeConfig);
var _utilsJs = require("../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
var _axiosHeadersJs = require("./AxiosHeaders.js");
var _axiosHeadersJsDefault = parcelHelpers.interopDefault(_axiosHeadersJs);
"use strict";
const headersToObject = (thing)=>thing instanceof (0, _axiosHeadersJsDefault.default) ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, caseless) {
        if ((0, _utilsJsDefault.default).isPlainObject(target) && (0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge.call({
            caseless
        }, target, source);
        else if ((0, _utilsJsDefault.default).isPlainObject(source)) return (0, _utilsJsDefault.default).merge({}, source);
        else if ((0, _utilsJsDefault.default).isArray(source)) return source.slice();
        return source;
    }
    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, caseless) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(a, b, caseless);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a, caseless);
    }
    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
    }
    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
        if (!(0, _utilsJsDefault.default).isUndefined(b)) return getMergedValue(undefined, b);
        else if (!(0, _utilsJsDefault.default).isUndefined(a)) return getMergedValue(undefined, a);
    }
    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
        if (prop in config2) return getMergedValue(a, b);
        else if (prop in config1) return getMergedValue(undefined, a);
    }
    const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b)=>mergeDeepProperties(headersToObject(a), headersToObject(b), true)
    };
    (0, _utilsJsDefault.default).forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge(config1[prop], config2[prop], prop);
        (0, _utilsJsDefault.default).isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
}

},{"../utils.js":"5By4s","./AxiosHeaders.js":"cgSSx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9vgkY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataJs = require("../env/data.js");
var _axiosErrorJs = require("../core/AxiosError.js");
var _axiosErrorJsDefault = parcelHelpers.interopDefault(_axiosErrorJs);
"use strict";
const validators = {};
// eslint-disable-next-line func-names
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach((type, i)=>{
    validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
});
const deprecatedWarnings = {};
/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */ validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return "[Axios v" + (0, _dataJs.VERSION) + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    // eslint-disable-next-line func-names
    return (value, opt, opts)=>{
        if (validator === false) throw new (0, _axiosErrorJsDefault.default)(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), (0, _axiosErrorJsDefault.default).ERR_DEPRECATED);
        if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            // eslint-disable-next-line no-console
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */ function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") throw new (0, _axiosErrorJsDefault.default)("options must be an object", (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
    const keys = Object.keys(options);
    let i = keys.length;
    while(i-- > 0){
        const opt = keys[i];
        const validator = schema[opt];
        if (validator) {
            const value = options[opt];
            const result = value === undefined || validator(value, opt, options);
            if (result !== true) throw new (0, _axiosErrorJsDefault.default)("option " + opt + " must be " + result, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION_VALUE);
            continue;
        }
        if (allowUnknown !== true) throw new (0, _axiosErrorJsDefault.default)("Unknown option " + opt, (0, _axiosErrorJsDefault.default).ERR_BAD_OPTION);
    }
}
exports.default = {
    assertOptions,
    validators
};

},{"../env/data.js":"h29L9","../core/AxiosError.js":"3u8Tl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h29L9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VERSION", ()=>VERSION);
const VERSION = "1.5.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"45wzn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _canceledErrorJs = require("./CanceledError.js");
var _canceledErrorJsDefault = parcelHelpers.interopDefault(_canceledErrorJs);
"use strict";
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */ class CancelToken {
    constructor(executor){
        if (typeof executor !== "function") throw new TypeError("executor must be a function.");
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
        });
        const token = this;
        // eslint-disable-next-line func-names
        this.promise.then((cancel)=>{
            if (!token._listeners) return;
            let i = token._listeners.length;
            while(i-- > 0)token._listeners[i](cancel);
            token._listeners = null;
        });
        // eslint-disable-next-line func-names
        this.promise.then = (onfulfilled)=>{
            let _resolve;
            // eslint-disable-next-line func-names
            const promise = new Promise((resolve)=>{
                token.subscribe(resolve);
                _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
                token.unsubscribe(_resolve);
            };
            return promise;
        };
        executor(function cancel(message, config, request) {
            if (token.reason) // Cancellation has already been requested
            return;
            token.reason = new (0, _canceledErrorJsDefault.default)(message, config, request);
            resolvePromise(token.reason);
        });
    }
    /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ throwIfRequested() {
        if (this.reason) throw this.reason;
    }
    /**
   * Subscribe to the cancel signal
   */ subscribe(listener) {
        if (this.reason) {
            listener(this.reason);
            return;
        }
        if (this._listeners) this._listeners.push(listener);
        else this._listeners = [
            listener
        ];
    }
    /**
   * Unsubscribe from the cancel signal
   */ unsubscribe(listener) {
        if (!this._listeners) return;
        const index = this._listeners.indexOf(listener);
        if (index !== -1) this._listeners.splice(index, 1);
    }
    /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ static source() {
        let cancel;
        const token = new CancelToken(function executor(c) {
            cancel = c;
        });
        return {
            token,
            cancel
        };
    }
}
exports.default = CancelToken;

},{"./CanceledError.js":"9PwCG","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dyQ8N":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>spread);
"use strict";
function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eyiLq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isAxiosError);
var _utilsJs = require("./../utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
"use strict";
function isAxiosError(payload) {
    return (0, _utilsJsDefault.default).isObject(payload) && payload.isAxiosError === true;
}

},{"./../utils.js":"5By4s","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fdR61":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value])=>{
    HttpStatusCode[value] = key;
});
exports.default = HttpStatusCode;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Mcnf":[function(require,module,exports) {
/*eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hideAlert", ()=>hideAlert);
parcelHelpers.export(exports, "showAlert", ()=>showAlert);
const hideAlert = ()=>{
    const el = document.querySelector(".alert");
    if (el) el.parentElement.removeChild(el);
};
const showAlert = (type, msg)=>{
    hideAlert();
    const markup = `<div class="alert alert--${type}">${msg}</div>`;
    document.querySelector("body").insertAdjacentHTML("afterbegin", markup);
    window.setTimeout(hideAlert, 5000);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"xvuTT":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "displayMap", ()=>displayMap);
const displayMap = (locations)=>{
    const map = L.map("map").setView([
        34.111745,
        -118.113491
    ], 13);
    L.tileLayer("https://tiles.stadiamaps.com/tiles/alidade_smooth/{z}/{x}/{y}{r}.{ext}", {
        minZoom: 3,
        maxZoom: 20,
        attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        ext: "png",
        crossOrigin: "",
        interactive: false,
        zoom: 200000
    }).addTo(map);
    const icon = L.icon({
        iconUrl: "../img/pin.png",
        iconSize: [
            20,
            25
        ]
    });
    const points = [];
    locations.forEach((loc)=>{
        points.push([
            loc.coordinates[1],
            loc.coordinates[0]
        ]);
        L.marker([
            loc.coordinates[1],
            loc.coordinates[0]
        ], {
            icon: icon
        }).addTo(map).bindPopup(`<p>Day ${loc.day}: ${loc.description}</p>`, {
            autoClose: false
        }).openPopup();
    });
    const bounds = L.latLngBounds(points).pad(0.5);
    map.fitBounds(bounds);
    map.setZoom(6);
    map.scrollWheelZoom.disable();
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l3cGY":[function(require,module,exports) {
/* eslint-disable */ // Update data function
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "updateData", ()=>updateData);
var _axios = require("axios");
var _axiosDefault = parcelHelpers.interopDefault(_axios);
var _alerts = require("./alerts");
const updateData = async (name, email)=>{
    try {
        const res = await (0, _axiosDefault.default)({
            method: "PATCH",
            url: "http://127.0.0.1:3000/api/v1/users/updateMe",
            data: {
                name,
                email
            }
        });
        if (res.data.status === "Success") (0, _alerts.showAlert)("success", "Data changed successfuly!");
    } catch (err) {
        (0, _alerts.showAlert)("error", err.response.data.message);
    }
};

},{"axios":"jo6P5","./alerts":"6Mcnf","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7FL8t":[function(require,module,exports) {
const mongoose = require("17d3e24d020b5aa4");
const slugify = require("fe7d67012634bcb1");
// const User = require('./userModel');
// const validator = require('validator');
const toursSchema = new mongoose.Schema({
    name: {
        type: String,
        required: [
            true,
            "A tour must have a name <Error string>"
        ],
        unique: true,
        trim: true,
        maxlength: [
            40,
            "A tour name must have less or equal than 40 characters"
        ],
        minlength: [
            10,
            "A tour name must have more or equal than 10 characters"
        ]
    },
    slug: String,
    duration: {
        type: Number,
        required: [
            true,
            "A tour must have a duration"
        ]
    },
    maxGroupSize: {
        type: Number,
        required: [
            true,
            "A tour must have a group size"
        ]
    },
    difficulty: {
        type: String,
        required: [
            true,
            "A tour must have a difficulty"
        ],
        enum: {
            values: [
                "easy",
                "medium",
                "difficult"
            ],
            message: "Dificulty is either easy, medium or difficult"
        }
    },
    ratingsAverage: {
        type: Number,
        default: 4.5,
        min: [
            1,
            "Rating must be above or equal 1.0"
        ],
        max: [
            5,
            "Rating must be above or equal 5.0"
        ],
        set: (val)=>Math.round(val * 10) / 10
    },
    ratingsQuantity: {
        type: Number,
        default: 0
    },
    price: {
        type: Number,
        required: [
            true,
            "A tour must have a price"
        ]
    },
    priceDiscount: {
        type: Number,
        validate: {
            validator: function(val) {
                return val < this.price;
            },
            message: "Discount price({VALUE}) should be below the regular price"
        }
    },
    summary: {
        type: String,
        trim: true,
        required: [
            true,
            "A tour must have a summary"
        ]
    },
    description: {
        type: String,
        required: [
            true,
            "A tour must have a price"
        ],
        trim: true
    },
    imageCover: {
        type: String,
        required: [
            true,
            "A tour must have a cover image"
        ]
    },
    images: [
        String
    ],
    createdAt: {
        type: Date,
        default: Date.now(),
        select: false
    },
    startDates: [
        Date
    ],
    secretTour: {
        type: Boolean,
        default: false
    },
    startLocation: {
        //* GeoJSON - embeded object
        type: {
            type: String,
            default: "Point",
            enum: [
                "Point"
            ],
            message: "Location can only be point"
        },
        coordinates: [
            Number
        ],
        address: String,
        description: String
    },
    locations: [
        //! We always need to use array to specify more items
        {
            type: {
                type: String,
                default: "Point",
                enum: [
                    "Point"
                ],
                message: "Location can only be point"
            },
            coordinates: [
                Number
            ],
            address: String,
            description: String,
            day: Number
        }
    ],
    guides: [
        {
            type: mongoose.Schema.ObjectId,
            ref: "User"
        }
    ]
}, {
    toJSON: {
        virtuals: true
    },
    toObject: {
        virtuals: true
    }
});
// toursSchema.index({ price: 1 });
toursSchema.index({
    price: 1,
    ratingsAverage: -1
});
toursSchema.index({
    slug: 1
});
toursSchema.index({
    startLocation: "2dsphere"
});
toursSchema.virtual("durationWeeks").get(function() {
    return this.duration / 7;
});
//VIRTUAL POPULATE
toursSchema.virtual("reviews", {
    ref: "Review",
    foreignField: "tour",
    localField: "_id"
});
//DOCUMENT MIDDLEWARE runs bedore .save() and .create(); not before .insertMany()
toursSchema.pre("save", function(next) {
    this.slug = slugify(this.name, {
        lower: true
    });
    next();
});
// toursSchema.pre('save', async function (next) {
//   const guidesPromises = this.guides.map(async (id) => await User.findById(id));
//   this.guides = await Promise.all(guidesPromises); //* Promise.all jer je rezultat array promise-a
//   next();
// });
// toursSchema.pre('save', function (next) {
//   console.log('Will save document...');
//   next();
// });
// toursSchema.post('save', function (doc, next) {
//   console.log(doc);
//   next();
// });
//QUERY MIDDLEWARE
// toursSchema.pre('find', function (next)
toursSchema.pre(/^find/, function(next) {
    //Koristimo RegEx da definiramo da se middleware aktivira za sve query-e koji poinju sa rijei find
    this.find({
        secretTour: {
            $ne: true
        }
    }); //findOne, findMany....
    this.start = Date.now();
    next();
});
toursSchema.pre(/^find/, function(next) {
    this.populate({
        path: "guides",
        select: "-__v -passwordChangedAt"
    });
    next();
});
toursSchema.post(/^find/, function(docs, next) {
    console.log(`Query took: ${Date.now() - this.start} miliseconds`);
    // console.log(docs);
    next();
});
//AGGREGATION MIDDLEWARE
// toursSchema.pre('aggregate', function (next) {
//   this.pipeline().unshift({ $match: { secretTour: { $ne: true } } });
//   // console.log(this);
//   next();
// });
const Tour = mongoose.model("Tour", toursSchema);
module.exports = Tour;

},{"17d3e24d020b5aa4":"eslQT","fe7d67012634bcb1":"7dT0d"}],"eslQT":[function(require,module,exports) {
!function(t1, e1) {
    module.exports = e1();
}("undefined" != typeof self ? self : this, function() {
    return function(t1) {
        var e1 = {};
        function r1(n1) {
            if (e1[n1]) return e1[n1].exports;
            var o1 = e1[n1] = {
                i: n1,
                l: !1,
                exports: {}
            };
            return t1[n1].call(o1.exports, o1, o1.exports, r1), o1.l = !0, o1.exports;
        }
        return r1.m = t1, r1.c = e1, r1.d = function(t1, e1, n1) {
            r1.o(t1, e1) || Object.defineProperty(t1, e1, {
                enumerable: !0,
                get: n1
            });
        }, r1.r = function(t1) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t1, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(t1, "__esModule", {
                value: !0
            });
        }, r1.t = function(t1, e1) {
            if (1 & e1 && (t1 = r1(t1)), 8 & e1) return t1;
            if (4 & e1 && "object" == typeof t1 && t1 && t1.__esModule) return t1;
            var n1 = Object.create(null);
            if (r1.r(n1), Object.defineProperty(n1, "default", {
                enumerable: !0,
                value: t1
            }), 2 & e1 && "string" != typeof t1) for(var o1 in t1)r1.d(n1, o1, (function(e1) {
                return t1[e1];
            }).bind(null, o1));
            return n1;
        }, r1.n = function(t1) {
            var e1 = t1 && t1.__esModule ? function() {
                return t1.default;
            } : function() {
                return t1;
            };
            return r1.d(e1, "a", e1), e1;
        }, r1.o = function(t1, e1) {
            return Object.prototype.hasOwnProperty.call(t1, e1);
        }, r1.p = "", r1(r1.s = 93);
    }([
        function(t1, e1, r1) {
            "use strict";
            e1.arrayAtomicsSymbol = Symbol("mongoose#Array#_atomics"), e1.arrayParentSymbol = Symbol("mongoose#Array#_parent"), e1.arrayPathSymbol = Symbol("mongoose#Array#_path"), e1.arraySchemaSymbol = Symbol("mongoose#Array#_schema"), e1.documentArrayParent = Symbol("mongoose:documentArrayParent"), e1.documentIsSelected = Symbol("mongoose#Document#isSelected"), e1.documentIsModified = Symbol("mongoose#Document#isModified"), e1.documentModifiedPaths = Symbol("mongoose#Document#modifiedPaths"), e1.documentSchemaSymbol = Symbol("mongoose#Document#schema"), e1.getSymbol = Symbol("mongoose#Document#get"), e1.modelSymbol = Symbol("mongoose#Model"), e1.objectIdSymbol = Symbol("mongoose#ObjectId"), e1.populateModelSymbol = Symbol("mongoose.PopulateOptions#Model"), e1.schemaTypeSymbol = Symbol("mongoose#schemaType"), e1.sessionNewDocuments = Symbol("mongoose:ClientSession#newDocuments"), e1.scopeSymbol = Symbol("mongoose#Document#scope"), e1.validatorErrorSymbol = Symbol("mongoose:validatorError");
        },
        function(t1, e1, r1) {
            "use strict";
            (function(t1) {
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */ var n1 = r1(95), o1 = r1(96), i1 = r1(97);
                function s1() {
                    return u1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
                }
                function a1(t1, e1) {
                    if (s1() < e1) throw new RangeError("Invalid typed array length");
                    return u1.TYPED_ARRAY_SUPPORT ? (t1 = new Uint8Array(e1)).__proto__ = u1.prototype : (null === t1 && (t1 = new u1(e1)), t1.length = e1), t1;
                }
                function u1(t1, e1, r1) {
                    if (!(u1.TYPED_ARRAY_SUPPORT || this instanceof u1)) return new u1(t1, e1, r1);
                    if ("number" == typeof t1) {
                        if ("string" == typeof e1) throw new Error("If encoding is specified then the first argument must be a string");
                        return f1(this, t1);
                    }
                    return c1(this, t1, e1, r1);
                }
                function c1(t1, e1, r1, n1) {
                    if ("number" == typeof e1) throw new TypeError('"value" argument must not be a number');
                    return "undefined" != typeof ArrayBuffer && e1 instanceof ArrayBuffer ? function(t1, e1, r1, n1) {
                        if (e1.byteLength, r1 < 0 || e1.byteLength < r1) throw new RangeError("'offset' is out of bounds");
                        if (e1.byteLength < r1 + (n1 || 0)) throw new RangeError("'length' is out of bounds");
                        e1 = void 0 === r1 && void 0 === n1 ? new Uint8Array(e1) : void 0 === n1 ? new Uint8Array(e1, r1) : new Uint8Array(e1, r1, n1);
                        u1.TYPED_ARRAY_SUPPORT ? (t1 = e1).__proto__ = u1.prototype : t1 = p1(t1, e1);
                        return t1;
                    }(t1, e1, r1, n1) : "string" == typeof e1 ? function(t1, e1, r1) {
                        "string" == typeof r1 && "" !== r1 || (r1 = "utf8");
                        if (!u1.isEncoding(r1)) throw new TypeError('"encoding" must be a valid string encoding');
                        var n1 = 0 | y1(e1, r1), o1 = (t1 = a1(t1, n1)).write(e1, r1);
                        o1 !== n1 && (t1 = t1.slice(0, o1));
                        return t1;
                    }(t1, e1, r1) : function(t1, e1) {
                        if (u1.isBuffer(e1)) {
                            var r1 = 0 | h1(e1.length);
                            return 0 === (t1 = a1(t1, r1)).length || e1.copy(t1, 0, 0, r1), t1;
                        }
                        if (e1) {
                            if ("undefined" != typeof ArrayBuffer && e1.buffer instanceof ArrayBuffer || "length" in e1) return "number" != typeof e1.length || (n1 = e1.length) != n1 ? a1(t1, 0) : p1(t1, e1);
                            if ("Buffer" === e1.type && i1(e1.data)) return p1(t1, e1.data);
                        }
                        var n1;
                        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
                    }(t1, e1);
                }
                function l1(t1) {
                    if ("number" != typeof t1) throw new TypeError('"size" argument must be a number');
                    if (t1 < 0) throw new RangeError('"size" argument must not be negative');
                }
                function f1(t1, e1) {
                    if (l1(e1), t1 = a1(t1, e1 < 0 ? 0 : 0 | h1(e1)), !u1.TYPED_ARRAY_SUPPORT) for(var r1 = 0; r1 < e1; ++r1)t1[r1] = 0;
                    return t1;
                }
                function p1(t1, e1) {
                    var r1 = e1.length < 0 ? 0 : 0 | h1(e1.length);
                    t1 = a1(t1, r1);
                    for(var n1 = 0; n1 < r1; n1 += 1)t1[n1] = 255 & e1[n1];
                    return t1;
                }
                function h1(t1) {
                    if (t1 >= s1()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s1().toString(16) + " bytes");
                    return 0 | t1;
                }
                function y1(t1, e1) {
                    if (u1.isBuffer(t1)) return t1.length;
                    if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t1) || t1 instanceof ArrayBuffer)) return t1.byteLength;
                    "string" != typeof t1 && (t1 = "" + t1);
                    var r1 = t1.length;
                    if (0 === r1) return 0;
                    for(var n1 = !1;;)switch(e1){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return r1;
                        case "utf8":
                        case "utf-8":
                        case void 0:
                            return L1(t1).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return 2 * r1;
                        case "hex":
                            return r1 >>> 1;
                        case "base64":
                            return U1(t1).length;
                        default:
                            if (n1) return L1(t1).length;
                            e1 = ("" + e1).toLowerCase(), n1 = !0;
                    }
                }
                function d1(t1, e1, r1) {
                    var n1 = !1;
                    if ((void 0 === e1 || e1 < 0) && (e1 = 0), e1 > this.length) return "";
                    if ((void 0 === r1 || r1 > this.length) && (r1 = this.length), r1 <= 0) return "";
                    if ((r1 >>>= 0) <= (e1 >>>= 0)) return "";
                    for(t1 || (t1 = "utf8");;)switch(t1){
                        case "hex":
                            return x1(this, e1, r1);
                        case "utf8":
                        case "utf-8":
                            return E1(this, e1, r1);
                        case "ascii":
                            return $1(this, e1, r1);
                        case "latin1":
                        case "binary":
                            return P1(this, e1, r1);
                        case "base64":
                            return j1(this, e1, r1);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return N1(this, e1, r1);
                        default:
                            if (n1) throw new TypeError("Unknown encoding: " + t1);
                            t1 = (t1 + "").toLowerCase(), n1 = !0;
                    }
                }
                function m1(t1, e1, r1) {
                    var n1 = t1[e1];
                    t1[e1] = t1[r1], t1[r1] = n1;
                }
                function _1(t1, e1, r1, n1, o1) {
                    if (0 === t1.length) return -1;
                    if ("string" == typeof r1 ? (n1 = r1, r1 = 0) : r1 > 2147483647 ? r1 = 2147483647 : r1 < -2147483648 && (r1 = -2147483648), r1 = +r1, isNaN(r1) && (r1 = o1 ? 0 : t1.length - 1), r1 < 0 && (r1 = t1.length + r1), r1 >= t1.length) {
                        if (o1) return -1;
                        r1 = t1.length - 1;
                    } else if (r1 < 0) {
                        if (!o1) return -1;
                        r1 = 0;
                    }
                    if ("string" == typeof e1 && (e1 = u1.from(e1, n1)), u1.isBuffer(e1)) return 0 === e1.length ? -1 : v1(t1, e1, r1, n1, o1);
                    if ("number" == typeof e1) return e1 &= 255, u1.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o1 ? Uint8Array.prototype.indexOf.call(t1, e1, r1) : Uint8Array.prototype.lastIndexOf.call(t1, e1, r1) : v1(t1, [
                        e1
                    ], r1, n1, o1);
                    throw new TypeError("val must be string, number or Buffer");
                }
                function v1(t1, e1, r1, n1, o1) {
                    var i1, s1 = 1, a1 = t1.length, u1 = e1.length;
                    if (void 0 !== n1 && ("ucs2" === (n1 = String(n1).toLowerCase()) || "ucs-2" === n1 || "utf16le" === n1 || "utf-16le" === n1)) {
                        if (t1.length < 2 || e1.length < 2) return -1;
                        s1 = 2, a1 /= 2, u1 /= 2, r1 /= 2;
                    }
                    function c1(t1, e1) {
                        return 1 === s1 ? t1[e1] : t1.readUInt16BE(e1 * s1);
                    }
                    if (o1) {
                        var l1 = -1;
                        for(i1 = r1; i1 < a1; i1++)if (c1(t1, i1) === c1(e1, -1 === l1 ? 0 : i1 - l1)) {
                            if (-1 === l1 && (l1 = i1), i1 - l1 + 1 === u1) return l1 * s1;
                        } else -1 !== l1 && (i1 -= i1 - l1), l1 = -1;
                    } else for(r1 + u1 > a1 && (r1 = a1 - u1), i1 = r1; i1 >= 0; i1--){
                        for(var f1 = !0, p1 = 0; p1 < u1; p1++)if (c1(t1, i1 + p1) !== c1(e1, p1)) {
                            f1 = !1;
                            break;
                        }
                        if (f1) return i1;
                    }
                    return -1;
                }
                function g1(t1, e1, r1, n1) {
                    r1 = Number(r1) || 0;
                    var o1 = t1.length - r1;
                    n1 ? (n1 = Number(n1)) > o1 && (n1 = o1) : n1 = o1;
                    var i1 = e1.length;
                    if (i1 % 2 != 0) throw new TypeError("Invalid hex string");
                    n1 > i1 / 2 && (n1 = i1 / 2);
                    for(var s1 = 0; s1 < n1; ++s1){
                        var a1 = parseInt(e1.substr(2 * s1, 2), 16);
                        if (isNaN(a1)) return s1;
                        t1[r1 + s1] = a1;
                    }
                    return s1;
                }
                function b1(t1, e1, r1, n1) {
                    return V1(L1(e1, t1.length - r1), t1, r1, n1);
                }
                function w1(t1, e1, r1, n1) {
                    return V1(function(t1) {
                        for(var e1 = [], r1 = 0; r1 < t1.length; ++r1)e1.push(255 & t1.charCodeAt(r1));
                        return e1;
                    }(e1), t1, r1, n1);
                }
                function O1(t1, e1, r1, n1) {
                    return w1(t1, e1, r1, n1);
                }
                function S1(t1, e1, r1, n1) {
                    return V1(U1(e1), t1, r1, n1);
                }
                function A1(t1, e1, r1, n1) {
                    return V1(function(t1, e1) {
                        for(var r1, n1, o1, i1 = [], s1 = 0; s1 < t1.length && !((e1 -= 2) < 0); ++s1)r1 = t1.charCodeAt(s1), n1 = r1 >> 8, o1 = r1 % 256, i1.push(o1), i1.push(n1);
                        return i1;
                    }(e1, t1.length - r1), t1, r1, n1);
                }
                function j1(t1, e1, r1) {
                    return 0 === e1 && r1 === t1.length ? n1.fromByteArray(t1) : n1.fromByteArray(t1.slice(e1, r1));
                }
                function E1(t1, e1, r1) {
                    r1 = Math.min(t1.length, r1);
                    for(var n1 = [], o1 = e1; o1 < r1;){
                        var i1, s1, a1, u1, c1 = t1[o1], l1 = null, f1 = c1 > 239 ? 4 : c1 > 223 ? 3 : c1 > 191 ? 2 : 1;
                        if (o1 + f1 <= r1) switch(f1){
                            case 1:
                                c1 < 128 && (l1 = c1);
                                break;
                            case 2:
                                128 == (192 & (i1 = t1[o1 + 1])) && (u1 = (31 & c1) << 6 | 63 & i1) > 127 && (l1 = u1);
                                break;
                            case 3:
                                i1 = t1[o1 + 1], s1 = t1[o1 + 2], 128 == (192 & i1) && 128 == (192 & s1) && (u1 = (15 & c1) << 12 | (63 & i1) << 6 | 63 & s1) > 2047 && (u1 < 55296 || u1 > 57343) && (l1 = u1);
                                break;
                            case 4:
                                i1 = t1[o1 + 1], s1 = t1[o1 + 2], a1 = t1[o1 + 3], 128 == (192 & i1) && 128 == (192 & s1) && 128 == (192 & a1) && (u1 = (15 & c1) << 18 | (63 & i1) << 12 | (63 & s1) << 6 | 63 & a1) > 65535 && u1 < 1114112 && (l1 = u1);
                        }
                        null === l1 ? (l1 = 65533, f1 = 1) : l1 > 65535 && (l1 -= 65536, n1.push(l1 >>> 10 & 1023 | 55296), l1 = 56320 | 1023 & l1), n1.push(l1), o1 += f1;
                    }
                    return function(t1) {
                        var e1 = t1.length;
                        if (e1 <= 4096) return String.fromCharCode.apply(String, t1);
                        var r1 = "", n1 = 0;
                        for(; n1 < e1;)r1 += String.fromCharCode.apply(String, t1.slice(n1, n1 += 4096));
                        return r1;
                    }(n1);
                }
                e1.Buffer = u1, e1.SlowBuffer = function(t1) {
                    +t1 != t1 && (t1 = 0);
                    return u1.alloc(+t1);
                }, e1.INSPECT_MAX_BYTES = 50, u1.TYPED_ARRAY_SUPPORT = void 0 !== t1.TYPED_ARRAY_SUPPORT ? t1.TYPED_ARRAY_SUPPORT : function() {
                    try {
                        var t1 = new Uint8Array(1);
                        return t1.__proto__ = {
                            __proto__: Uint8Array.prototype,
                            foo: function() {
                                return 42;
                            }
                        }, 42 === t1.foo() && "function" == typeof t1.subarray && 0 === t1.subarray(1, 1).byteLength;
                    } catch (t1) {
                        return !1;
                    }
                }(), e1.kMaxLength = s1(), u1.poolSize = 8192, u1._augment = function(t1) {
                    return t1.__proto__ = u1.prototype, t1;
                }, u1.from = function(t1, e1, r1) {
                    return c1(null, t1, e1, r1);
                }, u1.TYPED_ARRAY_SUPPORT && (u1.prototype.__proto__ = Uint8Array.prototype, u1.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && u1[Symbol.species] === u1 && Object.defineProperty(u1, Symbol.species, {
                    value: null,
                    configurable: !0
                })), u1.alloc = function(t1, e1, r1) {
                    return function(t1, e1, r1, n1) {
                        return l1(e1), e1 <= 0 ? a1(t1, e1) : void 0 !== r1 ? "string" == typeof n1 ? a1(t1, e1).fill(r1, n1) : a1(t1, e1).fill(r1) : a1(t1, e1);
                    }(null, t1, e1, r1);
                }, u1.allocUnsafe = function(t1) {
                    return f1(null, t1);
                }, u1.allocUnsafeSlow = function(t1) {
                    return f1(null, t1);
                }, u1.isBuffer = function(t1) {
                    return !(null == t1 || !t1._isBuffer);
                }, u1.compare = function(t1, e1) {
                    if (!u1.isBuffer(t1) || !u1.isBuffer(e1)) throw new TypeError("Arguments must be Buffers");
                    if (t1 === e1) return 0;
                    for(var r1 = t1.length, n1 = e1.length, o1 = 0, i1 = Math.min(r1, n1); o1 < i1; ++o1)if (t1[o1] !== e1[o1]) {
                        r1 = t1[o1], n1 = e1[o1];
                        break;
                    }
                    return r1 < n1 ? -1 : n1 < r1 ? 1 : 0;
                }, u1.isEncoding = function(t1) {
                    switch(String(t1).toLowerCase()){
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "latin1":
                        case "binary":
                        case "base64":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return !0;
                        default:
                            return !1;
                    }
                }, u1.concat = function(t1, e1) {
                    if (!i1(t1)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === t1.length) return u1.alloc(0);
                    var r1;
                    if (void 0 === e1) for(e1 = 0, r1 = 0; r1 < t1.length; ++r1)e1 += t1[r1].length;
                    var n1 = u1.allocUnsafe(e1), o1 = 0;
                    for(r1 = 0; r1 < t1.length; ++r1){
                        var s1 = t1[r1];
                        if (!u1.isBuffer(s1)) throw new TypeError('"list" argument must be an Array of Buffers');
                        s1.copy(n1, o1), o1 += s1.length;
                    }
                    return n1;
                }, u1.byteLength = y1, u1.prototype._isBuffer = !0, u1.prototype.swap16 = function() {
                    var t1 = this.length;
                    if (t1 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for(var e1 = 0; e1 < t1; e1 += 2)m1(this, e1, e1 + 1);
                    return this;
                }, u1.prototype.swap32 = function() {
                    var t1 = this.length;
                    if (t1 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for(var e1 = 0; e1 < t1; e1 += 4)m1(this, e1, e1 + 3), m1(this, e1 + 1, e1 + 2);
                    return this;
                }, u1.prototype.swap64 = function() {
                    var t1 = this.length;
                    if (t1 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for(var e1 = 0; e1 < t1; e1 += 8)m1(this, e1, e1 + 7), m1(this, e1 + 1, e1 + 6), m1(this, e1 + 2, e1 + 5), m1(this, e1 + 3, e1 + 4);
                    return this;
                }, u1.prototype.toString = function() {
                    var t1 = 0 | this.length;
                    return 0 === t1 ? "" : 0 === arguments.length ? E1(this, 0, t1) : d1.apply(this, arguments);
                }, u1.prototype.equals = function(t1) {
                    if (!u1.isBuffer(t1)) throw new TypeError("Argument must be a Buffer");
                    return this === t1 || 0 === u1.compare(this, t1);
                }, u1.prototype.inspect = function() {
                    var t1 = "", r1 = e1.INSPECT_MAX_BYTES;
                    return this.length > 0 && (t1 = this.toString("hex", 0, r1).match(/.{2}/g).join(" "), this.length > r1 && (t1 += " ... ")), "<Buffer " + t1 + ">";
                }, u1.prototype.compare = function(t1, e1, r1, n1, o1) {
                    if (!u1.isBuffer(t1)) throw new TypeError("Argument must be a Buffer");
                    if (void 0 === e1 && (e1 = 0), void 0 === r1 && (r1 = t1 ? t1.length : 0), void 0 === n1 && (n1 = 0), void 0 === o1 && (o1 = this.length), e1 < 0 || r1 > t1.length || n1 < 0 || o1 > this.length) throw new RangeError("out of range index");
                    if (n1 >= o1 && e1 >= r1) return 0;
                    if (n1 >= o1) return -1;
                    if (e1 >= r1) return 1;
                    if (this === t1) return 0;
                    for(var i1 = (o1 >>>= 0) - (n1 >>>= 0), s1 = (r1 >>>= 0) - (e1 >>>= 0), a1 = Math.min(i1, s1), c1 = this.slice(n1, o1), l1 = t1.slice(e1, r1), f1 = 0; f1 < a1; ++f1)if (c1[f1] !== l1[f1]) {
                        i1 = c1[f1], s1 = l1[f1];
                        break;
                    }
                    return i1 < s1 ? -1 : s1 < i1 ? 1 : 0;
                }, u1.prototype.includes = function(t1, e1, r1) {
                    return -1 !== this.indexOf(t1, e1, r1);
                }, u1.prototype.indexOf = function(t1, e1, r1) {
                    return _1(this, t1, e1, r1, !0);
                }, u1.prototype.lastIndexOf = function(t1, e1, r1) {
                    return _1(this, t1, e1, r1, !1);
                }, u1.prototype.write = function(t1, e1, r1, n1) {
                    if (void 0 === e1) n1 = "utf8", r1 = this.length, e1 = 0;
                    else if (void 0 === r1 && "string" == typeof e1) n1 = e1, r1 = this.length, e1 = 0;
                    else {
                        if (!isFinite(e1)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        e1 |= 0, isFinite(r1) ? (r1 |= 0, void 0 === n1 && (n1 = "utf8")) : (n1 = r1, r1 = void 0);
                    }
                    var o1 = this.length - e1;
                    if ((void 0 === r1 || r1 > o1) && (r1 = o1), t1.length > 0 && (r1 < 0 || e1 < 0) || e1 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    n1 || (n1 = "utf8");
                    for(var i1 = !1;;)switch(n1){
                        case "hex":
                            return g1(this, t1, e1, r1);
                        case "utf8":
                        case "utf-8":
                            return b1(this, t1, e1, r1);
                        case "ascii":
                            return w1(this, t1, e1, r1);
                        case "latin1":
                        case "binary":
                            return O1(this, t1, e1, r1);
                        case "base64":
                            return S1(this, t1, e1, r1);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return A1(this, t1, e1, r1);
                        default:
                            if (i1) throw new TypeError("Unknown encoding: " + n1);
                            n1 = ("" + n1).toLowerCase(), i1 = !0;
                    }
                }, u1.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    };
                };
                function $1(t1, e1, r1) {
                    var n1 = "";
                    r1 = Math.min(t1.length, r1);
                    for(var o1 = e1; o1 < r1; ++o1)n1 += String.fromCharCode(127 & t1[o1]);
                    return n1;
                }
                function P1(t1, e1, r1) {
                    var n1 = "";
                    r1 = Math.min(t1.length, r1);
                    for(var o1 = e1; o1 < r1; ++o1)n1 += String.fromCharCode(t1[o1]);
                    return n1;
                }
                function x1(t1, e1, r1) {
                    var n1 = t1.length;
                    (!e1 || e1 < 0) && (e1 = 0), (!r1 || r1 < 0 || r1 > n1) && (r1 = n1);
                    for(var o1 = "", i1 = e1; i1 < r1; ++i1)o1 += F1(t1[i1]);
                    return o1;
                }
                function N1(t1, e1, r1) {
                    for(var n1 = t1.slice(e1, r1), o1 = "", i1 = 0; i1 < n1.length; i1 += 2)o1 += String.fromCharCode(n1[i1] + 256 * n1[i1 + 1]);
                    return o1;
                }
                function T1(t1, e1, r1) {
                    if (t1 % 1 != 0 || t1 < 0) throw new RangeError("offset is not uint");
                    if (t1 + e1 > r1) throw new RangeError("Trying to access beyond buffer length");
                }
                function k1(t1, e1, r1, n1, o1, i1) {
                    if (!u1.isBuffer(t1)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (e1 > o1 || e1 < i1) throw new RangeError('"value" argument is out of bounds');
                    if (r1 + n1 > t1.length) throw new RangeError("Index out of range");
                }
                function C1(t1, e1, r1, n1) {
                    e1 < 0 && (e1 = 65535 + e1 + 1);
                    for(var o1 = 0, i1 = Math.min(t1.length - r1, 2); o1 < i1; ++o1)t1[r1 + o1] = (e1 & 255 << 8 * (n1 ? o1 : 1 - o1)) >>> 8 * (n1 ? o1 : 1 - o1);
                }
                function D1(t1, e1, r1, n1) {
                    e1 < 0 && (e1 = 4294967295 + e1 + 1);
                    for(var o1 = 0, i1 = Math.min(t1.length - r1, 4); o1 < i1; ++o1)t1[r1 + o1] = e1 >>> 8 * (n1 ? o1 : 3 - o1) & 255;
                }
                function R1(t1, e1, r1, n1, o1, i1) {
                    if (r1 + n1 > t1.length) throw new RangeError("Index out of range");
                    if (r1 < 0) throw new RangeError("Index out of range");
                }
                function B1(t1, e1, r1, n1, i1) {
                    return i1 || R1(t1, 0, r1, 4), o1.write(t1, e1, r1, n1, 23, 4), r1 + 4;
                }
                function M1(t1, e1, r1, n1, i1) {
                    return i1 || R1(t1, 0, r1, 8), o1.write(t1, e1, r1, n1, 52, 8), r1 + 8;
                }
                u1.prototype.slice = function(t1, e1) {
                    var r1, n1 = this.length;
                    if ((t1 = ~~t1) < 0 ? (t1 += n1) < 0 && (t1 = 0) : t1 > n1 && (t1 = n1), (e1 = void 0 === e1 ? n1 : ~~e1) < 0 ? (e1 += n1) < 0 && (e1 = 0) : e1 > n1 && (e1 = n1), e1 < t1 && (e1 = t1), u1.TYPED_ARRAY_SUPPORT) (r1 = this.subarray(t1, e1)).__proto__ = u1.prototype;
                    else {
                        var o1 = e1 - t1;
                        r1 = new u1(o1, void 0);
                        for(var i1 = 0; i1 < o1; ++i1)r1[i1] = this[i1 + t1];
                    }
                    return r1;
                }, u1.prototype.readUIntLE = function(t1, e1, r1) {
                    t1 |= 0, e1 |= 0, r1 || T1(t1, e1, this.length);
                    for(var n1 = this[t1], o1 = 1, i1 = 0; ++i1 < e1 && (o1 *= 256);)n1 += this[t1 + i1] * o1;
                    return n1;
                }, u1.prototype.readUIntBE = function(t1, e1, r1) {
                    t1 |= 0, e1 |= 0, r1 || T1(t1, e1, this.length);
                    for(var n1 = this[t1 + --e1], o1 = 1; e1 > 0 && (o1 *= 256);)n1 += this[t1 + --e1] * o1;
                    return n1;
                }, u1.prototype.readUInt8 = function(t1, e1) {
                    return e1 || T1(t1, 1, this.length), this[t1];
                }, u1.prototype.readUInt16LE = function(t1, e1) {
                    return e1 || T1(t1, 2, this.length), this[t1] | this[t1 + 1] << 8;
                }, u1.prototype.readUInt16BE = function(t1, e1) {
                    return e1 || T1(t1, 2, this.length), this[t1] << 8 | this[t1 + 1];
                }, u1.prototype.readUInt32LE = function(t1, e1) {
                    return e1 || T1(t1, 4, this.length), (this[t1] | this[t1 + 1] << 8 | this[t1 + 2] << 16) + 16777216 * this[t1 + 3];
                }, u1.prototype.readUInt32BE = function(t1, e1) {
                    return e1 || T1(t1, 4, this.length), 16777216 * this[t1] + (this[t1 + 1] << 16 | this[t1 + 2] << 8 | this[t1 + 3]);
                }, u1.prototype.readIntLE = function(t1, e1, r1) {
                    t1 |= 0, e1 |= 0, r1 || T1(t1, e1, this.length);
                    for(var n1 = this[t1], o1 = 1, i1 = 0; ++i1 < e1 && (o1 *= 256);)n1 += this[t1 + i1] * o1;
                    return n1 >= (o1 *= 128) && (n1 -= Math.pow(2, 8 * e1)), n1;
                }, u1.prototype.readIntBE = function(t1, e1, r1) {
                    t1 |= 0, e1 |= 0, r1 || T1(t1, e1, this.length);
                    for(var n1 = e1, o1 = 1, i1 = this[t1 + --n1]; n1 > 0 && (o1 *= 256);)i1 += this[t1 + --n1] * o1;
                    return i1 >= (o1 *= 128) && (i1 -= Math.pow(2, 8 * e1)), i1;
                }, u1.prototype.readInt8 = function(t1, e1) {
                    return e1 || T1(t1, 1, this.length), 128 & this[t1] ? -1 * (255 - this[t1] + 1) : this[t1];
                }, u1.prototype.readInt16LE = function(t1, e1) {
                    e1 || T1(t1, 2, this.length);
                    var r1 = this[t1] | this[t1 + 1] << 8;
                    return 32768 & r1 ? 4294901760 | r1 : r1;
                }, u1.prototype.readInt16BE = function(t1, e1) {
                    e1 || T1(t1, 2, this.length);
                    var r1 = this[t1 + 1] | this[t1] << 8;
                    return 32768 & r1 ? 4294901760 | r1 : r1;
                }, u1.prototype.readInt32LE = function(t1, e1) {
                    return e1 || T1(t1, 4, this.length), this[t1] | this[t1 + 1] << 8 | this[t1 + 2] << 16 | this[t1 + 3] << 24;
                }, u1.prototype.readInt32BE = function(t1, e1) {
                    return e1 || T1(t1, 4, this.length), this[t1] << 24 | this[t1 + 1] << 16 | this[t1 + 2] << 8 | this[t1 + 3];
                }, u1.prototype.readFloatLE = function(t1, e1) {
                    return e1 || T1(t1, 4, this.length), o1.read(this, t1, !0, 23, 4);
                }, u1.prototype.readFloatBE = function(t1, e1) {
                    return e1 || T1(t1, 4, this.length), o1.read(this, t1, !1, 23, 4);
                }, u1.prototype.readDoubleLE = function(t1, e1) {
                    return e1 || T1(t1, 8, this.length), o1.read(this, t1, !0, 52, 8);
                }, u1.prototype.readDoubleBE = function(t1, e1) {
                    return e1 || T1(t1, 8, this.length), o1.read(this, t1, !1, 52, 8);
                }, u1.prototype.writeUIntLE = function(t1, e1, r1, n1) {
                    (t1 = +t1, e1 |= 0, r1 |= 0, n1) || k1(this, t1, e1, r1, Math.pow(2, 8 * r1) - 1, 0);
                    var o1 = 1, i1 = 0;
                    for(this[e1] = 255 & t1; ++i1 < r1 && (o1 *= 256);)this[e1 + i1] = t1 / o1 & 255;
                    return e1 + r1;
                }, u1.prototype.writeUIntBE = function(t1, e1, r1, n1) {
                    (t1 = +t1, e1 |= 0, r1 |= 0, n1) || k1(this, t1, e1, r1, Math.pow(2, 8 * r1) - 1, 0);
                    var o1 = r1 - 1, i1 = 1;
                    for(this[e1 + o1] = 255 & t1; --o1 >= 0 && (i1 *= 256);)this[e1 + o1] = t1 / i1 & 255;
                    return e1 + r1;
                }, u1.prototype.writeUInt8 = function(t1, e1, r1) {
                    return t1 = +t1, e1 |= 0, r1 || k1(this, t1, e1, 1, 255, 0), u1.TYPED_ARRAY_SUPPORT || (t1 = Math.floor(t1)), this[e1] = 255 & t1, e1 + 1;
                }, u1.prototype.writeUInt16LE = function(t1, e1, r1) {
                    return t1 = +t1, e1 |= 0, r1 || k1(this, t1, e1, 2, 65535, 0), u1.TYPED_ARRAY_SUPPORT ? (this[e1] = 255 & t1, this[e1 + 1] = t1 >>> 8) : C1(this, t1, e1, !0), e1 + 2;
                }, u1.prototype.writeUInt16BE = function(t1, e1, r1) {
                    return t1 = +t1, e1 |= 0, r1 || k1(this, t1, e1, 2, 65535, 0), u1.TYPED_ARRAY_SUPPORT ? (this[e1] = t1 >>> 8, this[e1 + 1] = 255 & t1) : C1(this, t1, e1, !1), e1 + 2;
                }, u1.prototype.writeUInt32LE = function(t1, e1, r1) {
                    return t1 = +t1, e1 |= 0, r1 || k1(this, t1, e1, 4, 4294967295, 0), u1.TYPED_ARRAY_SUPPORT ? (this[e1 + 3] = t1 >>> 24, this[e1 + 2] = t1 >>> 16, this[e1 + 1] = t1 >>> 8, this[e1] = 255 & t1) : D1(this, t1, e1, !0), e1 + 4;
                }, u1.prototype.writeUInt32BE = function(t1, e1, r1) {
                    return t1 = +t1, e1 |= 0, r1 || k1(this, t1, e1, 4, 4294967295, 0), u1.TYPED_ARRAY_SUPPORT ? (this[e1] = t1 >>> 24, this[e1 + 1] = t1 >>> 16, this[e1 + 2] = t1 >>> 8, this[e1 + 3] = 255 & t1) : D1(this, t1, e1, !1), e1 + 4;
                }, u1.prototype.writeIntLE = function(t1, e1, r1, n1) {
                    if (t1 = +t1, e1 |= 0, !n1) {
                        var o1 = Math.pow(2, 8 * r1 - 1);
                        k1(this, t1, e1, r1, o1 - 1, -o1);
                    }
                    var i1 = 0, s1 = 1, a1 = 0;
                    for(this[e1] = 255 & t1; ++i1 < r1 && (s1 *= 256);)t1 < 0 && 0 === a1 && 0 !== this[e1 + i1 - 1] && (a1 = 1), this[e1 + i1] = (t1 / s1 >> 0) - a1 & 255;
                    return e1 + r1;
                }, u1.prototype.writeIntBE = function(t1, e1, r1, n1) {
                    if (t1 = +t1, e1 |= 0, !n1) {
                        var o1 = Math.pow(2, 8 * r1 - 1);
                        k1(this, t1, e1, r1, o1 - 1, -o1);
                    }
                    var i1 = r1 - 1, s1 = 1, a1 = 0;
                    for(this[e1 + i1] = 255 & t1; --i1 >= 0 && (s1 *= 256);)t1 < 0 && 0 === a1 && 0 !== this[e1 + i1 + 1] && (a1 = 1), this[e1 + i1] = (t1 / s1 >> 0) - a1 & 255;
                    return e1 + r1;
                }, u1.prototype.writeInt8 = function(t1, e1, r1) {
                    return t1 = +t1, e1 |= 0, r1 || k1(this, t1, e1, 1, 127, -128), u1.TYPED_ARRAY_SUPPORT || (t1 = Math.floor(t1)), t1 < 0 && (t1 = 255 + t1 + 1), this[e1] = 255 & t1, e1 + 1;
                }, u1.prototype.writeInt16LE = function(t1, e1, r1) {
                    return t1 = +t1, e1 |= 0, r1 || k1(this, t1, e1, 2, 32767, -32768), u1.TYPED_ARRAY_SUPPORT ? (this[e1] = 255 & t1, this[e1 + 1] = t1 >>> 8) : C1(this, t1, e1, !0), e1 + 2;
                }, u1.prototype.writeInt16BE = function(t1, e1, r1) {
                    return t1 = +t1, e1 |= 0, r1 || k1(this, t1, e1, 2, 32767, -32768), u1.TYPED_ARRAY_SUPPORT ? (this[e1] = t1 >>> 8, this[e1 + 1] = 255 & t1) : C1(this, t1, e1, !1), e1 + 2;
                }, u1.prototype.writeInt32LE = function(t1, e1, r1) {
                    return t1 = +t1, e1 |= 0, r1 || k1(this, t1, e1, 4, 2147483647, -2147483648), u1.TYPED_ARRAY_SUPPORT ? (this[e1] = 255 & t1, this[e1 + 1] = t1 >>> 8, this[e1 + 2] = t1 >>> 16, this[e1 + 3] = t1 >>> 24) : D1(this, t1, e1, !0), e1 + 4;
                }, u1.prototype.writeInt32BE = function(t1, e1, r1) {
                    return t1 = +t1, e1 |= 0, r1 || k1(this, t1, e1, 4, 2147483647, -2147483648), t1 < 0 && (t1 = 4294967295 + t1 + 1), u1.TYPED_ARRAY_SUPPORT ? (this[e1] = t1 >>> 24, this[e1 + 1] = t1 >>> 16, this[e1 + 2] = t1 >>> 8, this[e1 + 3] = 255 & t1) : D1(this, t1, e1, !1), e1 + 4;
                }, u1.prototype.writeFloatLE = function(t1, e1, r1) {
                    return B1(this, t1, e1, !0, r1);
                }, u1.prototype.writeFloatBE = function(t1, e1, r1) {
                    return B1(this, t1, e1, !1, r1);
                }, u1.prototype.writeDoubleLE = function(t1, e1, r1) {
                    return M1(this, t1, e1, !0, r1);
                }, u1.prototype.writeDoubleBE = function(t1, e1, r1) {
                    return M1(this, t1, e1, !1, r1);
                }, u1.prototype.copy = function(t1, e1, r1, n1) {
                    if (r1 || (r1 = 0), n1 || 0 === n1 || (n1 = this.length), e1 >= t1.length && (e1 = t1.length), e1 || (e1 = 0), n1 > 0 && n1 < r1 && (n1 = r1), n1 === r1) return 0;
                    if (0 === t1.length || 0 === this.length) return 0;
                    if (e1 < 0) throw new RangeError("targetStart out of bounds");
                    if (r1 < 0 || r1 >= this.length) throw new RangeError("sourceStart out of bounds");
                    if (n1 < 0) throw new RangeError("sourceEnd out of bounds");
                    n1 > this.length && (n1 = this.length), t1.length - e1 < n1 - r1 && (n1 = t1.length - e1 + r1);
                    var o1, i1 = n1 - r1;
                    if (this === t1 && r1 < e1 && e1 < n1) for(o1 = i1 - 1; o1 >= 0; --o1)t1[o1 + e1] = this[o1 + r1];
                    else if (i1 < 1e3 || !u1.TYPED_ARRAY_SUPPORT) for(o1 = 0; o1 < i1; ++o1)t1[o1 + e1] = this[o1 + r1];
                    else Uint8Array.prototype.set.call(t1, this.subarray(r1, r1 + i1), e1);
                    return i1;
                }, u1.prototype.fill = function(t1, e1, r1, n1) {
                    if ("string" == typeof t1) {
                        if ("string" == typeof e1 ? (n1 = e1, e1 = 0, r1 = this.length) : "string" == typeof r1 && (n1 = r1, r1 = this.length), 1 === t1.length) {
                            var o1 = t1.charCodeAt(0);
                            o1 < 256 && (t1 = o1);
                        }
                        if (void 0 !== n1 && "string" != typeof n1) throw new TypeError("encoding must be a string");
                        if ("string" == typeof n1 && !u1.isEncoding(n1)) throw new TypeError("Unknown encoding: " + n1);
                    } else "number" == typeof t1 && (t1 &= 255);
                    if (e1 < 0 || this.length < e1 || this.length < r1) throw new RangeError("Out of range index");
                    if (r1 <= e1) return this;
                    var i1;
                    if (e1 >>>= 0, r1 = void 0 === r1 ? this.length : r1 >>> 0, t1 || (t1 = 0), "number" == typeof t1) for(i1 = e1; i1 < r1; ++i1)this[i1] = t1;
                    else {
                        var s1 = u1.isBuffer(t1) ? t1 : L1(new u1(t1, n1).toString()), a1 = s1.length;
                        for(i1 = 0; i1 < r1 - e1; ++i1)this[i1 + e1] = s1[i1 % a1];
                    }
                    return this;
                };
                var I1 = /[^+\/0-9A-Za-z-_]/g;
                function F1(t1) {
                    return t1 < 16 ? "0" + t1.toString(16) : t1.toString(16);
                }
                function L1(t1, e1) {
                    var r1;
                    e1 = e1 || 1 / 0;
                    for(var n1 = t1.length, o1 = null, i1 = [], s1 = 0; s1 < n1; ++s1){
                        if ((r1 = t1.charCodeAt(s1)) > 55295 && r1 < 57344) {
                            if (!o1) {
                                if (r1 > 56319) {
                                    (e1 -= 3) > -1 && i1.push(239, 191, 189);
                                    continue;
                                }
                                if (s1 + 1 === n1) {
                                    (e1 -= 3) > -1 && i1.push(239, 191, 189);
                                    continue;
                                }
                                o1 = r1;
                                continue;
                            }
                            if (r1 < 56320) {
                                (e1 -= 3) > -1 && i1.push(239, 191, 189), o1 = r1;
                                continue;
                            }
                            r1 = 65536 + (o1 - 55296 << 10 | r1 - 56320);
                        } else o1 && (e1 -= 3) > -1 && i1.push(239, 191, 189);
                        if (o1 = null, r1 < 128) {
                            if ((e1 -= 1) < 0) break;
                            i1.push(r1);
                        } else if (r1 < 2048) {
                            if ((e1 -= 2) < 0) break;
                            i1.push(r1 >> 6 | 192, 63 & r1 | 128);
                        } else if (r1 < 65536) {
                            if ((e1 -= 3) < 0) break;
                            i1.push(r1 >> 12 | 224, r1 >> 6 & 63 | 128, 63 & r1 | 128);
                        } else {
                            if (!(r1 < 1114112)) throw new Error("Invalid code point");
                            if ((e1 -= 4) < 0) break;
                            i1.push(r1 >> 18 | 240, r1 >> 12 & 63 | 128, r1 >> 6 & 63 | 128, 63 & r1 | 128);
                        }
                    }
                    return i1;
                }
                function U1(t1) {
                    return n1.toByteArray(function(t1) {
                        if ((t1 = (function(t1) {
                            return t1.trim ? t1.trim() : t1.replace(/^\s+|\s+$/g, "");
                        })(t1).replace(I1, "")).length < 2) return "";
                        for(; t1.length % 4 != 0;)t1 += "=";
                        return t1;
                    }(t1));
                }
                function V1(t1, e1, r1, n1) {
                    for(var o1 = 0; o1 < n1 && !(o1 + r1 >= e1.length || o1 >= t1.length); ++o1)e1[o1 + r1] = t1[o1];
                    return o1;
                }
            }).call(this, r1(11));
        },
        function(t1, e1, r1) {
            "use strict";
            (function(t1) {
                /*!
 * Module dependencies.
 */ function n1(t1, e1) {
                    var r1;
                    if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                        if (Array.isArray(t1) || (r1 = function(t1, e1) {
                            if (!t1) return;
                            if ("string" == typeof t1) return o1(t1, e1);
                            var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                            "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                            if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                            if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return o1(t1, e1);
                        }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                            r1 && (t1 = r1);
                            var n1 = 0, i1 = function() {};
                            return {
                                s: i1,
                                n: function() {
                                    return n1 >= t1.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t1[n1++]
                                    };
                                },
                                e: function(t1) {
                                    throw t1;
                                },
                                f: i1
                            };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }
                    var s1, a1 = !0, u1 = !1;
                    return {
                        s: function() {
                            r1 = t1[Symbol.iterator]();
                        },
                        n: function() {
                            var t1 = r1.next();
                            return a1 = t1.done, t1;
                        },
                        e: function(t1) {
                            u1 = !0, s1 = t1;
                        },
                        f: function() {
                            try {
                                a1 || null == r1.return || r1.return();
                            } finally{
                                if (u1) throw s1;
                            }
                        }
                    };
                }
                function o1(t1, e1) {
                    (null == e1 || e1 > t1.length) && (e1 = t1.length);
                    for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                    return n1;
                }
                function i1(t1) {
                    return (i1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                var s1, a1 = r1(111), u1 = r1(46), c1 = r1(62), l1 = r1(63).Buffer, f1 = r1(20), p1 = r1(13), h1 = r1(113), y1 = r1(28), d1 = r1(21), m1 = r1(66), _1 = r1(65), v1 = r1(29), g1 = r1(24), b1 = r1(47);
                function w1(t1) {
                    if (Array.isArray(t1.populate)) {
                        var r1 = [];
                        t1.populate.forEach(function(t1) {
                            if (/[\s]/.test(t1.path)) {
                                var n1 = Object.assign({}, t1);
                                n1.path.split(" ").forEach(function(t1) {
                                    n1.path = t1, r1.push(e1.populate(n1)[0]);
                                });
                            } else r1.push(e1.populate(t1)[0]);
                        }), t1.populate = e1.populate(r1);
                    } else null != t1.populate && "object" === i1(t1.populate) && (t1.populate = e1.populate(t1.populate));
                    var o1 = [], s1 = t1.path.split(" ");
                    null != t1.options && (t1.options = e1.clone(t1.options));
                    var a1, u1 = n1(s1);
                    try {
                        for(u1.s(); !(a1 = u1.n()).done;){
                            var c1 = a1.value;
                            o1.push(new h1(Object.assign({}, t1, {
                                path: c1
                            })));
                        }
                    } catch (t1) {
                        u1.e(t1);
                    } finally{
                        u1.f();
                    }
                    return o1;
                }
                /*!
 * Return the value of `obj` at the given `path`.
 *
 * @param {String} path
 * @param {Object} obj
 */ e1.specialProperties = b1, /*!
 * Produces a collection name from model `name`. By default, just returns
 * the model name
 *
 * @param {String} name a model name
 * @param {Function} pluralize function that pluralizes the collection name
 * @return {String} a collection name
 * @api private
 */ e1.toCollectionName = function(t1, e1) {
                    return "system.profile" === t1 || "system.indexes" === t1 ? t1 : "function" == typeof e1 ? e1(t1) : t1;
                }, /*!
 * Determines if `a` and `b` are deep equal.
 *
 * Modified from node/lib/assert.js
 *
 * @param {any} a a value to compare to `b`
 * @param {any} b a value to compare to `a`
 * @return {Boolean}
 * @api private
 */ e1.deepEqual = function t1(r1, n1) {
                    if (r1 === n1) return !0;
                    if (r1 instanceof Date && n1 instanceof Date) return r1.getTime() === n1.getTime();
                    if (m1(r1, "ObjectID") && m1(n1, "ObjectID") || m1(r1, "Decimal128") && m1(n1, "Decimal128")) return r1.toString() === n1.toString();
                    if (r1 instanceof RegExp && n1 instanceof RegExp) return r1.source === n1.source && r1.ignoreCase === n1.ignoreCase && r1.multiline === n1.multiline && r1.global === n1.global;
                    if ("object" !== i1(r1) && "object" !== i1(n1)) return r1 === n1;
                    if (null === r1 || null === n1 || void 0 === r1 || void 0 === n1) return !1;
                    if (r1.prototype !== n1.prototype) return !1;
                    if (r1 instanceof Map && n1 instanceof Map) return t1(Array.from(r1.keys()), Array.from(n1.keys())) && t1(Array.from(r1.values()), Array.from(n1.values()));
                    if (r1 instanceof Number && n1 instanceof Number) return r1.valueOf() === n1.valueOf();
                    if (l1.isBuffer(r1)) return e1.buffer.areEqual(r1, n1);
                    var o1, s1, a1, u1;
                    v1(r1) && (r1 = r1.toObject()), v1(n1) && (n1 = n1.toObject());
                    try {
                        o1 = Object.keys(r1), s1 = Object.keys(n1);
                    } catch (t1) {
                        return !1;
                    }
                    if (o1.length !== s1.length) return !1;
                    for(o1.sort(), s1.sort(), u1 = o1.length - 1; u1 >= 0; u1--)if (o1[u1] !== s1[u1]) return !1;
                    for(u1 = o1.length - 1; u1 >= 0; u1--)if (!t1(r1[a1 = o1[u1]], n1[a1])) return !1;
                    return !0;
                }, /*!
 * Get the last element of an array
 */ e1.last = function(t1) {
                    if (t1.length > 0) return t1[t1.length - 1];
                }, e1.clone = y1, /*!
 * ignore
 */ e1.promiseOrCallback = g1, /*!
 * ignore
 */ e1.omit = function(t1, e1) {
                    if (null == e1) return Object.assign({}, t1);
                    Array.isArray(e1) || (e1 = [
                        e1
                    ]);
                    var r1, o1 = Object.assign({}, t1), i1 = n1(e1);
                    try {
                        for(i1.s(); !(r1 = i1.n()).done;)delete o1[r1.value];
                    } catch (t1) {
                        i1.e(t1);
                    } finally{
                        i1.f();
                    }
                    return o1;
                }, /*!
 * Shallow copies defaults into options.
 *
 * @param {Object} defaults
 * @param {Object} options
 * @return {Object} the merged object
 * @api private
 */ e1.options = function(t1, e1) {
                    var r1, n1 = Object.keys(t1), o1 = n1.length;
                    for(e1 = e1 || {}; o1--;)(r1 = n1[o1]) in e1 || (e1[r1] = t1[r1]);
                    return e1;
                }, /*!
 * Generates a random string
 *
 * @api private
 */ e1.random = function() {
                    return Math.random().toString().substr(3);
                }, /*!
 * Merges `from` into `to` without overwriting existing properties.
 *
 * @param {Object} to
 * @param {Object} from
 * @api private
 */ e1.merge = function t1(r1, n1, o1, i1) {
                    o1 = o1 || {};
                    var s1, a1 = Object.keys(n1), u1 = 0, c1 = a1.length;
                    i1 = i1 || "";
                    for(var l1 = o1.omitNested || {}; u1 < c1;)if (s1 = a1[u1++], !(o1.omit && o1.omit[s1] || l1[i1] || b1.has(s1))) {
                        if (null == r1[s1]) r1[s1] = n1[s1];
                        else if (e1.isObject(n1[s1])) {
                            if (e1.isObject(r1[s1]) || (r1[s1] = {}), null != n1[s1]) {
                                if (o1.isDiscriminatorSchemaMerge && n1[s1].$isSingleNested && r1[s1].$isMongooseDocumentArray || n1[s1].$isMongooseDocumentArray && r1[s1].$isSingleNested) continue;
                                if (n1[s1].instanceOfSchema) {
                                    r1[s1].instanceOfSchema ? r1[s1].add(n1[s1].clone()) : r1[s1] = n1[s1].clone();
                                    continue;
                                }
                                if (n1[s1] instanceof p1) {
                                    r1[s1] = new p1(n1[s1]);
                                    continue;
                                }
                            }
                            t1(r1[s1], n1[s1], o1, i1 ? i1 + "." + s1 : s1);
                        } else o1.overwrite && (r1[s1] = n1[s1]);
                    }
                }, /*!
 * Applies toObject recursively.
 *
 * @param {Document|Array|Object} obj
 * @return {Object}
 * @api private
 */ e1.toObject = function t1(o1) {
                    var i1;
                    if (s1 || (s1 = r1(6)), null == o1) return o1;
                    if (o1 instanceof s1) return o1.toObject();
                    if (Array.isArray(o1)) {
                        i1 = [];
                        var a1, u1 = n1(o1);
                        try {
                            for(u1.s(); !(a1 = u1.n()).done;){
                                var c1 = a1.value;
                                i1.push(t1(c1));
                            }
                        } catch (t1) {
                            u1.e(t1);
                        } finally{
                            u1.f();
                        }
                        return i1;
                    }
                    if (e1.isPOJO(o1)) {
                        for(var l1 in i1 = {}, o1)b1.has(l1) || (i1[l1] = t1(o1[l1]));
                        return i1;
                    }
                    return o1;
                }, e1.isObject = d1, /*!
 * Determines if `arg` is a plain old JavaScript object (POJO). Specifically,
 * `arg` must be an object but not an instance of any special class, like String,
 * ObjectId, etc.
 *
 * `Object.getPrototypeOf()` is part of ES5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @api private
 * @return {Boolean}
 */ e1.isPOJO = function(t1) {
                    if (null == t1 || "object" !== i1(t1)) return !1;
                    var e1 = Object.getPrototypeOf(t1);
                    return !e1 || "Object" === e1.constructor.name;
                }, /*!
 * Determines if `obj` is a built-in object like an array, date, boolean,
 * etc.
 */ e1.isNativeObject = function(t1) {
                    return Array.isArray(t1) || t1 instanceof Date || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String;
                }, /*!
 * Determines if `val` is an object that has no own keys
 */ e1.isEmptyObject = function(t1) {
                    return null != t1 && "object" === i1(t1) && 0 === Object.keys(t1).length;
                }, /*!
 * Search if `obj` or any POJOs nested underneath `obj` has a property named
 * `key`
 */ e1.hasKey = function(t1, r1) {
                    for(var n1 = 0, o1 = Object.keys(t1); n1 < o1.length; n1++){
                        var i1 = o1[n1];
                        if (i1 === r1) return !0;
                        if (e1.isPOJO(t1[i1]) && e1.hasKey(t1[i1], r1)) return !0;
                    }
                    return !1;
                }, /*!
 * A faster Array.prototype.slice.call(arguments) alternative
 * @api private
 */ e1.args = c1, /*!
 * process.nextTick helper.
 *
 * Wraps `callback` in a try/catch + nextTick.
 *
 * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.
 *
 * @param {Function} callback
 * @api private
 */ e1.tick = function(e1) {
                    if ("function" == typeof e1) return function() {
                        try {
                            e1.apply(this, arguments);
                        } catch (e1) {
                            t1.nextTick(function() {
                                throw e1;
                            });
                        }
                    };
                }, /*!
 * Returns true if `v` is an object that can be serialized as a primitive in
 * MongoDB
 */ e1.isMongooseType = function(t1) {
                    return t1 instanceof p1 || t1 instanceof f1 || t1 instanceof l1;
                }, e1.isMongooseObject = v1, /*!
 * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.
 *
 * @param {Object} object
 * @api private
 */ e1.expires = function(t1) {
                    var e1;
                    t1 && "Object" === t1.constructor.name && "expires" in t1 && (e1 = "string" != typeof t1.expires ? t1.expires : Math.round(a1(t1.expires) / 1e3), t1.expireAfterSeconds = e1, delete t1.expires);
                }, /*!
 * populate helper
 */ e1.populate = function(t1, r1, n1, o1, s1, a1, u1, c1) {
                    var l1 = null;
                    if (1 === arguments.length) {
                        if (t1 instanceof h1) return [
                            t1
                        ];
                        if (Array.isArray(t1)) {
                            var f1 = p1(t1);
                            return f1.map(function(t1) {
                                return e1.populate(t1)[0];
                            });
                        }
                        l1 = e1.isObject(t1) ? Object.assign({}, t1) : {
                            path: t1
                        };
                    } else l1 = "object" === i1(n1) ? {
                        path: t1,
                        select: r1,
                        match: n1,
                        options: o1
                    } : {
                        path: t1,
                        select: r1,
                        model: n1,
                        match: o1,
                        options: s1,
                        populate: a1,
                        justOne: u1,
                        count: c1
                    };
                    if ("string" != typeof l1.path) throw new TypeError("utils.populate: invalid path. Expected string. Got typeof `" + i1(t1) + "`");
                    return w1(l1);
                    function p1(t1) {
                        var e1 = [];
                        return t1.forEach(function(t1) {
                            /[\s]/.test(t1.path) ? t1.path.split(" ").forEach(function(r1) {
                                var n1 = Object.assign({}, t1);
                                n1.path = r1, e1.push(n1);
                            }) : e1.push(t1);
                        }), e1;
                    }
                }, e1.getValue = function(t1, e1, r1) {
                    return u1.get(t1, e1, "_doc", r1);
                }, /*!
 * Sets the value of `obj` at the given `path`.
 *
 * @param {String} path
 * @param {Anything} val
 * @param {Object} obj
 */ e1.setValue = function(t1, e1, r1, n1, o1) {
                    u1.set(t1, e1, r1, "_doc", n1, o1);
                }, /*!
 * Returns an array of values from object `o`.
 *
 * @param {Object} o
 * @return {Array}
 * @private
 */ e1.object = {}, e1.object.vals = function(t1) {
                    for(var e1 = Object.keys(t1), r1 = e1.length, n1 = []; r1--;)n1.push(t1[e1[r1]]);
                    return n1;
                }, /*!
 * @see exports.options
 */ e1.object.shallowCopy = e1.options;
                /*!
 * Safer helper for hasOwnProperty checks
 *
 * @param {Object} obj
 * @param {String} prop
 */ var O1 = Object.prototype.hasOwnProperty;
                e1.object.hasOwnProperty = function(t1, e1) {
                    return O1.call(t1, e1);
                }, /*!
 * Determine if `val` is null or undefined
 *
 * @return {Boolean}
 */ e1.isNullOrUndefined = function(t1) {
                    return null == t1;
                }, /*!
 * ignore
 */ e1.array = {}, /*!
 * Flattens an array.
 *
 * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]
 *
 * @param {Array} arr
 * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsy value, the item will not be included in the results.
 * @return {Array}
 * @private
 */ e1.array.flatten = function t1(e1, r1, n1) {
                    return n1 || (n1 = []), e1.forEach(function(e1) {
                        Array.isArray(e1) ? t1(e1, r1, n1) : r1 && !r1(e1) || n1.push(e1);
                    }), n1;
                };
                /*!
 * ignore
 */ var S1 = Object.prototype.hasOwnProperty;
                e1.hasUserDefinedProperty = function(t1, r1) {
                    if (null == t1) return !1;
                    if (Array.isArray(r1)) {
                        var o1, s1 = n1(r1);
                        try {
                            for(s1.s(); !(o1 = s1.n()).done;){
                                var a1 = o1.value;
                                if (e1.hasUserDefinedProperty(t1, a1)) return !0;
                            }
                        } catch (t1) {
                            s1.e(t1);
                        } finally{
                            s1.f();
                        }
                        return !1;
                    }
                    if (S1.call(t1, r1)) return !0;
                    if ("object" === i1(t1) && r1 in t1) {
                        var u1 = t1[r1];
                        return u1 !== Object.prototype[r1] && u1 !== Array.prototype[r1];
                    }
                    return !1;
                };
                /*!
 * ignore
 */ var A1 = Math.pow(2, 32) - 1;
                e1.isArrayIndex = function(t1) {
                    return "number" == typeof t1 ? t1 >= 0 && t1 <= A1 : "string" == typeof t1 && !!/^\d+$/.test(t1) && (t1 = +t1) >= 0 && t1 <= A1;
                }, /*!
 * Removes duplicate values from an array
 *
 * [1, 2, 3, 3, 5] => [1, 2, 3, 5]
 * [ ObjectId("550988ba0c19d57f697dc45e"), ObjectId("550988ba0c19d57f697dc45e") ]
 *    => [ObjectId("550988ba0c19d57f697dc45e")]
 *
 * @param {Array} arr
 * @return {Array}
 * @private
 */ e1.array.unique = function(t1) {
                    var e1, r1 = {}, o1 = {}, i1 = [], s1 = n1(t1);
                    try {
                        for(s1.s(); !(e1 = s1.n()).done;){
                            var a1 = e1.value;
                            if ("number" == typeof a1 || "string" == typeof a1 || null == a1) {
                                if (r1[a1]) continue;
                                i1.push(a1), r1[a1] = !0;
                            } else if (a1 instanceof p1) {
                                if (o1[a1.toString()]) continue;
                                i1.push(a1), o1[a1.toString()] = !0;
                            } else i1.push(a1);
                        }
                    } catch (t1) {
                        s1.e(t1);
                    } finally{
                        s1.f();
                    }
                    return i1;
                }, /*!
 * Determines if two buffers are equal.
 *
 * @param {Buffer} a
 * @param {Object} b
 */ e1.buffer = {}, e1.buffer.areEqual = function(t1, e1) {
                    if (!l1.isBuffer(t1)) return !1;
                    if (!l1.isBuffer(e1)) return !1;
                    if (t1.length !== e1.length) return !1;
                    for(var r1 = 0, n1 = t1.length; r1 < n1; ++r1)if (t1[r1] !== e1[r1]) return !1;
                    return !0;
                }, e1.getFunctionName = _1, /*!
 * Decorate buffers
 */ e1.decorate = function(t1, e1) {
                    for(var r1 in e1)b1.has(r1) || (t1[r1] = e1[r1]);
                }, e1.mergeClone = function(t1, r1) {
                    v1(r1) && (r1 = r1.toObject({
                        transform: !1,
                        virtuals: !1,
                        depopulate: !0,
                        getters: !1,
                        flattenDecimals: !1
                    }));
                    for(var n1, o1 = Object.keys(r1), i1 = o1.length, s1 = 0; s1 < i1;)if (n1 = o1[s1++], !b1.has(n1)) {
                        if (void 0 === t1[n1]) t1[n1] = e1.clone(r1[n1], {
                            transform: !1,
                            virtuals: !1,
                            depopulate: !0,
                            getters: !1,
                            flattenDecimals: !1
                        });
                        else {
                            var a1 = r1[n1];
                            if (null == a1 || !a1.valueOf || a1 instanceof Date || (a1 = a1.valueOf()), e1.isObject(a1)) {
                                var u1 = a1;
                                v1(a1) && !a1.isMongooseBuffer && (u1 = u1.toObject({
                                    transform: !1,
                                    virtuals: !1,
                                    depopulate: !0,
                                    getters: !1,
                                    flattenDecimals: !1
                                })), a1.isMongooseBuffer && (u1 = l1.from(u1)), e1.mergeClone(t1[n1], u1);
                            } else t1[n1] = e1.clone(a1, {
                                flattenDecimals: !1
                            });
                        }
                    }
                }, e1.each = function(t1, e1) {
                    var r1, o1 = n1(t1);
                    try {
                        for(o1.s(); !(r1 = o1.n()).done;)e1(r1.value);
                    } catch (t1) {
                        o1.e(t1);
                    } finally{
                        o1.f();
                    }
                }, /*!
 * ignore
 */ e1.getOption = function(t1) {
                    var e1, r1 = Array.prototype.slice.call(arguments, 1), o1 = n1(r1);
                    try {
                        for(o1.s(); !(e1 = o1.n()).done;){
                            var i1 = e1.value;
                            if (null != i1[t1]) return i1[t1];
                        }
                    } catch (t1) {
                        o1.e(t1);
                    } finally{
                        o1.f();
                    }
                    return null;
                }, /*!
 * ignore
 */ e1.noop = function() {};
            }).call(this, r1(8));
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Simplified lodash.get to work around the annoying null quirk. See:
 * https://github.com/lodash/lodash/issues/3659
 */ function n1(t1, e1) {
                var r1;
                if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                    if (Array.isArray(t1) || (r1 = function(t1, e1) {
                        if (!t1) return;
                        if ("string" == typeof t1) return o1(t1, e1);
                        var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                        "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                        if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                        if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return o1(t1, e1);
                    }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                        r1 && (t1 = r1);
                        var n1 = 0, i1 = function() {};
                        return {
                            s: i1,
                            n: function() {
                                return n1 >= t1.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t1[n1++]
                                };
                            },
                            e: function(t1) {
                                throw t1;
                            },
                            f: i1
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var s1, a1 = !0, u1 = !1;
                return {
                    s: function() {
                        r1 = t1[Symbol.iterator]();
                    },
                    n: function() {
                        var t1 = r1.next();
                        return a1 = t1.done, t1;
                    },
                    e: function(t1) {
                        u1 = !0, s1 = t1;
                    },
                    f: function() {
                        try {
                            a1 || null == r1.return || r1.return();
                        } finally{
                            if (u1) throw s1;
                        }
                    }
                };
            }
            function o1(t1, e1) {
                (null == e1 || e1 > t1.length) && (e1 = t1.length);
                for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                return n1;
            }
            function i1(t1, e1) {
                return null == t1 ? t1 : t1 instanceof Map ? t1.get(e1) : t1[e1];
            }
            t1.exports = function(t1, e1, r1) {
                var o1, s1 = e1.split("."), a1 = e1, u1 = t1, c1 = n1(s1);
                try {
                    for(c1.s(); !(o1 = c1.n()).done;){
                        var l1 = o1.value;
                        if (null == u1) return r1;
                        if (null != u1[a1]) return u1[a1];
                        u1 = i1(u1, l1), a1 = a1.substr(l1.length + 1);
                    }
                } catch (t1) {
                    c1.e(t1);
                } finally{
                    c1.f();
                }
                return null == u1 ? r1 : u1;
            };
        },
        function(t1, e1, r1) {
            (function(t1) {
                function n1(t1) {
                    return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                var o1 = Object.getOwnPropertyDescriptors || function(t1) {
                    for(var e1 = Object.keys(t1), r1 = {}, n1 = 0; n1 < e1.length; n1++)r1[e1[n1]] = Object.getOwnPropertyDescriptor(t1, e1[n1]);
                    return r1;
                }, i1 = /%[sdj%]/g;
                e1.format = function(t1) {
                    if (!v1(t1)) {
                        for(var e1 = [], r1 = 0; r1 < arguments.length; r1++)e1.push(u1(arguments[r1]));
                        return e1.join(" ");
                    }
                    r1 = 1;
                    for(var n1 = arguments, o1 = n1.length, s1 = String(t1).replace(i1, function(t1) {
                        if ("%%" === t1) return "%";
                        if (r1 >= o1) return t1;
                        switch(t1){
                            case "%s":
                                return String(n1[r1++]);
                            case "%d":
                                return Number(n1[r1++]);
                            case "%j":
                                try {
                                    return JSON.stringify(n1[r1++]);
                                } catch (t1) {
                                    return "[Circular]";
                                }
                            default:
                                return t1;
                        }
                    }), a1 = n1[r1]; r1 < o1; a1 = n1[++r1])m1(a1) || !w1(a1) ? s1 += " " + a1 : s1 += " " + u1(a1);
                    return s1;
                }, e1.deprecate = function(r1, n1) {
                    if (void 0 !== t1 && !0 === t1.noDeprecation) return r1;
                    if (void 0 === t1) return function() {
                        return e1.deprecate(r1, n1).apply(this, arguments);
                    };
                    var o1 = !1;
                    return function() {
                        if (!o1) {
                            if (t1.throwDeprecation) throw new Error(n1);
                            t1.traceDeprecation ? console.trace(n1) : console.error(n1), o1 = !0;
                        }
                        return r1.apply(this, arguments);
                    };
                };
                var s1, a1 = {};
                function u1(t1, r1) {
                    var n1 = {
                        seen: [],
                        stylize: l1
                    };
                    return arguments.length >= 3 && (n1.depth = arguments[2]), arguments.length >= 4 && (n1.colors = arguments[3]), d1(r1) ? n1.showHidden = r1 : r1 && e1._extend(n1, r1), g1(n1.showHidden) && (n1.showHidden = !1), g1(n1.depth) && (n1.depth = 2), g1(n1.colors) && (n1.colors = !1), g1(n1.customInspect) && (n1.customInspect = !0), n1.colors && (n1.stylize = c1), f1(n1, t1, n1.depth);
                }
                function c1(t1, e1) {
                    var r1 = u1.styles[e1];
                    return r1 ? "\x1b[" + u1.colors[r1][0] + "m" + t1 + "\x1b[" + u1.colors[r1][1] + "m" : t1;
                }
                function l1(t1, e1) {
                    return t1;
                }
                function f1(t1, r1, n1) {
                    if (t1.customInspect && r1 && A1(r1.inspect) && r1.inspect !== e1.inspect && (!r1.constructor || r1.constructor.prototype !== r1)) {
                        var o1 = r1.inspect(n1, t1);
                        return v1(o1) || (o1 = f1(t1, o1, n1)), o1;
                    }
                    var i1 = function(t1, e1) {
                        if (g1(e1)) return t1.stylize("undefined", "undefined");
                        if (v1(e1)) {
                            var r1 = "'" + JSON.stringify(e1).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                            return t1.stylize(r1, "string");
                        }
                        if (_1(e1)) return t1.stylize("" + e1, "number");
                        if (d1(e1)) return t1.stylize("" + e1, "boolean");
                        if (m1(e1)) return t1.stylize("null", "null");
                    }(t1, r1);
                    if (i1) return i1;
                    var s1 = Object.keys(r1), a1 = function(t1) {
                        var e1 = {};
                        return t1.forEach(function(t1, r1) {
                            e1[t1] = !0;
                        }), e1;
                    }(s1);
                    if (t1.showHidden && (s1 = Object.getOwnPropertyNames(r1)), S1(r1) && (s1.indexOf("message") >= 0 || s1.indexOf("description") >= 0)) return p1(r1);
                    if (0 === s1.length) {
                        if (A1(r1)) {
                            var u1 = r1.name ? ": " + r1.name : "";
                            return t1.stylize("[Function" + u1 + "]", "special");
                        }
                        if (b1(r1)) return t1.stylize(RegExp.prototype.toString.call(r1), "regexp");
                        if (O1(r1)) return t1.stylize(Date.prototype.toString.call(r1), "date");
                        if (S1(r1)) return p1(r1);
                    }
                    var c1, l1 = "", w1 = !1, j1 = [
                        "{",
                        "}"
                    ];
                    (y1(r1) && (w1 = !0, j1 = [
                        "[",
                        "]"
                    ]), A1(r1)) && (l1 = " [Function" + (r1.name ? ": " + r1.name : "") + "]");
                    return b1(r1) && (l1 = " " + RegExp.prototype.toString.call(r1)), O1(r1) && (l1 = " " + Date.prototype.toUTCString.call(r1)), S1(r1) && (l1 = " " + p1(r1)), 0 !== s1.length || w1 && 0 != r1.length ? n1 < 0 ? b1(r1) ? t1.stylize(RegExp.prototype.toString.call(r1), "regexp") : t1.stylize("[Object]", "special") : (t1.seen.push(r1), c1 = w1 ? function(t1, e1, r1, n1, o1) {
                        for(var i1 = [], s1 = 0, a1 = e1.length; s1 < a1; ++s1)x1(e1, String(s1)) ? i1.push(h1(t1, e1, r1, n1, String(s1), !0)) : i1.push("");
                        return o1.forEach(function(o1) {
                            o1.match(/^\d+$/) || i1.push(h1(t1, e1, r1, n1, o1, !0));
                        }), i1;
                    }(t1, r1, n1, a1, s1) : s1.map(function(e1) {
                        return h1(t1, r1, n1, a1, e1, w1);
                    }), t1.seen.pop(), function(t1, e1, r1) {
                        if (t1.reduce(function(t1, e1) {
                            return e1.indexOf("\n"), t1 + e1.replace(/\u001b\[\d\d?m/g, "").length + 1;
                        }, 0) > 60) return r1[0] + ("" === e1 ? "" : e1 + "\n ") + " " + t1.join(",\n  ") + " " + r1[1];
                        return r1[0] + e1 + " " + t1.join(", ") + " " + r1[1];
                    }(c1, l1, j1)) : j1[0] + l1 + j1[1];
                }
                function p1(t1) {
                    return "[" + Error.prototype.toString.call(t1) + "]";
                }
                function h1(t1, e1, r1, n1, o1, i1) {
                    var s1, a1, u1;
                    if ((u1 = Object.getOwnPropertyDescriptor(e1, o1) || {
                        value: e1[o1]
                    }).get ? a1 = u1.set ? t1.stylize("[Getter/Setter]", "special") : t1.stylize("[Getter]", "special") : u1.set && (a1 = t1.stylize("[Setter]", "special")), x1(n1, o1) || (s1 = "[" + o1 + "]"), a1 || (t1.seen.indexOf(u1.value) < 0 ? (a1 = m1(r1) ? f1(t1, u1.value, null) : f1(t1, u1.value, r1 - 1)).indexOf("\n") > -1 && (a1 = i1 ? a1.split("\n").map(function(t1) {
                        return "  " + t1;
                    }).join("\n").substr(2) : "\n" + a1.split("\n").map(function(t1) {
                        return "   " + t1;
                    }).join("\n")) : a1 = t1.stylize("[Circular]", "special")), g1(s1)) {
                        if (i1 && o1.match(/^\d+$/)) return a1;
                        (s1 = JSON.stringify("" + o1)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s1 = s1.substr(1, s1.length - 2), s1 = t1.stylize(s1, "name")) : (s1 = s1.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s1 = t1.stylize(s1, "string"));
                    }
                    return s1 + ": " + a1;
                }
                function y1(t1) {
                    return Array.isArray(t1);
                }
                function d1(t1) {
                    return "boolean" == typeof t1;
                }
                function m1(t1) {
                    return null === t1;
                }
                function _1(t1) {
                    return "number" == typeof t1;
                }
                function v1(t1) {
                    return "string" == typeof t1;
                }
                function g1(t1) {
                    return void 0 === t1;
                }
                function b1(t1) {
                    return w1(t1) && "[object RegExp]" === j1(t1);
                }
                function w1(t1) {
                    return "object" === n1(t1) && null !== t1;
                }
                function O1(t1) {
                    return w1(t1) && "[object Date]" === j1(t1);
                }
                function S1(t1) {
                    return w1(t1) && ("[object Error]" === j1(t1) || t1 instanceof Error);
                }
                function A1(t1) {
                    return "function" == typeof t1;
                }
                function j1(t1) {
                    return Object.prototype.toString.call(t1);
                }
                function E1(t1) {
                    return t1 < 10 ? "0" + t1.toString(10) : t1.toString(10);
                }
                e1.debuglog = function(r1) {
                    if (g1(s1) && (s1 = t1.env.NODE_DEBUG || ""), r1 = r1.toUpperCase(), !a1[r1]) {
                        if (new RegExp("\\b" + r1 + "\\b", "i").test(s1)) {
                            var n1 = t1.pid;
                            a1[r1] = function() {
                                var t1 = e1.format.apply(e1, arguments);
                                console.error("%s %d: %s", r1, n1, t1);
                            };
                        } else a1[r1] = function() {};
                    }
                    return a1[r1];
                }, e1.inspect = u1, u1.colors = {
                    bold: [
                        1,
                        22
                    ],
                    italic: [
                        3,
                        23
                    ],
                    underline: [
                        4,
                        24
                    ],
                    inverse: [
                        7,
                        27
                    ],
                    white: [
                        37,
                        39
                    ],
                    grey: [
                        90,
                        39
                    ],
                    black: [
                        30,
                        39
                    ],
                    blue: [
                        34,
                        39
                    ],
                    cyan: [
                        36,
                        39
                    ],
                    green: [
                        32,
                        39
                    ],
                    magenta: [
                        35,
                        39
                    ],
                    red: [
                        31,
                        39
                    ],
                    yellow: [
                        33,
                        39
                    ]
                }, u1.styles = {
                    special: "cyan",
                    number: "yellow",
                    boolean: "yellow",
                    undefined: "grey",
                    null: "bold",
                    string: "green",
                    date: "magenta",
                    regexp: "red"
                }, e1.isArray = y1, e1.isBoolean = d1, e1.isNull = m1, e1.isNullOrUndefined = function(t1) {
                    return null == t1;
                }, e1.isNumber = _1, e1.isString = v1, e1.isSymbol = function(t1) {
                    return "symbol" === n1(t1);
                }, e1.isUndefined = g1, e1.isRegExp = b1, e1.isObject = w1, e1.isDate = O1, e1.isError = S1, e1.isFunction = A1, e1.isPrimitive = function(t1) {
                    return null === t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || "symbol" === n1(t1) || void 0 === t1;
                }, e1.isBuffer = r1(100);
                var $1 = [
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec"
                ];
                function P1() {
                    var t1 = new Date, e1 = [
                        E1(t1.getHours()),
                        E1(t1.getMinutes()),
                        E1(t1.getSeconds())
                    ].join(":");
                    return [
                        t1.getDate(),
                        $1[t1.getMonth()],
                        e1
                    ].join(" ");
                }
                function x1(t1, e1) {
                    return Object.prototype.hasOwnProperty.call(t1, e1);
                }
                e1.log = function() {
                    console.log("%s - %s", P1(), e1.format.apply(e1, arguments));
                }, e1.inherits = r1(101), e1._extend = function(t1, e1) {
                    if (!e1 || !w1(e1)) return t1;
                    for(var r1 = Object.keys(e1), n1 = r1.length; n1--;)t1[r1[n1]] = e1[r1[n1]];
                    return t1;
                };
                var N1 = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
                function T1(t1, e1) {
                    if (!t1) {
                        var r1 = new Error("Promise was rejected with a falsy value");
                        r1.reason = t1, t1 = r1;
                    }
                    return e1(t1);
                }
                e1.promisify = function(t1) {
                    if ("function" != typeof t1) throw new TypeError('The "original" argument must be of type Function');
                    if (N1 && t1[N1]) {
                        var e1;
                        if ("function" != typeof (e1 = t1[N1])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        return Object.defineProperty(e1, N1, {
                            value: e1,
                            enumerable: !1,
                            writable: !1,
                            configurable: !0
                        }), e1;
                    }
                    function e1() {
                        for(var e1, r1, n1 = new Promise(function(t1, n1) {
                            e1 = t1, r1 = n1;
                        }), o1 = [], i1 = 0; i1 < arguments.length; i1++)o1.push(arguments[i1]);
                        o1.push(function(t1, n1) {
                            t1 ? r1(t1) : e1(n1);
                        });
                        try {
                            t1.apply(this, o1);
                        } catch (t1) {
                            r1(t1);
                        }
                        return n1;
                    }
                    return Object.setPrototypeOf(e1, Object.getPrototypeOf(t1)), N1 && Object.defineProperty(e1, N1, {
                        value: e1,
                        enumerable: !1,
                        writable: !1,
                        configurable: !0
                    }), Object.defineProperties(e1, o1(t1));
                }, e1.promisify.custom = N1, e1.callbackify = function(e1) {
                    if ("function" != typeof e1) throw new TypeError('The "original" argument must be of type Function');
                    function r1() {
                        for(var r1 = [], n1 = 0; n1 < arguments.length; n1++)r1.push(arguments[n1]);
                        var o1 = r1.pop();
                        if ("function" != typeof o1) throw new TypeError("The last argument must be of type Function");
                        var i1 = this, s1 = function() {
                            return o1.apply(i1, arguments);
                        };
                        e1.apply(this, r1).then(function(e1) {
                            t1.nextTick(s1, null, e1);
                        }, function(e1) {
                            t1.nextTick(T1, e1, s1);
                        });
                    }
                    return Object.setPrototypeOf(r1, Object.getPrototypeOf(e1)), Object.defineProperties(r1, o1(e1)), r1;
                };
            }).call(this, r1(8));
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(14);
            /*!
 * Module exports.
 */ t1.exports = n1, n1.messages = r1(126), n1.Messages = n1.messages, n1.DocumentNotFoundError = r1(127), n1.CastError = r1(12), n1.ValidationError = r1(31), n1.ValidatorError = r1(71), n1.VersionError = r1(128), n1.ParallelSaveError = r1(129), n1.OverwriteModelError = r1(130), n1.MissingSchemaError = r1(131), n1.DivergentArrayError = r1(132), n1.StrictModeError = r1(32);
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1, n1) {
                /*!
 * Module dependencies.
 */ function o1(t1, e1, r1) {
                    return e1 in t1 ? Object.defineProperty(t1, e1, {
                        value: r1,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t1[e1] = r1, t1;
                }
                function i1(t1, e1) {
                    var r1;
                    if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                        if (Array.isArray(t1) || (r1 = function(t1, e1) {
                            if (!t1) return;
                            if ("string" == typeof t1) return s1(t1, e1);
                            var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                            "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                            if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                            if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return s1(t1, e1);
                        }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                            r1 && (t1 = r1);
                            var n1 = 0, o1 = function() {};
                            return {
                                s: o1,
                                n: function() {
                                    return n1 >= t1.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t1[n1++]
                                    };
                                },
                                e: function(t1) {
                                    throw t1;
                                },
                                f: o1
                            };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }
                    var i1, a1 = !0, u1 = !1;
                    return {
                        s: function() {
                            r1 = t1[Symbol.iterator]();
                        },
                        n: function() {
                            var t1 = r1.next();
                            return a1 = t1.done, t1;
                        },
                        e: function(t1) {
                            u1 = !0, i1 = t1;
                        },
                        f: function() {
                            try {
                                a1 || null == r1.return || r1.return();
                            } finally{
                                if (u1) throw i1;
                            }
                        }
                    };
                }
                function s1(t1, e1) {
                    (null == e1 || e1 > t1.length) && (e1 = t1.length);
                    for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                    return n1;
                }
                function a1(t1) {
                    return (a1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                var u1, c1, l1, f1 = r1(19).EventEmitter, p1 = r1(109), h1 = r1(5), y1 = r1(25), d1 = r1(73), m1 = r1(134), _1 = r1(135), v1 = r1(52), g1 = r1(32), b1 = r1(31), w1 = r1(71), O1 = r1(53), S1 = r1(24), A1 = r1(84), j1 = r1(57).compile, E1 = r1(57).defineKey, $1 = r1(171).flatten, P1 = r1(3), x1 = r1(172), N1 = r1(88), T1 = r1(173), k1 = r1(58), C1 = r1(174), D1 = r1(4).inspect, R1 = r1(17).internalToObjectOptions, B1 = r1(46), M1 = r1(175), I1 = r1(2), F1 = r1(177), L1 = I1.clone, U1 = I1.deepEqual, V1 = I1.isMongooseObject, q1 = Symbol("mongoose.Array#atomicsBackup"), W1 = r1(0).arrayAtomicsSymbol, H1 = r1(0).documentArrayParent, Y1 = r1(0).documentIsSelected, K1 = r1(0).documentIsModified, z1 = r1(0).documentModifiedPaths, Q1 = r1(0).documentSchemaSymbol, J1 = r1(0).getSymbol, G1 = r1(0).populateModelSymbol, X1 = r1(0).scopeSymbol, Z1 = I1.specialProperties;
                function tt1(t1, e1, r1, n1) {
                    var o1 = this;
                    "object" === a1(r1) && null != r1 && (r1 = (n1 = r1).skipId), n1 = Object.assign({}, n1);
                    var s1 = P1(n1, "defaults", !0);
                    if (n1.defaults = s1, null == this.schema) {
                        var u1 = I1.isObject(e1) && !e1.instanceOfSchema ? new v1(e1) : e1;
                        this.$__setSchema(u1), e1 = r1, r1 = n1, n1 = arguments[4] || {};
                    }
                    if (this.$__ = new p1, this.$__.emitter = new f1, this.isNew = !("isNew" in n1) || n1.isNew, this.errors = void 0, this.$__.$options = n1 || {}, this.$locals = {}, this.$op = null, null != t1 && "object" !== a1(t1)) throw new m1(t1, "obj", "Document");
                    var c1 = this.schema;
                    "boolean" == typeof e1 || "throw" === e1 ? (this.$__.strictMode = e1, e1 = void 0) : (this.$__.strictMode = c1.options.strict, this.$__.selected = e1);
                    var l1, h1 = c1.requiredPaths(!0), y1 = i1(h1);
                    try {
                        for(y1.s(); !(l1 = y1.n()).done;){
                            var d1 = l1.value;
                            this.$__.activePaths.require(d1);
                        }
                    } catch (t1) {
                        y1.e(t1);
                    } finally{
                        y1.f();
                    }
                    this.$__.emitter.setMaxListeners(0);
                    var _1 = null;
                    I1.isPOJO(e1) && (_1 = C1(e1));
                    var g1 = !1 === _1 && e1 ? rt1(e1) : {};
                    if (null == this._doc && (this.$__buildDoc(t1, e1, r1, _1, g1, !1), s1 && nt1(this, e1, r1, _1, g1, !0, {
                        isNew: this.isNew
                    })), t1 && (this.$__original_set ? this.$__original_set(t1, void 0, !0) : this.$set(t1, void 0, !0), t1 instanceof tt1 && (this.isNew = t1.isNew)), n1.willInit && s1 ? f1.prototype.once.call(this, "init", function() {
                        nt1(o1, e1, r1, _1, g1, !1, n1.skipDefaults, o1.isNew);
                    }) : s1 && nt1(this, e1, r1, _1, g1, !1, n1.skipDefaults, this.isNew), this.$__._id = this._id, !this.$__.strictMode && t1) {
                        var b1 = this, w1 = Object.keys(this._doc);
                        w1.forEach(function(t1) {
                            t1 in c1.tree || E1(t1, null, b1);
                        });
                    }
                    at1(this);
                }
                /*!
 * Document exposes the NodeJS event emitter API, so you can use
 * `on`, `once`, etc.
 */ for(var et1 in I1.each([
                    "on",
                    "once",
                    "emit",
                    "listeners",
                    "removeListener",
                    "setMaxListeners",
                    "removeAllListeners",
                    "addListener"
                ], function(t1) {
                    tt1.prototype[t1] = function() {
                        return this.$__.emitter[t1].apply(this.$__.emitter, arguments);
                    };
                }), tt1.prototype.constructor = tt1, f1.prototype)tt1[et1] = f1.prototype[et1];
                /*!
 * ignore
 */ function rt1(t1) {
                    for(var e1 = {}, r1 = 0, n1 = Object.keys(t1); r1 < n1.length; r1++){
                        var o1, s1 = [], a1 = i1(n1[r1].split("."));
                        try {
                            for(a1.s(); !(o1 = a1.n()).done;){
                                var u1 = o1.value;
                                s1.push(u1), e1[s1.join(".")] = 1;
                            }
                        } catch (t1) {
                            a1.e(t1);
                        } finally{
                            a1.f();
                        }
                    }
                    return e1;
                }
                /*!
 * ignore
 */ function nt1(t1, e1, r1, n1, o1, i1, s1) {
                    for(var a1 = Object.keys(t1.schema.paths), u1 = a1.length, c1 = 0; c1 < u1; ++c1){
                        var l1 = void 0, f1 = "", p1 = a1[c1];
                        if ("_id" !== p1 || !r1) for(var h1 = t1.schema.paths[p1], y1 = -1 === p1.indexOf(".") ? [
                            p1
                        ] : p1.split("."), d1 = y1.length, m1 = !1, _1 = t1._doc, v1 = 0; v1 < d1 && null != _1; ++v1){
                            var g1 = y1[v1];
                            if (f1 += (f1.length ? "." : "") + g1, !0 === n1) {
                                if (f1 in e1) break;
                            } else if (!1 === n1 && e1 && !m1) {
                                if (f1 in e1) m1 = !0;
                                else if (!o1[f1]) break;
                            }
                            if (v1 === d1 - 1) {
                                if (void 0 !== _1[g1]) break;
                                if ("function" == typeof h1.defaultValue) {
                                    if (!h1.defaultValue.$runBeforeSetters && i1) break;
                                    if (h1.defaultValue.$runBeforeSetters && !i1) break;
                                } else if (!i1) continue;
                                if (s1 && s1[f1]) break;
                                if (e1 && null !== n1) {
                                    if (!0 === n1) {
                                        if (p1 in e1) continue;
                                        try {
                                            l1 = h1.getDefault(t1, !1);
                                        } catch (e1) {
                                            t1.invalidate(p1, e1);
                                            break;
                                        }
                                        void 0 !== l1 && (_1[g1] = l1, t1.$__.activePaths.default(p1));
                                    } else if (m1) {
                                        try {
                                            l1 = h1.getDefault(t1, !1);
                                        } catch (e1) {
                                            t1.invalidate(p1, e1);
                                            break;
                                        }
                                        void 0 !== l1 && (_1[g1] = l1, t1.$__.activePaths.default(p1));
                                    }
                                } else {
                                    try {
                                        l1 = h1.getDefault(t1, !1);
                                    } catch (e1) {
                                        t1.invalidate(p1, e1);
                                        break;
                                    }
                                    void 0 !== l1 && (_1[g1] = l1, t1.$__.activePaths.default(p1));
                                }
                            } else _1 = _1[g1];
                        }
                    }
                }
                function ot1(t1) {
                    if (null == t1) return !0;
                    if ("object" !== a1(t1) || Array.isArray(t1)) return !1;
                    for(var e1 = 0, r1 = Object.keys(t1); e1 < r1.length; e1++){
                        if (!ot1(t1[r1[e1]])) return !1;
                    }
                    return !0;
                }
                /*!
 * ignore
 */ function it1(t1) {
                    var e1 = {};
                    !/*!
 * ignore
 */ function(t1) {
                        Object.keys(t1.$__.activePaths.states.require).forEach(function(e1) {
                            var r1 = t1.schema.path(e1);
                            null != r1 && "function" == typeof r1.originalRequiredValue && (t1.$__.cachedRequired[e1] = r1.originalRequiredValue.call(t1, t1));
                        });
                    }(t1);
                    var r1 = new Set(Object.keys(t1.$__.activePaths.states.require).filter(function(e1) {
                        return !(!t1.isSelected(e1) && !t1.isModified(e1)) && (!(e1 in t1.$__.cachedRequired) || t1.$__.cachedRequired[e1]);
                    }));
                    function n1(t1) {
                        r1.add(t1);
                    }
                    Object.keys(t1.$__.activePaths.states.init).forEach(n1), Object.keys(t1.$__.activePaths.states.modify).forEach(n1), Object.keys(t1.$__.activePaths.states.default).forEach(n1);
                    var o1, s1 = t1.$__getAllSubdocs(), a1 = t1.modifiedPaths(), u1 = i1(s1);
                    try {
                        for(u1.s(); !(o1 = u1.n()).done;){
                            var c1 = o1.value;
                            if (c1.$basePath) {
                                var l1, f1 = i1(r1);
                                try {
                                    for(f1.s(); !(l1 = f1.n()).done;){
                                        var p1 = l1.value;
                                        (null === p1 || p1.startsWith(c1.$basePath + ".")) && r1.delete(p1);
                                    }
                                } catch (t1) {
                                    f1.e(t1);
                                } finally{
                                    f1.f();
                                }
                                !t1.isModified(c1.$basePath, a1) || t1.isDirectModified(c1.$basePath) || t1.$isDefault(c1.$basePath) || (r1.add(c1.$basePath), e1[c1.$basePath] = !0);
                            }
                        }
                    } catch (t1) {
                        u1.e(t1);
                    } finally{
                        u1.f();
                    }
                    var h1, y1 = i1(r1);
                    try {
                        for(y1.s(); !(h1 = y1.n()).done;){
                            var d1 = h1.value, m1 = t1.schema.path(d1);
                            if (m1 && m1.$isMongooseArray && (!m1.$isMongooseDocumentArray || P1(m1, "schemaOptions.required"))) _1(t1.$__getValue(d1), r1, d1);
                        }
                    } catch (t1) {
                        y1.e(t1);
                    } finally{
                        y1.f();
                    }
                    function _1(t1, e1, r1) {
                        if (null != t1) for(var n1 = t1.length, o1 = 0; o1 < n1; ++o1)Array.isArray(t1[o1]) ? _1(t1[o1], e1, r1 + "." + o1) : e1.add(r1 + "." + o1);
                    }
                    var v1, g1 = {
                        skipArrays: !0
                    }, b1 = i1(r1);
                    try {
                        for(b1.s(); !(v1 = b1.n()).done;){
                            var w1 = v1.value;
                            if (t1.schema.nested[w1]) {
                                var O1 = t1.$__getValue(w1);
                                V1(O1) && (O1 = O1.toObject({
                                    transform: !1
                                }));
                                var S1 = $1(O1, w1, g1, t1.schema);
                                Object.keys(S1).forEach(n1);
                            }
                        }
                    } catch (t1) {
                        b1.e(t1);
                    } finally{
                        b1.f();
                    }
                    var A1, j1 = i1(r1);
                    try {
                        for(j1.s(); !(A1 = j1.n()).done;){
                            var E1 = A1.value;
                            if (t1.schema.singleNestedPaths.hasOwnProperty(E1)) r1.delete(E1);
                            else {
                                var x1 = t1.schema.path(E1);
                                if (x1 && x1.$isSchemaMap) {
                                    var N1 = t1.$__getValue(E1);
                                    if (null != N1) {
                                        var T1, k1 = i1(N1.keys());
                                        try {
                                            for(k1.s(); !(T1 = k1.n()).done;){
                                                var C1 = T1.value;
                                                r1.add(E1 + "." + C1);
                                            }
                                        } catch (t1) {
                                            k1.e(t1);
                                        } finally{
                                            k1.f();
                                        }
                                    }
                                }
                            }
                        }
                    } catch (t1) {
                        j1.e(t1);
                    } finally{
                        j1.f();
                    }
                    return [
                        r1 = Array.from(r1),
                        e1
                    ];
                }
                /*!
 * ignore
 */ /*!
 * ignore
 */ function st1(t1, e1) {
                    var r1, n1 = new Set(e1), o1 = new Map([]), s1 = i1(e1);
                    try {
                        for(s1.s(); !(r1 = s1.n()).done;){
                            var a1 = r1.value;
                            if (-1 !== a1.indexOf(".")) for(var u1 = a1.split("."), c1 = u1[0], l1 = 1; l1 < u1.length; ++l1)o1.set(c1, a1), c1 = c1 + "." + u1[l1];
                        }
                    } catch (t1) {
                        s1.e(t1);
                    } finally{
                        s1.f();
                    }
                    var f1, p1 = [], h1 = i1(t1);
                    try {
                        for(h1.s(); !(f1 = h1.n()).done;){
                            var y1 = f1.value;
                            n1.has(y1) ? p1.push(y1) : o1.has(y1) && p1.push(o1.get(y1));
                        }
                    } catch (t1) {
                        h1.e(t1);
                    } finally{
                        h1.f();
                    }
                    return p1;
                }
                /*!
 * Runs queued functions
 */ function at1(t1) {
                    var e1 = t1.schema && t1.schema.callQueue;
                    if (e1.length) {
                        var r1, n1 = i1(e1);
                        try {
                            for(n1.s(); !(r1 = n1.n()).done;){
                                var o1 = r1.value;
                                "pre" !== o1[0] && "post" !== o1[0] && "on" !== o1[0] && t1[o1[0]].apply(t1, o1[1]);
                            }
                        } catch (t1) {
                            n1.e(t1);
                        } finally{
                            n1.f();
                        }
                    }
                }
                /*!
 * ignore
 */ /*!
 * Applies virtuals properties to `json`.
 */ function ut1(t1, e1, r1, n1) {
                    var o1, i1, s1, a1 = t1.schema, u1 = Object.keys(a1.virtuals), c1 = u1.length, l1 = c1, f1 = t1._doc, p1 = P1(n1, "aliases", !0);
                    if (!f1) return e1;
                    for(r1 = r1 || {}, c1 = 0; c1 < l1; ++c1)if (o1 = u1[c1], p1 || !a1.aliases.hasOwnProperty(o1)) {
                        if (i1 = o1, null != r1.path) {
                            if (!o1.startsWith(r1.path + ".")) continue;
                            i1 = o1.substr(r1.path.length + 1);
                        }
                        var h1 = i1.split(".");
                        if (void 0 !== (s1 = L1(t1.get(o1), r1))) {
                            var y1 = h1.length;
                            f1 = e1;
                            for(var d1 = 0; d1 < y1 - 1; ++d1)f1[h1[d1]] = f1[h1[d1]] || {}, f1 = f1[h1[d1]];
                            f1[h1[y1 - 1]] = s1;
                        }
                    }
                    return e1;
                }
                /*!
 * Applies virtuals properties to `json`.
 *
 * @param {Document} self
 * @param {Object} json
 * @return {Object} `json`
 */ function ct1(t1, e1) {
                    if (F1(e1)) throw new Error("`transform` function must be synchronous, but the transform on path `" + t1 + "` returned a promise.");
                }
                /*!
 * ignore
 */ tt1.prototype.schema, Object.defineProperty(tt1.prototype, "$locals", {
                    configurable: !1,
                    enumerable: !1,
                    writable: !0
                }), tt1.prototype.isNew, tt1.prototype.id, tt1.prototype.errors, tt1.prototype.$op, tt1.prototype.$__buildDoc = function(t1, e1, r1, n1, o1) {
                    for(var i1 = {}, s1 = Object.keys(this.schema.paths).filter(function(t1) {
                        return !t1.includes("$*");
                    }), a1 = s1.length, u1 = 0; u1 < a1; ++u1){
                        var c1 = s1[u1];
                        if ("_id" === c1) {
                            if (r1) continue;
                            if (t1 && "_id" in t1) continue;
                        }
                        for(var l1 = c1.split("."), f1 = l1.length, p1 = f1 - 1, h1 = "", y1 = i1, d1 = !1, m1 = 0; m1 < f1; ++m1){
                            var _1 = l1[m1];
                            if (h1 += (h1.length ? "." : "") + _1, !0 === n1) {
                                if (h1 in e1) break;
                            } else if (!1 === n1 && e1 && !d1) {
                                if (h1 in e1) d1 = !0;
                                else if (!o1[h1]) break;
                            }
                            m1 < p1 && (y1 = y1[_1] || (y1[_1] = {}));
                        }
                    }
                    this._doc = i1;
                }, /*!
 * Converts to POJO when you use the document for querying
 */ tt1.prototype.toBSON = function() {
                    return this.toObject(R1);
                }, tt1.prototype.init = function(t1, e1, r1) {
                    return "function" == typeof e1 && (r1 = e1, e1 = null), this.$__init(t1, e1), r1 && r1(null, this), this;
                }, /*!
 * ignore
 */ tt1.prototype.$__init = function(t1, e1) {
                    if (this.isNew = !1, this.$init = !0, e1 = e1 || {}, null != t1._id && e1.populated && e1.populated.length) {
                        var r1, n1 = String(t1._id), o1 = i1(e1.populated);
                        try {
                            for(o1.s(); !(r1 = o1.n()).done;){
                                var s1 = r1.value;
                                if (s1.isVirtual ? this.populated(s1.path, I1.getValue(s1.path, t1), s1) : this.populated(s1.path, s1._docs[n1], s1), null != s1._childDocs) {
                                    var a1, u1 = i1(s1._childDocs);
                                    try {
                                        for(u1.s(); !(a1 = u1.n()).done;){
                                            var c1 = a1.value;
                                            null != c1 && null != c1.$__ && (c1.$__.parent = this);
                                        }
                                    } catch (t1) {
                                        u1.e(t1);
                                    } finally{
                                        u1.f();
                                    }
                                }
                            }
                        } catch (t1) {
                            o1.e(t1);
                        } finally{
                            o1.f();
                        }
                    }
                    /*!
 * Init helper.
 *
 * @param {Object} self document instance
 * @param {Object} obj raw mongodb doc
 * @param {Object} doc object we are initializing
 * @api private
 */ return function t1(e1, r1, n1, o1, i1) {
                        i1 = i1 || "";
                        var s1, a1, u1, c1 = Object.keys(r1), l1 = c1.length, f1 = 0;
                        for(; f1 < l1;)p1(f1++);
                        function p1(l1) {
                            if (u1 = c1[l1], a1 = i1 + u1, s1 = e1.schema.path(a1), !e1.schema.$isRootDiscriminator || e1.isSelected(a1)) {
                                if (!s1 && I1.isPOJO(r1[u1])) n1[u1] || (n1[u1] = {}), t1(e1, r1[u1], n1[u1], o1, a1 + ".");
                                else if (s1) {
                                    if (null === r1[u1]) n1[u1] = s1._castNullish(null);
                                    else if (void 0 !== r1[u1]) {
                                        var f1 = (r1[u1].$__ || {}).wasPopulated || null;
                                        if (s1 && !f1) try {
                                            n1[u1] = s1.cast(r1[u1], e1, !0);
                                        } catch (t1) {
                                            e1.invalidate(t1.path, new w1({
                                                path: t1.path,
                                                message: t1.message,
                                                type: "cast",
                                                value: t1.value,
                                                reason: t1
                                            }));
                                        }
                                        else n1[u1] = r1[u1];
                                    }
                                    e1.isModified(a1) || e1.$__.activePaths.init(a1);
                                } else n1[u1] = r1[u1];
                            }
                        }
                    }(this, t1, this._doc, e1), /*!
 * If populating a path within a document array, make sure each
 * subdoc within the array knows its subpaths are populated.
 *
 * ####Example:
 *     const doc = await Article.findOne().populate('comments.author');
 *     doc.comments[0].populated('author'); // Should be set
 */ function(t1, e1) {
                        if (null == t1._id || null == e1 || 0 === e1.length) return;
                        var r1, n1 = String(t1._id), o1 = i1(e1);
                        try {
                            for(o1.s(); !(r1 = o1.n()).done;){
                                var s1 = r1.value;
                                if (!s1.isVirtual) for(var a1 = s1.path.split("."), u1 = 0; u1 < a1.length - 1; ++u1){
                                    var c1 = a1.slice(0, u1 + 1).join("."), l1 = a1.slice(u1 + 1).join("."), f1 = t1.get(c1);
                                    if (null != f1 && f1.isMongooseDocumentArray) {
                                        for(var p1 = 0; p1 < f1.length; ++p1)f1[p1].populated(l1, null == s1._docs[n1] ? [] : s1._docs[n1][p1], s1);
                                        break;
                                    }
                                }
                            }
                        } catch (t1) {
                            o1.e(t1);
                        } finally{
                            o1.f();
                        }
                    }(this, e1.populated), this.emit("init", this), this.constructor.emit("init", this), this.$__._id = this._id, this;
                }, tt1.prototype.update = function() {
                    var t1 = I1.args(arguments);
                    t1.unshift({
                        _id: this._id
                    });
                    var e1 = this.constructor.update.apply(this.constructor, t1);
                    return null != this.$session() && ("session" in e1.options || (e1.options.session = this.$session())), e1;
                }, tt1.prototype.updateOne = function(t1, e1, r1) {
                    var n1 = this, o1 = this.constructor.updateOne({
                        _id: this._id
                    }, t1, e1);
                    return o1._pre(function(t1) {
                        n1.constructor._middleware.execPre("updateOne", n1, [
                            n1
                        ], t1);
                    }), o1._post(function(t1) {
                        n1.constructor._middleware.execPost("updateOne", n1, [
                            n1
                        ], {}, t1);
                    }), null != this.$session() && ("session" in o1.options || (o1.options.session = this.$session())), null != r1 ? o1.exec(r1) : o1;
                }, tt1.prototype.replaceOne = function() {
                    var t1 = I1.args(arguments);
                    return t1.unshift({
                        _id: this._id
                    }), this.constructor.replaceOne.apply(this.constructor, t1);
                }, tt1.prototype.$session = function(t1) {
                    if (0 === arguments.length) return this.$__.session;
                    if (this.$__.session = t1, !this.ownerDocument) {
                        var e1, r1 = this.$__getAllSubdocs(), n1 = i1(r1);
                        try {
                            for(n1.s(); !(e1 = n1.n()).done;){
                                var o1 = e1.value;
                                o1.$session(t1);
                            }
                        } catch (t1) {
                            n1.e(t1);
                        } finally{
                            n1.f();
                        }
                    }
                    return t1;
                }, tt1.prototype.overwrite = function(t1) {
                    for(var e1 = 0, r1 = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(t1)))); e1 < r1.length; e1++){
                        var n1 = r1[e1];
                        "_id" !== n1 && (this.schema.options.versionKey && n1 === this.schema.options.versionKey || this.schema.options.discriminatorKey && n1 === this.schema.options.discriminatorKey || this.$set(n1, t1[n1]));
                    }
                    return this;
                }, tt1.prototype.$set = function(t1, e1, r1, n1) {
                    var s1 = this;
                    I1.isPOJO(r1) && (n1 = r1, r1 = void 0);
                    var u1, c1, l1, f1, p1 = (n1 = n1 || {}).merge, m1 = r1 && !0 !== r1, _1 = !0 === r1, v1 = 0, b1 = "strict" in n1 ? n1.strict : this.$__.strictMode;
                    if (m1 && ((this.$__.adhocPaths || (this.$__.adhocPaths = {}))[t1] = this.schema.interpretAsType(t1, r1, this.schema.options)), null == t1) {
                        var w1 = t1;
                        t1 = e1, e1 = w1;
                    } else {
                        if ("string" != typeof t1) {
                            t1 instanceof tt1 && (t1 = t1.$__isNested ? t1.toObject() : t1._doc), f1 = e1 ? e1 + "." : "";
                            var O1 = (u1 = Object.keys(t1)).length, S1 = P1(n1, "_skipMinimizeTopLevel", !1);
                            if (0 === O1 && S1) return delete n1._skipMinimizeTopLevel, e1 && this.$set(e1, {}), this;
                            for(var j1 = 0; j1 < O1; ++j1){
                                var E1 = f1 + (l1 = u1[j1]);
                                if (c1 = this.schema.pathType(E1), !0 !== r1 || f1 || null == t1[l1] || "nested" !== c1 || null == this._doc[l1] || 0 !== Object.keys(this._doc[l1]).length || (delete this._doc[l1], n1 = Object.assign({}, n1, {
                                    _skipMinimizeTopLevel: !0
                                })), !("object" !== a1(t1[l1]) || I1.isNativeObject(t1[l1]) || I1.isMongooseType(t1[l1]) || null == t1[l1] || "virtual" === c1 || "real" === c1 || "adhocOrUndefined" === c1 || this.$__path(E1) instanceof y1 || this.schema.paths[E1] && this.schema.paths[E1].options && this.schema.paths[E1].options.ref)) this.$__.$setCalled.add(f1 + l1), this.$set(t1[l1], f1 + l1, _1, n1);
                                else if (b1) {
                                    if (_1 && void 0 === t1[l1] && void 0 !== this.get(E1)) continue;
                                    if ("adhocOrUndefined" === c1 && (c1 = x1(this, E1, {
                                        typeOnly: !0
                                    })), "real" === c1 || "virtual" === c1) {
                                        var $1 = t1[l1];
                                        this.schema.paths[E1] && this.schema.paths[E1].$isSingleNested && t1[l1] instanceof tt1 && ($1 = $1.toObject({
                                            virtuals: !1,
                                            transform: !1
                                        })), this.$set(f1 + l1, $1, _1, n1);
                                    } else if ("nested" === c1 && t1[l1] instanceof tt1) this.$set(f1 + l1, t1[l1].toObject({
                                        transform: !1
                                    }), _1, n1);
                                    else if ("throw" === b1) throw "nested" === c1 ? new d1(l1, t1[l1]) : new g1(l1);
                                } else void 0 !== t1[l1] && this.$set(f1 + l1, t1[l1], _1, n1);
                            }
                            return this;
                        }
                        this.$__.$setCalled.add(t1);
                    }
                    var T1, k1 = this.schema.pathType(t1);
                    if ("adhocOrUndefined" === k1 && (k1 = x1(this, t1, {
                        typeOnly: !0
                    })), e1 = N1(e1), "nested" === k1 && e1) {
                        if ("object" === a1(e1) && null != e1) {
                            if (p1) return this.$set(e1, t1, _1);
                            this.$__setValue(t1, null), A1(this, t1);
                            var C1 = Object.keys(e1);
                            this.$__setValue(t1, {});
                            for(var D1 = 0, R1 = C1; D1 < R1.length; D1++){
                                var M1 = R1[D1];
                                this.$set(t1 + "." + M1, e1[M1], _1);
                            }
                            return this.markModified(t1), A1(this, t1, {
                                skipDocArrays: !0
                            }), this;
                        }
                        return this.invalidate(t1, new h1.CastError("Object", e1, t1)), this;
                    }
                    var F1 = -1 === t1.indexOf(".") ? [
                        t1
                    ] : t1.split(".");
                    if ("string" == typeof this.schema.aliases[F1[0]] && (F1[0] = this.schema.aliases[F1[0]]), "adhocOrUndefined" === k1 && b1) {
                        var L1;
                        for(v1 = 0; v1 < F1.length; ++v1){
                            var U1 = F1.slice(0, v1 + 1).join(".");
                            if (v1 + 1 < F1.length && "virtual" === this.schema.pathType(U1)) return B1.set(t1, e1, this), this;
                            if (null != (T1 = this.schema.path(U1)) && T1 instanceof y1) {
                                L1 = !0;
                                break;
                            }
                        }
                        if (null == T1 && (T1 = x1(this, t1)), !L1 && !T1) {
                            if ("throw" === b1) throw new g1(t1);
                            return this;
                        }
                    } else {
                        if ("virtual" === k1) return (T1 = this.schema.virtualpath(t1)).applySetters(e1, this), this;
                        T1 = this.$__path(t1);
                    }
                    var V1, q1 = this._doc, W1 = "";
                    for(v1 = 0; v1 < F1.length - 1; ++v1)q1 = q1[F1[v1]], W1 += (W1.length > 0 ? "." : "") + F1[v1], q1 || (this.$set(W1, {}), this.isSelected(W1) || this.unmarkModified(W1), q1 = this.$__getValue(W1));
                    if (F1.length <= 1) V1 = t1;
                    else {
                        for(v1 = 0; v1 < F1.length; ++v1){
                            var H1 = F1.slice(0, v1 + 1).join(".");
                            if (null === this.get(H1, null, {
                                getters: !1
                            })) {
                                V1 = H1;
                                break;
                            }
                        }
                        V1 || (V1 = t1);
                    }
                    var Y1 = null != s1.$__.$options.priorDoc ? s1.$__.$options.priorDoc.$__getValue(t1) : _1 ? void 0 : s1.$__getValue(t1);
                    if (!T1) return this.$__set(V1, t1, _1, F1, T1, e1, Y1), this;
                    if ((T1.$isSingleNested || T1.$isMongooseArray) && /*!
 * ignore
 */ function(t1, e1) {
                        if (!t1.$__.validationError) return;
                        for(var r1 = Object.keys(t1.$__.validationError.errors), n1 = 0, o1 = r1; n1 < o1.length; n1++){
                            var i1 = o1[n1];
                            i1.startsWith(e1 + ".") && delete t1.$__.validationError.errors[i1];
                        }
                        0 === Object.keys(t1.$__.validationError.errors).length && (t1.$__.validationError = null);
                    }(this, t1), T1.$isSingleNested && null != e1 && p1) {
                        e1 instanceof tt1 && (e1 = e1.toObject({
                            virtuals: !1,
                            transform: !1
                        }));
                        for(var K1 = 0, z1 = Object.keys(e1); K1 < z1.length; K1++){
                            var Q1 = z1[K1];
                            this.$set(t1 + "." + Q1, e1[Q1], _1, n1);
                        }
                        return this;
                    }
                    var J1 = !0;
                    try {
                        var X1, Z1 = function() {
                            if (null == T1.options) return !1;
                            if (!(e1 instanceof tt1)) return !1;
                            var t1 = e1.constructor, r1 = T1.options.ref;
                            if (null != r1 && (r1 === t1.modelName || r1 === t1.baseModelName)) return !0;
                            var n1 = T1.options.refPath;
                            if (null == n1) return !1;
                            var o1 = e1.get(n1);
                            return o1 === t1.modelName || o1 === t1.baseModelName;
                        }(), et1 = !1;
                        if (Z1 && e1 instanceof tt1 && (this.populated(t1, e1._id, o1({}, G1, e1.constructor)), et1 = !0), T1.options && Array.isArray(T1.options[this.schema.options.typeKey]) && T1.options[this.schema.options.typeKey].length && T1.options[this.schema.options.typeKey][0].ref && /*!
 * ignore
 */ function(t1, e1) {
                            if (!Array.isArray(t1)) return !1;
                            if (0 === t1.length) return !1;
                            var r1, n1 = i1(t1);
                            try {
                                for(n1.s(); !(r1 = n1.n()).done;){
                                    var o1 = r1.value;
                                    if (!(o1 instanceof tt1)) return !1;
                                    if (null == o1.constructor.modelName) return !1;
                                    if (o1.constructor.modelName != e1 && o1.constructor.baseModelName != e1) return !1;
                                }
                            } catch (t1) {
                                n1.e(t1);
                            } finally{
                                n1.f();
                            }
                            return !0;
                        }(e1, T1.options[this.schema.options.typeKey][0].ref) && (this.ownerDocument ? (X1 = o1({}, G1, e1[0].constructor), this.ownerDocument().populated(this.$__fullPath(t1), e1.map(function(t1) {
                            return t1._id;
                        }), X1)) : (X1 = o1({}, G1, e1[0].constructor), this.populated(t1, e1.map(function(t1) {
                            return t1._id;
                        }), X1)), et1 = !0), null == this.schema.singleNestedPaths[t1] && (e1 = T1.applySetters(e1, this, !1, Y1)), T1.$isMongooseDocumentArray && Array.isArray(e1) && e1.length > 0 && null != e1[0] && null != e1[0].$__ && null != e1[0].$__.populated) {
                            for(var rt1 = Object.keys(e1[0].$__.populated), nt1 = function() {
                                var r1 = it1[ot1];
                                s1.populated(t1 + "." + r1, e1.map(function(t1) {
                                    return t1.populated(r1);
                                }), e1[0].$__.populated[r1].options);
                            }, ot1 = 0, it1 = rt1; ot1 < it1.length; ot1++)nt1();
                            et1 = !0;
                        }
                        if (!et1 && this.$__.populated) {
                            if (Array.isArray(e1) && this.$__.populated[t1]) for(var st1 = 0; st1 < e1.length; ++st1)e1[st1] instanceof tt1 && (e1[st1] = e1[st1]._id);
                            delete this.$__.populated[t1];
                        }
                        T1.$isSingleNested && null != e1 && function(t1, e1, r1) {
                            var n1 = e1.schema;
                            if (null == n1) return;
                            for(var o1 = 0, i1 = Object.keys(n1.paths); o1 < i1.length; o1++){
                                var s1 = i1[o1], a1 = n1.paths[s1];
                                if (null != a1.$immutableSetter) {
                                    var u1 = null == r1 ? void 0 : r1.$__getValue(s1);
                                    a1.$immutableSetter.call(t1, u1);
                                }
                            }
                        }(e1, T1, Y1), this.$markValid(t1);
                    } catch (r1) {
                        r1 instanceof h1.StrictModeError && r1.isImmutableError ? this.invalidate(t1, r1) : r1 instanceof h1.CastError ? (this.invalidate(r1.path, r1), r1.$originalErrorPath && this.invalidate(t1, new h1.CastError(T1.instance, e1, t1, r1.$originalErrorPath))) : this.invalidate(t1, new h1.CastError(T1.instance, e1, t1, r1)), J1 = !1;
                    }
                    return J1 && this.$__set(V1, t1, _1, F1, T1, e1, Y1), T1.$isSingleNested && (this.isDirectModified(t1) || null == e1) && A1(this, t1), this;
                }, tt1.prototype.set = tt1.prototype.$set, tt1.prototype.$__shouldModify = function(t1, e1, r1, n1, o1, i1, s1) {
                    return !!this.isNew || null == this.schema.singleNestedPaths[e1] && (void 0 === i1 && !this.isSelected(e1) || (void 0 !== i1 || !(e1 in this.$__.activePaths.states.default)) && !(this.populated(e1) && i1 instanceof tt1 && U1(i1._id, s1)) && (!U1(i1, s1 || I1.getValue(e1, this)) || !(r1 || null == i1 || !(e1 in this.$__.activePaths.states.default) || !U1(i1, o1.getDefault(this, r1)))));
                }, tt1.prototype.$__set = function(t1, e1, n1, o1, i1, s1, a1) {
                    l1 = l1 || r1(26);
                    var u1 = this.$__shouldModify(t1, e1, n1, o1, i1, s1, a1), f1 = this;
                    u1 && (this.markModified(t1), c1 || (c1 = r1(82)), s1 && s1.isMongooseArray && (s1._registerAtomic("$set", s1), s1.isMongooseDocumentArray && s1.forEach(function(t1) {
                        t1 && t1.__parentArray && (t1.__parentArray = s1);
                    }), this.$__.activePaths.forEach(function(t1) {
                        t1.startsWith(e1 + ".") && f1.$__.activePaths.ignore(t1);
                    })));
                    for(var p1 = this._doc, h1 = 0, y1 = o1.length, d1 = ""; h1 < y1; h1++){
                        var m1 = h1 + 1 === y1;
                        if (d1 += d1 ? "." + o1[h1] : o1[h1], Z1.has(o1[h1])) return;
                        m1 ? p1 instanceof Map ? p1.set(o1[h1], s1) : p1[o1[h1]] = s1 : (I1.isPOJO(p1[o1[h1]]) || p1[o1[h1]] && p1[o1[h1]] instanceof l1 || p1[o1[h1]] && p1[o1[h1]].$isSingleNested || p1[o1[h1]] && Array.isArray(p1[o1[h1]]) || (p1[o1[h1]] = p1[o1[h1]] || {}), p1 = p1[o1[h1]]);
                    }
                }, tt1.prototype.$__getValue = function(t1) {
                    return I1.getValue(t1, this._doc);
                }, tt1.prototype.$__setValue = function(t1, e1) {
                    return I1.setValue(t1, e1, this._doc), this;
                }, tt1.prototype.get = function(t1, e1, r1) {
                    var n1;
                    r1 = r1 || {}, e1 && (n1 = this.schema.interpretAsType(t1, e1, this.schema.options));
                    var o1 = this.$__path(t1);
                    if (null == o1 && (o1 = this.schema.virtualpath(t1)), o1 instanceof y1) {
                        var i1 = this.schema.virtualpath(t1);
                        null != i1 && (o1 = i1);
                    }
                    var s1 = t1.split("."), a1 = this._doc;
                    if (o1 instanceof O1) {
                        if (0 === o1.getters.length) return;
                        return o1.applyGetters(null, this);
                    }
                    "string" == typeof this.schema.aliases[s1[0]] && (s1[0] = this.schema.aliases[s1[0]]);
                    for(var u1 = 0, c1 = s1.length; u1 < c1; u1++)a1 && a1._doc && (a1 = a1._doc), a1 = null == a1 ? void 0 : a1 instanceof Map ? a1.get(s1[u1], {
                        getters: !1
                    }) : u1 === c1 - 1 ? I1.getValue(s1[u1], a1) : a1[s1[u1]];
                    if (n1 && (a1 = n1.cast(a1)), null != o1 && !1 !== r1.getters) a1 = o1.applyGetters(a1, this);
                    else if (this.schema.nested[t1] && r1.virtuals) return ut1(this, I1.clone(a1) || {}, {
                        path: t1
                    });
                    return a1;
                }, /*!
 * ignore
 */ tt1.prototype[J1] = tt1.prototype.get, tt1.prototype.$__path = function(t1) {
                    var e1 = this.$__.adhocPaths, r1 = e1 && e1.hasOwnProperty(t1) ? e1[t1] : null;
                    return r1 || this.schema.path(t1);
                }, tt1.prototype.markModified = function(t1, e1) {
                    this.$__.activePaths.modify(t1), null == e1 || this.ownerDocument || (this.$__.pathsToScopes[t1] = e1);
                }, tt1.prototype.unmarkModified = function(t1) {
                    this.$__.activePaths.init(t1), delete this.$__.pathsToScopes[t1];
                }, tt1.prototype.$ignore = function(t1) {
                    this.$__.activePaths.ignore(t1);
                }, tt1.prototype.directModifiedPaths = function() {
                    return Object.keys(this.$__.activePaths.states.modify);
                }, tt1.prototype.$isEmpty = function(t1) {
                    var e1 = {
                        minimize: !0,
                        virtuals: !1,
                        getters: !1,
                        transform: !1
                    };
                    if (arguments.length > 0) {
                        var r1 = this.get(t1);
                        return null == r1 || "object" === a1(r1) && (I1.isPOJO(r1) ? ot1(r1) : 0 === Object.keys(r1.toObject(e1)).length);
                    }
                    return 0 === Object.keys(this.toObject(e1)).length;
                }, tt1.prototype.modifiedPaths = function(t1) {
                    t1 = t1 || {};
                    var e1 = Object.keys(this.$__.activePaths.states.modify), r1 = this;
                    return e1.reduce(function(e1, n1) {
                        var o1 = n1.split(".");
                        if (e1 = e1.concat(o1.reduce(function(t1, e1, r1) {
                            return t1.concat(o1.slice(0, r1).concat(e1).join("."));
                        }, []).filter(function(t1) {
                            return -1 === e1.indexOf(t1);
                        })), !t1.includeChildren) return e1;
                        var s1 = r1.get(n1);
                        if (null != s1 && "object" === a1(s1)) {
                            if (s1._doc && (s1 = s1._doc), Array.isArray(s1)) {
                                for(var u1 = s1.length, c1 = 0; c1 < u1; ++c1)if (-1 === e1.indexOf(n1 + "." + c1) && (e1.push(n1 + "." + c1), null != s1[c1] && s1[c1].$__)) {
                                    var l1, f1 = i1(s1[c1].modifiedPaths());
                                    try {
                                        for(f1.s(); !(l1 = f1.n()).done;){
                                            var p1 = l1.value;
                                            e1.push(n1 + "." + c1 + "." + p1);
                                        }
                                    } catch (t1) {
                                        f1.e(t1);
                                    } finally{
                                        f1.f();
                                    }
                                }
                            } else Object.keys(s1).filter(function(t1) {
                                return -1 === e1.indexOf(n1 + "." + t1);
                            }).forEach(function(t1) {
                                e1.push(n1 + "." + t1);
                            });
                        }
                        return e1;
                    }, []);
                }, tt1.prototype[z1] = tt1.prototype.modifiedPaths, tt1.prototype.isModified = function(t1, e1) {
                    if (t1) {
                        Array.isArray(t1) || (t1 = t1.split(" "));
                        var r1 = e1 || this[z1](), n1 = Object.keys(this.$__.activePaths.states.modify);
                        return t1.some(function(t1) {
                            return !!~r1.indexOf(t1);
                        }) || t1.some(function(t1) {
                            return n1.some(function(e1) {
                                return e1 === t1 || t1.startsWith(e1 + ".");
                            });
                        });
                    }
                    return this.$__.activePaths.some("modify");
                }, tt1.prototype[K1] = tt1.prototype.isModified, tt1.prototype.$isDefault = function(t1) {
                    return t1 in this.$__.activePaths.states.default;
                }, tt1.prototype.$isDeleted = function(t1) {
                    return 0 === arguments.length ? !!this.$__.isDeleted : (this.$__.isDeleted = !!t1, this);
                }, tt1.prototype.isDirectModified = function(t1) {
                    return t1 in this.$__.activePaths.states.modify;
                }, tt1.prototype.isInit = function(t1) {
                    return t1 in this.$__.activePaths.states.init;
                }, tt1.prototype.isSelected = function(t1) {
                    if (this.$__.selected) {
                        if ("_id" === t1) return 0 !== this.$__.selected._id;
                        var e1, r1 = Object.keys(this.$__.selected), n1 = r1.length, o1 = null;
                        if (1 === n1 && "_id" === r1[0]) return 0 === this.$__.selected._id;
                        for(; n1--;)if ("_id" !== (e1 = r1[n1]) && k1(this.$__.selected[e1])) {
                            o1 = !!this.$__.selected[e1];
                            break;
                        }
                        if (null === o1) return !0;
                        if (t1 in this.$__.selected) return o1;
                        n1 = r1.length;
                        for(var i1 = t1 + "."; n1--;)if ("_id" !== (e1 = r1[n1])) {
                            if (e1.startsWith(i1)) return o1 || e1 !== i1;
                            if (i1.startsWith(e1 + ".")) return o1;
                        }
                        return !o1;
                    }
                    return !0;
                }, tt1.prototype[Y1] = tt1.prototype.isSelected, tt1.prototype.isDirectSelected = function(t1) {
                    if (this.$__.selected) {
                        if ("_id" === t1) return 0 !== this.$__.selected._id;
                        var e1, r1 = Object.keys(this.$__.selected), n1 = r1.length, o1 = null;
                        if (1 === n1 && "_id" === r1[0]) return 0 === this.$__.selected._id;
                        for(; n1--;)if ("_id" !== (e1 = r1[n1]) && k1(this.$__.selected[e1])) {
                            o1 = !!this.$__.selected[e1];
                            break;
                        }
                        return null === o1 || (t1 in this.$__.selected ? o1 : !o1);
                    }
                    return !0;
                }, tt1.prototype.validate = function(t1, e1, r1) {
                    var n1, o1 = this;
                    return this.$op = "validate", null != this.ownerDocument || (this.$__.validating ? n1 = new _1(this, {
                        parentStack: e1 && e1.parentStack,
                        conflictStack: this.$__.validating.stack
                    }) : this.$__.validating = new _1(this, {
                        parentStack: e1 && e1.parentStack
                    })), "function" == typeof t1 ? (r1 = t1, e1 = null, t1 = null) : "function" == typeof e1 && (r1 = e1, e1 = t1, t1 = null), S1(r1, function(r1) {
                        if (null != n1) return r1(n1);
                        o1.$__validate(t1, e1, function(t1) {
                            o1.$op = null, r1(t1);
                        });
                    }, this.constructor.events);
                }, tt1.prototype.$__validate = function(t1, r1, n1) {
                    var o1 = this;
                    "function" == typeof t1 ? (n1 = t1, r1 = null, t1 = null) : "function" == typeof r1 && (n1 = r1, r1 = null);
                    var i1, s1 = r1 && "object" === a1(r1) && "validateModifiedOnly" in r1;
                    i1 = s1 ? !!r1.validateModifiedOnly : this.schema.options.validateModifiedOnly;
                    var u1 = this, c1 = function() {
                        var t1 = o1.$__.validationError;
                        if (o1.$__.validationError = void 0, i1 && null != t1) {
                            for(var e1 = 0, r1 = Object.keys(t1.errors); e1 < r1.length; e1++){
                                var n1 = r1[e1];
                                o1.isModified(n1) || delete t1.errors[n1];
                            }
                            0 === Object.keys(t1.errors).length && (t1 = void 0);
                        }
                        if (o1.$__.cachedRequired = {}, o1.emit("validate", u1), o1.constructor.emit("validate", u1), o1.$__.validating = null, t1) {
                            for(var s1 in t1.errors)!o1[H1] && t1.errors[s1] instanceof h1.CastError && o1.invalidate(s1, t1.errors[s1]);
                            return t1;
                        }
                    }, l1 = it1(this), f1 = i1 ? l1[0].filter(function(t1) {
                        return o1.isModified(t1);
                    }) : l1[0], p1 = l1[1];
                    if (Array.isArray(t1) && (f1 = st1(f1, t1)), 0 === f1.length) return e1.nextTick(function() {
                        var t1 = c1();
                        if (t1) return u1.schema.s.hooks.execPost("validate:error", u1, [
                            u1
                        ], {
                            error: t1
                        }, function(t1) {
                            n1(t1);
                        });
                        n1(null, u1);
                    });
                    for(var y1 = {}, d1 = 0, m1 = function() {
                        var t1 = c1();
                        if (t1) return u1.schema.s.hooks.execPost("validate:error", u1, [
                            u1
                        ], {
                            error: t1
                        }, function(t1) {
                            n1(t1);
                        });
                        n1(null, u1);
                    }, _1 = function(t1) {
                        null == t1 || y1[t1] || (y1[t1] = !0, d1++, e1.nextTick(function() {
                            var e1 = u1.schema.path(t1);
                            if (!e1) return --d1 || m1();
                            if (u1.$isValid(t1)) {
                                var r1, n1 = u1.$__getValue(t1);
                                null == n1 && (r1 = u1.populated(t1)) && (n1 = r1);
                                var o1 = (t1 in u1.$__.pathsToScopes) ? u1.$__.pathsToScopes[t1] : u1, i1 = {
                                    skipSchemaValidators: p1[t1],
                                    path: t1
                                };
                                e1.doValidate(n1, function(r1) {
                                    if (r1 && (!e1.$isMongooseDocumentArray || r1.$isArrayValidatorError)) {
                                        if (e1.$isSingleNested && r1 instanceof b1 && !1 === e1.schema.options.storeSubdocValidationError) return --d1 || m1();
                                        u1.invalidate(t1, r1, void 0, !0);
                                    }
                                    --d1 || m1();
                                }, o1, i1);
                            } else --d1 || m1();
                        }));
                    }, v1 = f1.length, g1 = 0; g1 < v1; ++g1)_1(f1[g1]);
                }, tt1.prototype.validateSync = function(t1, e1) {
                    var r1, n1 = this, o1 = this;
                    r1 = e1 && "object" === a1(e1) && "validateModifiedOnly" in e1 ? !!e1.validateModifiedOnly : this.schema.options.validateModifiedOnly, "string" == typeof t1 && (t1 = t1.split(" "));
                    var i1 = it1(this), s1 = r1 ? i1[0].filter(function(t1) {
                        return n1.isModified(t1);
                    }) : i1[0], u1 = i1[1];
                    Array.isArray(t1) && (s1 = st1(s1, t1));
                    var c1 = {};
                    s1.forEach(function(t1) {
                        if (!c1[t1]) {
                            c1[t1] = !0;
                            var e1 = o1.schema.path(t1);
                            if (e1 && o1.$isValid(t1)) {
                                var r1 = o1.$__getValue(t1), n1 = e1.doValidateSync(r1, o1, {
                                    skipSchemaValidators: u1[t1],
                                    path: t1
                                });
                                if (n1 && (!e1.$isMongooseDocumentArray || n1.$isArrayValidatorError)) {
                                    if (e1.$isSingleNested && n1 instanceof b1 && !1 === e1.schema.options.storeSubdocValidationError) return;
                                    o1.invalidate(t1, n1, void 0, !0);
                                }
                            }
                        }
                    });
                    var l1 = o1.$__.validationError;
                    if (o1.$__.validationError = void 0, o1.emit("validate", o1), o1.constructor.emit("validate", o1), l1) for(var f1 in l1.errors)l1.errors[f1] instanceof h1.CastError && o1.invalidate(f1, l1.errors[f1]);
                    return l1;
                }, tt1.prototype.invalidate = function(t1, e1, r1, n1) {
                    if (this.$__.validationError || (this.$__.validationError = new b1(this)), !this.$__.validationError.errors[t1]) return e1 && "string" != typeof e1 || (e1 = new w1({
                        path: t1,
                        message: e1,
                        type: n1 || "user defined",
                        value: r1
                    })), this.$__.validationError === e1 || this.$__.validationError.addError(t1, e1), this.$__.validationError;
                }, tt1.prototype.$markValid = function(t1) {
                    this.$__.validationError && this.$__.validationError.errors[t1] && (delete this.$__.validationError.errors[t1], 0 === Object.keys(this.$__.validationError.errors).length && (this.$__.validationError = null));
                }, tt1.prototype.$isValid = function(t1) {
                    return !this.$__.validationError || !this.$__.validationError.errors[t1];
                }, tt1.prototype.$__reset = function() {
                    var t1 = this;
                    return u1 || (u1 = r1(18)), this.$__.activePaths.map("init", "modify", function(e1) {
                        return t1.$__getValue(e1);
                    }).filter(function(t1) {
                        return t1 && t1 instanceof Array && t1.isMongooseDocumentArray && t1.length;
                    }).forEach(function(e1) {
                        for(var r1 = e1.length; r1--;){
                            var n1 = e1[r1];
                            n1 && n1.$__reset();
                        }
                        t1.$__.activePaths.init(e1.$path()), e1[q1] = e1[W1], e1[W1] = {};
                    }), this.$__.activePaths.map("init", "modify", function(e1) {
                        return t1.$__getValue(e1);
                    }).filter(function(t1) {
                        return t1 && t1.$isSingleNested;
                    }).forEach(function(e1) {
                        e1.$__reset(), t1.$__.activePaths.init(e1.$basePath);
                    }), this.$__dirty().forEach(function(t1) {
                        var e1 = t1.value;
                        e1 && e1[W1] && (e1[q1] = e1[W1], e1[W1] = {});
                    }), this.$__.backup = {}, this.$__.backup.activePaths = {
                        modify: Object.assign({}, this.$__.activePaths.states.modify),
                        default: Object.assign({}, this.$__.activePaths.states.default)
                    }, this.$__.backup.validationError = this.$__.validationError, this.$__.backup.errors = this.errors, this.$__.activePaths.clear("modify"), this.$__.activePaths.clear("default"), this.$__.validationError = void 0, this.errors = void 0, t1 = this, this.schema.requiredPaths().forEach(function(e1) {
                        t1.$__.activePaths.require(e1);
                    }), this;
                }, /*!
 * ignore
 */ tt1.prototype.$__undoReset = function() {
                    if (null != this.$__.backup && null != this.$__.backup.activePaths) {
                        this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify, this.$__.activePaths.states.default = this.$__.backup.activePaths.default, this.$__.validationError = this.$__.backup.validationError, this.errors = this.$__.backup.errors;
                        var t1, e1 = i1(this.$__dirty());
                        try {
                            for(e1.s(); !(t1 = e1.n()).done;){
                                var r1 = t1.value.value;
                                r1 && r1[W1] && r1[q1] && (r1[W1] = r1[q1]);
                            }
                        } catch (t1) {
                            e1.e(t1);
                        } finally{
                            e1.f();
                        }
                        var n1, o1 = i1(this.$__getAllSubdocs());
                        try {
                            for(o1.s(); !(n1 = o1.n()).done;)n1.value.$__undoReset();
                        } catch (t1) {
                            o1.e(t1);
                        } finally{
                            o1.f();
                        }
                    }
                }, tt1.prototype.$__dirty = function() {
                    var t1 = this, e1 = this.$__.activePaths.map("modify", function(e1) {
                        return {
                            path: e1,
                            value: t1.$__getValue(e1),
                            schema: t1.$__path(e1)
                        };
                    });
                    (e1 = e1.concat(this.$__.activePaths.map("default", function(e1) {
                        if ("_id" !== e1 && null != t1.$__getValue(e1)) return {
                            path: e1,
                            value: t1.$__getValue(e1),
                            schema: t1.$__path(e1)
                        };
                    }))).sort(function(t1, e1) {
                        return t1.path < e1.path ? -1 : t1.path > e1.path ? 1 : 0;
                    });
                    var r1, n1, o1 = [];
                    return e1.forEach(function(t1) {
                        t1 && (null == r1 || 0 !== t1.path.indexOf(r1) ? (r1 = t1.path + ".", o1.push(t1), n1 = t1) : null != n1 && null != n1.value && null != n1.value[W1] && n1.value.hasAtomics() && (n1.value[W1] = {}, n1.value[W1].$set = n1.value));
                    }), n1 = r1 = null, o1;
                }, tt1.prototype.$__setSchema = function(t1) {
                    t1.plugin(T1, {
                        deduplicate: !0
                    }), j1(t1.tree, this, void 0, t1.options);
                    for(var e1 = 0, r1 = Object.keys(t1.virtuals); e1 < r1.length; e1++){
                        var n1 = r1[e1];
                        t1.virtuals[n1]._applyDefaultGetters();
                    }
                    this.schema = t1, this[Q1] = t1;
                }, tt1.prototype.$__getArrayPathsToValidate = function() {
                    return u1 || (u1 = r1(18)), this.$__.activePaths.map("init", "modify", (function(t1) {
                        return this.$__getValue(t1);
                    }).bind(this)).filter(function(t1) {
                        return t1 && t1 instanceof Array && t1.isMongooseDocumentArray && t1.length;
                    }).reduce(function(t1, e1) {
                        return t1.concat(e1);
                    }, []).filter(function(t1) {
                        return t1;
                    });
                }, tt1.prototype.$__getAllSubdocs = function() {
                    u1 || (u1 = r1(18)), l1 = l1 || r1(26);
                    var t1 = this;
                    return Object.keys(this._doc).reduce(function(e1, r1) {
                        return function t1(e1, r1, n1) {
                            var o1 = e1;
                            return n1 && (o1 = e1 instanceof tt1 && e1[Q1].paths[n1] ? e1._doc[n1] : e1[n1]), o1 instanceof l1 ? r1.push(o1) : o1 instanceof Map ? r1 = Array.from(o1.keys()).reduce(function(e1, r1) {
                                return t1(o1.get(r1), e1, null);
                            }, r1) : o1 && o1.$isSingleNested ? (r1 = Object.keys(o1._doc).reduce(function(e1, r1) {
                                return t1(o1._doc, e1, r1);
                            }, r1)).push(o1) : o1 && o1.isMongooseDocumentArray ? o1.forEach(function(e1) {
                                e1 && e1._doc && (r1 = Object.keys(e1._doc).reduce(function(r1, n1) {
                                    return t1(e1._doc, r1, n1);
                                }, r1), e1 instanceof l1 && r1.push(e1));
                            }) : o1 instanceof tt1 && o1.$__isNested && (r1 = Object.keys(o1).reduce(function(e1, r1) {
                                return t1(o1, e1, r1);
                            }, r1)), r1;
                        }(t1, e1, r1);
                    }, []);
                }, tt1.prototype.$__handleReject = function(t1) {
                    this.listeners("error").length ? this.emit("error", t1) : this.constructor.listeners && this.constructor.listeners("error").length && this.constructor.emit("error", t1);
                }, tt1.prototype.$toObject = function(t1, e1) {
                    var r1, o1 = {
                        transform: !0,
                        flattenDecimals: !0
                    }, i1 = e1 ? "toJSON" : "toObject", s1 = P1(this, "constructor.base.options." + i1, {}), a1 = P1(this, "schema.options", {});
                    o1 = I1.options(o1, L1(s1)), o1 = I1.options(o1, L1(a1[i1] || {})), (t1 = I1.isPOJO(t1) ? L1(t1) : {})._calledWithOptions = t1._calledWithOptions || L1(t1), "flattenMaps" in t1 || (t1.flattenMaps = o1.flattenMaps), r1 = null != t1._calledWithOptions.minimize ? t1.minimize : null != o1.minimize ? o1.minimize : a1.minimize;
                    var u1 = Object.assign(I1.clone(t1), {
                        _isNested: !0,
                        json: e1,
                        minimize: r1
                    });
                    if (I1.hasUserDefinedProperty(t1, "getters") && (u1.getters = t1.getters), I1.hasUserDefinedProperty(t1, "virtuals") && (u1.virtuals = t1.virtuals), (t1.depopulate || P1(t1, "_parentOptions.depopulate", !1)) && t1._isNested && this.$__.wasPopulated) return L1(this._id, u1);
                    (t1 = I1.options(o1, t1))._isNested = !0, t1.json = e1, t1.minimize = r1, u1._parentOptions = t1, u1._skipSingleNestedGetters = !0;
                    var c1 = Object.assign({}, u1);
                    c1._skipSingleNestedGetters = !1;
                    var l1 = t1.transform, f1 = L1(this._doc, u1) || {};
                    t1.getters && (!function(t1, e1, r1) {
                        var n1, o1, i1 = t1.schema, s1 = Object.keys(i1.paths), a1 = s1.length, u1 = t1._doc;
                        if (!u1) return e1;
                        for(; a1--;){
                            var c1 = (n1 = s1[a1]).split("."), l1 = c1.length, f1 = l1 - 1, p1 = e1, h1 = void 0;
                            if (u1 = t1._doc, t1.isSelected(n1)) for(var y1 = 0; y1 < l1; ++y1){
                                if (h1 = c1[y1], o1 = u1[h1], y1 === f1) {
                                    var d1 = t1.get(n1);
                                    p1[h1] = L1(d1, r1);
                                } else {
                                    if (null == o1) {
                                        h1 in u1 && (p1[h1] = o1);
                                        break;
                                    }
                                    p1 = p1[h1] || (p1[h1] = {});
                                }
                                u1 = o1;
                            }
                        }
                    }(this, f1, c1), t1.minimize && (f1 = /*!
 * Minimizes an object, removing undefined values and empty objects
 *
 * @param {Object} object to minimize
 * @return {Object}
 */ function t1(e1) {
                        var r1, o1, i1, s1 = Object.keys(e1), a1 = s1.length;
                        for(; a1--;)o1 = s1[a1], i1 = e1[o1], I1.isObject(i1) && !n1.isBuffer(i1) && (e1[o1] = t1(i1)), void 0 !== e1[o1] ? r1 = !0 : delete e1[o1];
                        return r1 ? e1 : void 0;
                    }(f1) || {})), (t1.virtuals || t1.getters && !1 !== t1.virtuals) && ut1(this, f1, c1, t1), !1 === t1.versionKey && this.schema.options.versionKey && delete f1[this.schema.options.versionKey];
                    var p1 = t1.transform;
                    if (p1 && function(t1, e1) {
                        var r1 = t1.schema, n1 = Object.keys(r1.paths || {});
                        if (!t1._doc) return e1;
                        for(var o1 = 0, i1 = n1; o1 < i1.length; o1++){
                            var s1 = i1[o1], a1 = r1.paths[s1];
                            if ("function" == typeof a1.options.transform) {
                                var u1 = t1.get(s1), c1 = a1.options.transform.call(t1, u1);
                                ct1(s1, c1), I1.setValue(s1, c1, e1);
                            } else if (null != a1.$embeddedSchemaType && "function" == typeof a1.$embeddedSchemaType.options.transform) {
                                for(var l1 = [].concat(t1.get(s1)), f1 = a1.$embeddedSchemaType.options.transform, p1 = 0; p1 < l1.length; ++p1){
                                    var h1 = f1.call(t1, l1[p1]);
                                    l1[p1] = h1, ct1(s1, h1);
                                }
                                e1[s1] = l1;
                            }
                        }
                    }(this, f1), t1.useProjection && function(t1, e1) {
                        var r1 = t1.schema, n1 = Object.keys(r1.paths || {});
                        if (!t1._doc) return e1;
                        var o1 = t1.$__.selected;
                        void 0 === o1 && (o1 = {}, M1.applyPaths(o1, r1));
                        if (null == o1 || 0 === Object.keys(o1).length) return e1;
                        for(var i1 = 0, s1 = n1; i1 < s1.length; i1++){
                            var a1 = s1[i1];
                            null == o1[a1] || o1[a1] || delete e1[a1];
                        }
                    }(this, f1), !0 === p1 || a1.toObject && p1) {
                        var h1 = t1.json ? a1.toJSON : a1.toObject;
                        h1 && (p1 = "function" == typeof t1.transform ? t1.transform : h1.transform);
                    } else t1.transform = l1;
                    if ("function" == typeof p1) {
                        var y1 = p1(this, f1, t1);
                        void 0 !== y1 && (f1 = y1);
                    }
                    return f1;
                }, tt1.prototype.toObject = function(t1) {
                    return this.$toObject(t1);
                }, tt1.prototype.toJSON = function(t1) {
                    return this.$toObject(t1, !0);
                }, tt1.prototype.parent = function() {
                    return this.$__.parent;
                }, tt1.prototype.inspect = function(t1) {
                    var e1;
                    I1.isPOJO(t1) && ((e1 = t1).minimize = !1);
                    var r1 = this.toObject(e1);
                    return null == r1 ? "MongooseDocument { " + r1 + " }" : r1;
                }, D1.custom && /*!
  * Avoid Node deprecation warning DEP0079
  */ (tt1.prototype[D1.custom] = tt1.prototype.inspect), tt1.prototype.toString = function() {
                    var t1 = this.inspect();
                    return "string" == typeof t1 ? t1 : D1(t1);
                }, tt1.prototype.equals = function(t1) {
                    if (!t1) return !1;
                    var e1 = this.$__getValue("_id"), r1 = null != t1.$__ ? t1.$__getValue("_id") : t1;
                    return e1 || r1 ? e1 && e1.equals ? e1.equals(r1) : e1 === r1 : U1(this, t1);
                }, tt1.prototype.populate = function() {
                    if (0 === arguments.length) return this;
                    var t1, e1 = this.$__.populate || (this.$__.populate = {}), r1 = I1.args(arguments);
                    if ("function" == typeof r1[r1.length - 1] && (t1 = r1.pop()), r1.length) {
                        var n1, o1 = I1.populate.apply(null, r1), s1 = i1(o1);
                        try {
                            for(s1.s(); !(n1 = s1.n()).done;){
                                var a1 = n1.value;
                                e1[a1.path] = a1;
                            }
                        } catch (t1) {
                            s1.e(t1);
                        } finally{
                            s1.f();
                        }
                    }
                    if (t1) {
                        var u1 = I1.object.vals(e1);
                        this.$__.populate = void 0;
                        var c1 = this.constructor;
                        if (this.$__isNested) {
                            c1 = this.$__[X1].constructor;
                            var l1 = this.$__.nestedPath;
                            u1.forEach(function(t1) {
                                t1.path = l1 + "." + t1.path;
                            });
                        }
                        if (null != this.$session()) {
                            var f1 = this.$session();
                            u1.forEach(function(t1) {
                                null != t1.options ? "session" in t1.options || (t1.options.session = f1) : t1.options = {
                                    session: f1
                                };
                            });
                        }
                        c1.populate(this, u1, t1);
                    }
                    return this;
                }, tt1.prototype.execPopulate = function(t1) {
                    var e1 = this, r1 = null != t1 && "function" != typeof t1;
                    return r1 ? this.populate.apply(this, arguments).execPopulate() : S1(t1, function(t1) {
                        e1.populate(t1);
                    }, this.constructor.events);
                }, tt1.prototype.populated = function(t1, e1, r1) {
                    if (null == e1) {
                        if (!this.$__.populated) return;
                        var n1 = this.$__.populated[t1];
                        return n1 ? n1.value : void 0;
                    }
                    if (!0 === e1) {
                        if (!this.$__.populated) return;
                        return this.$__.populated[t1];
                    }
                    this.$__.populated || (this.$__.populated = {}), this.$__.populated[t1] = {
                        value: e1,
                        options: r1
                    };
                    for(var o1 = t1.split("."), i1 = 0; i1 < o1.length - 1; ++i1){
                        var s1 = o1.slice(0, i1 + 1).join("."), a1 = this.get(s1);
                        if (null != a1 && null != a1.$__ && this.populated(s1)) {
                            var u1 = o1.slice(i1 + 1).join(".");
                            a1.populated(u1, e1, r1);
                            break;
                        }
                    }
                    return e1;
                }, tt1.prototype.depopulate = function(t1) {
                    var e1;
                    "string" == typeof t1 && (t1 = t1.split(" "));
                    var r1 = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [], n1 = P1(this, "$__.populated", {});
                    if (0 === arguments.length) {
                        var o1, s1 = i1(r1);
                        try {
                            for(s1.s(); !(o1 = s1.n()).done;){
                                var a1 = o1.value;
                                delete this.$$populatedVirtuals[a1], delete this._doc[a1], delete n1[a1];
                            }
                        } catch (t1) {
                            s1.e(t1);
                        } finally{
                            s1.f();
                        }
                        for(var u1 = Object.keys(n1), c1 = 0, l1 = u1; c1 < l1.length; c1++){
                            var f1 = l1[c1];
                            (e1 = this.populated(f1)) && (delete n1[f1], this.$set(f1, e1));
                        }
                        return this;
                    }
                    var p1, h1 = i1(t1);
                    try {
                        for(h1.s(); !(p1 = h1.n()).done;){
                            var y1 = p1.value;
                            e1 = this.populated(y1), delete n1[y1], -1 !== r1.indexOf(y1) ? (delete this.$$populatedVirtuals[y1], delete this._doc[y1]) : e1 && this.$set(y1, e1);
                        }
                    } catch (t1) {
                        h1.e(t1);
                    } finally{
                        h1.f();
                    }
                    return this;
                }, tt1.prototype.$__fullPath = function(t1) {
                    return t1 || "";
                }, tt1.prototype.getChanges = function() {
                    var t1 = this.$__delta();
                    return t1 ? t1[1] : {};
                }, /*!
 * Module exports.
 */ tt1.ValidationError = b1, t1.exports = tt1;
            }).call(this, r1(8), r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            (function(n1) {
                /*!
 * Module dependencies.
 */ function o1(t1, e1) {
                    var r1;
                    if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                        if (Array.isArray(t1) || (r1 = function(t1, e1) {
                            if (!t1) return;
                            if ("string" == typeof t1) return i1(t1, e1);
                            var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                            "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                            if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                            if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return i1(t1, e1);
                        }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                            r1 && (t1 = r1);
                            var n1 = 0, o1 = function() {};
                            return {
                                s: o1,
                                n: function() {
                                    return n1 >= t1.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t1[n1++]
                                    };
                                },
                                e: function(t1) {
                                    throw t1;
                                },
                                f: o1
                            };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }
                    var s1, a1 = !0, u1 = !1;
                    return {
                        s: function() {
                            r1 = t1[Symbol.iterator]();
                        },
                        n: function() {
                            var t1 = r1.next();
                            return a1 = t1.done, t1;
                        },
                        e: function(t1) {
                            u1 = !0, s1 = t1;
                        },
                        f: function() {
                            try {
                                a1 || null == r1.return || r1.return();
                            } finally{
                                if (u1) throw s1;
                            }
                        }
                    };
                }
                function i1(t1, e1) {
                    (null == e1 || e1 > t1.length) && (e1 = t1.length);
                    for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                    return n1;
                }
                function s1(t1) {
                    return (s1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                var a1 = r1(5), u1 = r1(9), c1 = r1(48), l1 = r1(72), f1 = r1(3), p1 = r1(133), h1 = r1(50), y1 = r1(0).schemaTypeSymbol, d1 = r1(4), m1 = r1(2), _1 = r1(0).validatorErrorSymbol, v1 = r1(0).documentIsSelected, g1 = r1(0).documentIsModified, b1 = a1.CastError, w1 = a1.ValidatorError;
                function O1(t1, e1, r1) {
                    this[y1] = !0, this.path = t1, this.instance = r1, this.validators = [], this.getters = this.constructor.hasOwnProperty("getters") ? this.constructor.getters.slice() : [], this.setters = [], e1 = e1 || {};
                    for(var n1 = this.constructor.defaultOptions || {}, o1 = 0, i1 = Object.keys(n1); o1 < i1.length; o1++){
                        var a1 = i1[o1];
                        n1.hasOwnProperty(a1) && !e1.hasOwnProperty(a1) && (e1[a1] = n1[a1]);
                    }
                    null == e1.select && delete e1.select;
                    var c1 = this.OptionsConstructor || u1;
                    this.options = new c1(e1), this._index = null, m1.hasUserDefinedProperty(this.options, "immutable") && (this.$immutable = this.options.immutable, p1(this));
                    for(var l1 = 0, f1 = Object.keys(this.options); l1 < f1.length; l1++){
                        var h1 = f1[l1];
                        if ("cast" !== h1 && m1.hasUserDefinedProperty(this.options, h1) && "function" == typeof this[h1]) {
                            if ("index" === h1 && this._index) {
                                if (!1 === e1.index) {
                                    var d1 = this._index;
                                    if ("object" === s1(d1) && null != d1) {
                                        if (d1.unique) throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
                                        if (d1.sparse) throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
                                    }
                                    this._index = !1;
                                }
                                continue;
                            }
                            var _1 = e1[h1];
                            if ("default" === h1) {
                                this.default(_1);
                                continue;
                            }
                            var v1 = Array.isArray(_1) ? _1 : [
                                _1
                            ];
                            this[h1].apply(this, v1);
                        }
                    }
                    Object.defineProperty(this, "$$context", {
                        enumerable: !1,
                        configurable: !1,
                        writable: !0,
                        value: null
                    });
                }
                /*!
 * ignore
 */ O1.prototype.OptionsConstructor = u1, O1.cast = function(t1) {
                    return 0 === arguments.length || (!1 === t1 && (t1 = function(t1) {
                        return t1;
                    }), this._cast = t1), this._cast;
                }, O1.set = function(t1, e1) {
                    this.hasOwnProperty("defaultOptions") || (this.defaultOptions = Object.assign({}, this.defaultOptions)), this.defaultOptions[t1] = e1;
                }, O1.get = function(t1) {
                    this.getters = this.hasOwnProperty("getters") ? this.getters : [], this.getters.push(t1);
                }, O1.prototype.default = function(t1) {
                    if (1 === arguments.length) {
                        if (void 0 === t1) return void (this.defaultValue = void 0);
                        if (null != t1 && t1.instanceOfSchema) throw new a1("Cannot set default value of path `" + this.path + "` to a mongoose Schema instance.");
                        return this.defaultValue = t1, this.defaultValue;
                    }
                    return arguments.length > 1 && (this.defaultValue = m1.args(arguments)), this.defaultValue;
                }, O1.prototype.index = function(t1) {
                    return this._index = t1, m1.expires(this._index), this;
                }, O1.prototype.unique = function(t1) {
                    if (!1 === this._index) {
                        if (!t1) return;
                        throw new Error('Path "' + this.path + '" may not have `index` set to false and `unique` set to true');
                    }
                    return null == this._index || !0 === this._index ? this._index = {} : "string" == typeof this._index && (this._index = {
                        type: this._index
                    }), this._index.unique = t1, this;
                }, O1.prototype.text = function(t1) {
                    if (!1 === this._index) {
                        if (!t1) return;
                        throw new Error('Path "' + this.path + '" may not have `index` set to false and `text` set to true');
                    }
                    return null === this._index || void 0 === this._index || "boolean" == typeof this._index ? this._index = {} : "string" == typeof this._index && (this._index = {
                        type: this._index
                    }), this._index.text = t1, this;
                }, O1.prototype.sparse = function(t1) {
                    if (!1 === this._index) {
                        if (!t1) return;
                        throw new Error('Path "' + this.path + '" may not have `index` set to false and `sparse` set to true');
                    }
                    return null == this._index || "boolean" == typeof this._index ? this._index = {} : "string" == typeof this._index && (this._index = {
                        type: this._index
                    }), this._index.sparse = t1, this;
                }, O1.prototype.immutable = function(t1) {
                    return this.$immutable = t1, p1(this), this;
                }, O1.prototype.transform = function(t1) {
                    return this.options.transform = t1, this;
                }, O1.prototype.set = function(t1) {
                    if ("function" != typeof t1) throw new TypeError("A setter must be a function.");
                    return this.setters.push(t1), this;
                }, O1.prototype.get = function(t1) {
                    if ("function" != typeof t1) throw new TypeError("A getter must be a function.");
                    return this.getters.push(t1), this;
                }, O1.prototype.validate = function(t1, e1, r1) {
                    var n1, o1, i1, u1;
                    if ("function" == typeof t1 || t1 && "RegExp" === m1.getFunctionName(t1.constructor)) return "function" == typeof e1 ? (n1 = {
                        validator: t1,
                        message: e1
                    }).type = r1 || "user defined" : e1 instanceof Object && !r1 ? ((n1 = m1.clone(e1)).message || (n1.message = n1.msg), n1.validator = t1, n1.type = n1.type || "user defined") : (null == e1 && (e1 = a1.messages.general.default), r1 || (r1 = "user defined"), n1 = {
                        message: e1,
                        type: r1,
                        validator: t1
                    }), n1.isAsync && S1(), this.validators.push(n1), this;
                    for(o1 = 0, i1 = arguments.length; o1 < i1; o1++){
                        if (u1 = arguments[o1], !m1.isPOJO(u1)) {
                            var c1 = "Invalid validator. Received (" + s1(u1) + ") " + u1 + ". See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate";
                            throw new Error(c1);
                        }
                        this.validate(u1.validator, u1);
                    }
                    return this;
                };
                /*!
 * ignore
 */ var S1 = d1.deprecate(function() {}, "Mongoose: the `isAsync` option for custom validators is deprecated. Make your async validators return a promise instead: https://mongoosejs.com/docs/validation.html#async-custom-validators");
                /*!
 * ignore
 */ function A1(t1) {
                    return this.castForQuery(t1);
                }
                /*!
 * ignore
 */ /*!
 * Just like handleArray, except also allows `[]` because surprisingly
 * `$in: [1, []]` works fine
 */ function j1(t1) {
                    var e1 = this;
                    return Array.isArray(t1) ? t1.map(function(t1) {
                        return Array.isArray(t1) && 0 === t1.length ? t1 : e1.castForQuery(t1);
                    }) : [
                        this.castForQuery(t1)
                    ];
                }
                /*!
 * ignore
 */ O1.prototype.required = function(t1, e1) {
                    var r1 = {};
                    if (arguments.length > 0 && null == t1) return this.validators = this.validators.filter(function(t1) {
                        return t1.validator !== this.requiredValidator;
                    }, this), this.isRequired = !1, delete this.originalRequiredValue, this;
                    if ("object" === s1(t1) && (e1 = (r1 = t1).message || e1, t1 = t1.isRequired), !1 === t1) return this.validators = this.validators.filter(function(t1) {
                        return t1.validator !== this.requiredValidator;
                    }, this), this.isRequired = !1, delete this.originalRequiredValue, this;
                    var n1 = this;
                    this.isRequired = !0, this.requiredValidator = function(e1) {
                        var r1 = f1(this, "$__.cachedRequired");
                        if (null != r1 && !this[v1](n1.path) && !this[g1](n1.path)) return !0;
                        if (null != r1 && n1.path in r1) {
                            var o1 = !r1[n1.path] || n1.checkRequired(e1, this);
                            return delete r1[n1.path], o1;
                        }
                        return "function" == typeof t1 && !t1.apply(this) || n1.checkRequired(e1, this);
                    }, this.originalRequiredValue = t1, "string" == typeof t1 && (e1 = t1, t1 = void 0);
                    var o1 = e1 || a1.messages.general.required;
                    return this.validators.unshift(Object.assign({}, r1, {
                        validator: this.requiredValidator,
                        message: o1,
                        type: "required"
                    })), this;
                }, O1.prototype.ref = function(t1) {
                    return this.options.ref = t1, this;
                }, O1.prototype.getDefault = function(t1, e1) {
                    var r1 = "function" == typeof this.defaultValue ? this.defaultValue.call(t1) : this.defaultValue;
                    if (null != r1) {
                        "object" !== s1(r1) || this.options && this.options.shared || (r1 = m1.clone(r1));
                        var n1 = this.applySetters(r1, t1, e1);
                        return n1 && n1.$isSingleNested && (n1.$parent = t1), n1;
                    }
                    return r1;
                }, /*!
 * Applies setters without casting
 *
 * @api private
 */ O1.prototype._applySetters = function(t1, e1, r1, n1) {
                    var i1, s1 = t1, u1 = this.setters, c1 = this.caster, l1 = o1(m1.clone(u1).reverse());
                    try {
                        for(l1.s(); !(i1 = l1.n()).done;)s1 = i1.value.call(e1, s1, this);
                    } catch (t1) {
                        l1.e(t1);
                    } finally{
                        l1.f();
                    }
                    if (Array.isArray(s1) && c1 && c1.setters) {
                        for(var f1 = [], p1 = 0; p1 < s1.length; ++p1){
                            var h1 = s1[p1];
                            try {
                                f1.push(c1.applySetters(h1, e1, r1, n1));
                            } catch (t1) {
                                throw t1 instanceof a1.CastError && (t1.$originalErrorPath = t1.path, t1.path = t1.path + "." + p1), t1;
                            }
                        }
                        s1 = f1;
                    }
                    return s1;
                }, /*!
 * ignore
 */ O1.prototype._castNullish = function(t1) {
                    return t1;
                }, O1.prototype.applySetters = function(t1, e1, r1, n1, o1) {
                    var i1 = this._applySetters(t1, e1, r1, n1, o1);
                    return null == i1 ? this._castNullish(i1) : i1 = this.cast(i1, e1, r1, n1, o1);
                }, O1.prototype.applyGetters = function(t1, e1) {
                    var r1 = t1, n1 = this.getters, o1 = n1.length;
                    if (0 === o1) return r1;
                    for(var i1 = 0; i1 < o1; ++i1)r1 = n1[i1].call(e1, r1, this);
                    return r1;
                }, O1.prototype.select = function(t1) {
                    return this.selected = !!t1, this;
                }, O1.prototype.doValidate = function(t1, e1, r1, n1) {
                    var o1 = !1, i1 = this.path, a1 = this.validators.filter(function(t1) {
                        return null != t1 && "object" === s1(t1);
                    }), u1 = a1.length;
                    if (!u1) return e1(null);
                    var c1 = this;
                    function l1(t1, r1) {
                        if (!o1) {
                            if (void 0 === t1 || t1) --u1 <= 0 && h1(function() {
                                e1(null);
                            });
                            else {
                                var n1 = r1.ErrorConstructor || w1;
                                (o1 = new n1(r1))[_1] = !0, h1(function() {
                                    e1(o1);
                                });
                            }
                        }
                    }
                    a1.forEach(function(e1) {
                        if (!o1) {
                            var s1, a1 = e1.validator, u1 = m1.clone(e1);
                            if (u1.path = n1 && n1.path ? n1.path : i1, u1.value = t1, a1 instanceof RegExp) l1(a1.test(t1), u1);
                            else if ("function" == typeof a1) {
                                if (void 0 !== t1 || a1 === c1.requiredValidator) {
                                    if (u1.isAsync) !/*!
 * Handle async validators
 */ function(t1, e1, r1, n1, o1) {
                                        var i1 = !1, s1 = t1.call(e1, r1, function(t1, e1) {
                                            i1 || (i1 = !0, e1 && (n1.message = e1), o1(t1, n1));
                                        });
                                        "boolean" == typeof s1 ? (i1 = !0, o1(s1, n1)) : s1 && "function" == typeof s1.then && s1.then(function(t1) {
                                            i1 || (i1 = !0, o1(t1, n1));
                                        }, function(t1) {
                                            i1 || (i1 = !0, n1.reason = t1, n1.message = t1.message, o1(!1, n1));
                                        });
                                    }(a1, r1, t1, u1, l1);
                                    else {
                                        try {
                                            s1 = u1.propsParameter ? a1.call(r1, t1, u1) : a1.call(r1, t1);
                                        } catch (t1) {
                                            s1 = !1, u1.reason = t1, t1.message && (u1.message = t1.message);
                                        }
                                        null != s1 && "function" == typeof s1.then ? s1.then(function(t1) {
                                            l1(t1, u1);
                                        }, function(t1) {
                                            u1.reason = t1, u1.message = t1.message, l1(s1 = !1, u1);
                                        }) : l1(s1, u1);
                                    }
                                } else l1(!0, u1);
                            }
                        }
                    });
                }, O1.prototype.doValidateSync = function(t1, e1, r1) {
                    var n1 = this.path;
                    if (!this.validators.length) return null;
                    var o1 = this.validators;
                    if (void 0 === t1) {
                        if (!(this.validators.length > 0 && "required" === this.validators[0].type)) return null;
                        o1 = [
                            this.validators[0]
                        ];
                    }
                    var i1 = null;
                    return o1.forEach(function(o1) {
                        if (!i1 && null != o1 && "object" === s1(o1)) {
                            var u1, c1 = o1.validator, l1 = m1.clone(o1);
                            if (l1.path = r1 && r1.path ? r1.path : n1, l1.value = t1, !c1.isAsync) {
                                if (c1 instanceof RegExp) a1(c1.test(t1), l1);
                                else if ("function" == typeof c1) {
                                    try {
                                        u1 = l1.propsParameter ? c1.call(e1, t1, l1) : c1.call(e1, t1);
                                    } catch (t1) {
                                        u1 = !1, l1.reason = t1;
                                    }
                                    null != u1 && "function" == typeof u1.then || a1(u1, l1);
                                }
                            }
                        }
                    }), i1;
                    function a1(t1, e1) {
                        if (!i1 && void 0 !== t1 && !t1) {
                            var r1 = e1.ErrorConstructor || w1;
                            (i1 = new r1(e1))[_1] = !0;
                        }
                    }
                }, O1._isRef = function(t1, e1, r1, o1) {
                    var i1 = o1 && t1.options && (t1.options.ref || t1.options.refPath);
                    if (!i1 && r1 && null != r1.$__) {
                        var s1 = r1.$__fullPath(t1.path);
                        i1 = (r1.ownerDocument ? r1.ownerDocument() : r1).populated(s1) || r1.populated(t1.path);
                    }
                    if (i1) {
                        if (null == e1) return !0;
                        if (!n1.isBuffer(e1) && "Binary" !== e1._bsontype && m1.isObject(e1)) return !0;
                    }
                    return !1;
                }, O1.prototype.$conditionalHandlers = {
                    $all: function(t1) {
                        var e1 = this;
                        return Array.isArray(t1) ? t1.map(function(t1) {
                            return e1.castForQuery(t1);
                        }) : [
                            this.castForQuery(t1)
                        ];
                    },
                    $eq: A1,
                    $in: j1,
                    $ne: A1,
                    $nin: j1,
                    $exists: c1,
                    $type: l1
                }, /*!
 * Wraps `castForQuery` to handle context
 */ O1.prototype.castForQueryWrapper = function(t1) {
                    if (this.$$context = t1.context, "$conditional" in t1) {
                        var e1 = this.castForQuery(t1.$conditional, t1.val);
                        return this.$$context = null, e1;
                    }
                    if (t1.$skipQueryCastForUpdate || t1.$applySetters) {
                        var r1 = this._castForQuery(t1.val);
                        return this.$$context = null, r1;
                    }
                    var n1 = this.castForQuery(t1.val);
                    return this.$$context = null, n1;
                }, O1.prototype.castForQuery = function(t1, e1) {
                    var r1;
                    if (2 === arguments.length) {
                        if (!(r1 = this.$conditionalHandlers[t1])) throw new Error("Can't use " + t1);
                        return r1.call(this, e1);
                    }
                    return e1 = t1, this._castForQuery(e1);
                }, /*!
 * Internal switch for runSetters
 *
 * @api private
 */ O1.prototype._castForQuery = function(t1) {
                    return this.applySetters(t1, this.$$context);
                }, O1.checkRequired = function(t1) {
                    return arguments.length > 0 && (this._checkRequired = t1), this._checkRequired;
                }, O1.prototype.checkRequired = function(t1) {
                    return null != t1;
                }, /*!
 * ignore
 */ O1.prototype.clone = function() {
                    var t1 = Object.assign({}, this.options), e1 = new this.constructor(this.path, t1, this.instance);
                    return e1.validators = this.validators.slice(), void 0 !== this.requiredValidator && (e1.requiredValidator = this.requiredValidator), void 0 !== this.defaultValue && (e1.defaultValue = this.defaultValue), void 0 !== this.$immutable && void 0 === this.options.immutable && (e1.$immutable = this.$immutable, p1(e1)), void 0 !== this._index && (e1._index = this._index), void 0 !== this.selected && (e1.selected = this.selected), void 0 !== this.isRequired && (e1.isRequired = this.isRequired), void 0 !== this.originalRequiredValue && (e1.originalRequiredValue = this.originalRequiredValue), e1.getters = this.getters.slice(), e1.setters = this.setters.slice(), e1;
                }, /*!
 * Module exports.
 */ t1.exports = e1 = O1, e1.CastError = b1, e1.ValidatorError = w1;
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1) {
            var r1, n1, o1 = t1.exports = {};
            function i1() {
                throw new Error("setTimeout has not been defined");
            }
            function s1() {
                throw new Error("clearTimeout has not been defined");
            }
            function a1(t1) {
                if (r1 === setTimeout) return setTimeout(t1, 0);
                if ((r1 === i1 || !r1) && setTimeout) return r1 = setTimeout, setTimeout(t1, 0);
                try {
                    return r1(t1, 0);
                } catch (e1) {
                    try {
                        return r1.call(null, t1, 0);
                    } catch (e1) {
                        return r1.call(this, t1, 0);
                    }
                }
            }
            !function() {
                try {
                    r1 = "function" == typeof setTimeout ? setTimeout : i1;
                } catch (t1) {
                    r1 = i1;
                }
                try {
                    n1 = "function" == typeof clearTimeout ? clearTimeout : s1;
                } catch (t1) {
                    n1 = s1;
                }
            }();
            var u1, c1 = [], l1 = !1, f1 = -1;
            function p1() {
                l1 && u1 && (l1 = !1, u1.length ? c1 = u1.concat(c1) : f1 = -1, c1.length && h1());
            }
            function h1() {
                if (!l1) {
                    var t1 = a1(p1);
                    l1 = !0;
                    for(var e1 = c1.length; e1;){
                        for(u1 = c1, c1 = []; ++f1 < e1;)u1 && u1[f1].run();
                        f1 = -1, e1 = c1.length;
                    }
                    u1 = null, l1 = !1, function(t1) {
                        if (n1 === clearTimeout) return clearTimeout(t1);
                        if ((n1 === s1 || !n1) && clearTimeout) return n1 = clearTimeout, clearTimeout(t1);
                        try {
                            n1(t1);
                        } catch (e1) {
                            try {
                                return n1.call(null, t1);
                            } catch (e1) {
                                return n1.call(this, t1);
                            }
                        }
                    }(t1);
                }
            }
            function y1(t1, e1) {
                this.fun = t1, this.array = e1;
            }
            function d1() {}
            o1.nextTick = function(t1) {
                var e1 = new Array(arguments.length - 1);
                if (arguments.length > 1) for(var r1 = 1; r1 < arguments.length; r1++)e1[r1 - 1] = arguments[r1];
                c1.push(new y1(t1, e1)), 1 !== c1.length || l1 || a1(h1);
            }, y1.prototype.run = function() {
                this.fun.apply(null, this.array);
            }, o1.title = "browser", o1.browser = !0, o1.env = {}, o1.argv = [], o1.version = "", o1.versions = {}, o1.on = d1, o1.addListener = d1, o1.once = d1, o1.off = d1, o1.removeListener = d1, o1.removeAllListeners = d1, o1.emit = d1, o1.prependListener = d1, o1.prependOnceListener = d1, o1.listeners = function(t1) {
                return [];
            }, o1.binding = function(t1) {
                throw new Error("process.binding is not supported");
            }, o1.cwd = function() {
                return "/";
            }, o1.chdir = function(t1) {
                throw new Error("process.chdir is not supported");
            }, o1.umask = function() {
                return 0;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(28), o1 = function t1(e1) {
                if (function(t1, e1) {
                    if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                }(this, t1), null == e1) return this;
                Object.assign(this, n1(e1));
            }, i1 = r1(10);
            Object.defineProperty(o1.prototype, "type", i1), Object.defineProperty(o1.prototype, "validate", i1), Object.defineProperty(o1.prototype, "cast", i1), Object.defineProperty(o1.prototype, "required", i1), Object.defineProperty(o1.prototype, "default", i1), Object.defineProperty(o1.prototype, "ref", i1), Object.defineProperty(o1.prototype, "select", i1), Object.defineProperty(o1.prototype, "index", i1), Object.defineProperty(o1.prototype, "unique", i1), Object.defineProperty(o1.prototype, "immutable", i1), Object.defineProperty(o1.prototype, "sparse", i1), Object.defineProperty(o1.prototype, "text", i1), Object.defineProperty(o1.prototype, "transform", i1), t1.exports = o1;
        },
        function(t1, e1, r1) {
            "use strict";
            t1.exports = Object.freeze({
                enumerable: !0,
                configurable: !0,
                writable: !0,
                value: void 0
            });
        },
        function(t1, e1) {
            function r1(t1) {
                return (r1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            var n1;
            n1 = function() {
                return this;
            }();
            try {
                n1 = n1 || new Function("return this")();
            } catch (t1) {
                "object" === ("undefined" == typeof window ? "undefined" : r1(window)) && (n1 = window);
            }
            t1.exports = n1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
            }
            function i1(t1, e1) {
                for(var r1 = 0; r1 < e1.length; r1++){
                    var n1 = e1[r1];
                    n1.enumerable = n1.enumerable || !1, n1.configurable = !0, "value" in n1 && (n1.writable = !0), Object.defineProperty(t1, n1.key, n1);
                }
            }
            function s1(t1, e1) {
                return (s1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function a1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = c1(t1);
                    if (e1) {
                        var o1 = c1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return u1(this, r1);
                };
            }
            function u1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function c1(t1) {
                return (c1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var l1 = r1(14), f1 = r1(3), p1 = r1(4), h1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && s1(t1, e1);
                }(l1, t1);
                var e1, r1, n1, c1 = a1(l1);
                function l1(t1, e1, r1, n1, i1) {
                    var s1;
                    if (o1(this, l1), arguments.length > 0) {
                        var a1 = y1(e1), f1 = d1(i1), p1 = m1(null, t1, a1, r1, f1);
                        (s1 = c1.call(this, p1)).init(t1, e1, r1, n1, i1);
                    } else s1 = c1.call(this, m1());
                    return u1(s1);
                }
                /*!
   * ignore
   */ return e1 = l1, r1 = [
                    {
                        key: "init",
                        value: function(t1, e1, r1, n1, o1) {
                            this.stringValue = y1(e1), this.messageFormat = d1(o1), this.kind = t1, this.value = e1, this.path = r1, this.reason = n1;
                        }
                    },
                    {
                        key: "copy",
                        value: function(t1) {
                            this.messageFormat = t1.messageFormat, this.stringValue = t1.stringValue, this.kind = t1.kind, this.value = t1.value, this.path = t1.path, this.reason = t1.reason, this.message = t1.message;
                        }
                    },
                    {
                        key: "setModel",
                        value: function(t1) {
                            this.model = t1, this.message = m1(t1, this.kind, this.stringValue, this.path, this.messageFormat);
                        }
                    }
                ], i1(e1.prototype, r1), n1 && i1(e1, n1), l1;
            }(l1);
            function y1(t1) {
                var e1 = p1.inspect(t1);
                return (e1 = e1.replace(/^'|'$/g, '"')).startsWith('"') || (e1 = '"' + e1 + '"'), e1;
            }
            function d1(t1) {
                var e1 = f1(t1, "options.cast", null);
                if ("string" == typeof e1) return e1;
            }
            /*!
 * ignore
 */ function m1(t1, e1, r1, n1, o1) {
                if (null != o1) {
                    var i1 = o1.replace("{KIND}", e1).replace("{VALUE}", r1).replace("{PATH}", n1);
                    return null != t1 && (i1 = i1.replace("{MODEL}", t1.modelName)), i1;
                }
                var s1 = "Cast to " + e1 + " failed for value " + r1 + ' at path "' + n1 + '"';
                return null != t1 && (s1 += ' for model "' + t1.modelName + '"'), s1;
            }
            /*!
 * exports
 */ Object.defineProperty(h1.prototype, "name", {
                value: "CastError"
            }), t1.exports = h1;
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(15).get().ObjectId, o1 = r1(0).objectIdSymbol;
            /*!
 * Getter for convenience with populate, see gh-6115
 */ Object.defineProperty(n1.prototype, "_id", {
                enumerable: !1,
                configurable: !0,
                get: function() {
                    return this;
                }
            }), n1.prototype[o1] = !0, t1.exports = n1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * ignore
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
            }
            function i1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function s1(t1) {
                var e1 = "function" == typeof Map ? new Map : void 0;
                return (s1 = function(t1) {
                    if (null === t1 || (r1 = t1, -1 === Function.toString.call(r1).indexOf("[native code]"))) return t1;
                    var r1;
                    if ("function" != typeof t1) throw new TypeError("Super expression must either be null or a function");
                    if (void 0 !== e1) {
                        if (e1.has(t1)) return e1.get(t1);
                        e1.set(t1, n1);
                    }
                    function n1() {
                        return a1(t1, arguments, l1(this).constructor);
                    }
                    return n1.prototype = Object.create(t1.prototype, {
                        constructor: {
                            value: n1,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), c1(n1, t1);
                })(t1);
            }
            function a1(t1, e1, r1) {
                return (a1 = u1() ? Reflect.construct : function(t1, e1, r1) {
                    var n1 = [
                        null
                    ];
                    n1.push.apply(n1, e1);
                    var o1 = new (Function.bind.apply(t1, n1));
                    return r1 && c1(o1, r1.prototype), o1;
                }).apply(null, arguments);
            }
            function u1() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                } catch (t1) {
                    return !1;
                }
            }
            function c1(t1, e1) {
                return (c1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function l1(t1) {
                return (l1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var f1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && c1(t1, e1);
                }(s1, t1);
                var e1, r1, n1 = (e1 = s1, r1 = u1(), function() {
                    var t1, n1 = l1(e1);
                    if (r1) {
                        var o1 = l1(this).constructor;
                        t1 = Reflect.construct(n1, arguments, o1);
                    } else t1 = n1.apply(this, arguments);
                    return i1(this, t1);
                });
                function s1() {
                    return o1(this, s1), n1.apply(this, arguments);
                }
                return s1;
            }(s1(Error));
            Object.defineProperty(f1.prototype, "name", {
                value: "MongooseError"
            }), t1.exports = f1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * ignore
 */ var n1 = null;
            t1.exports.get = function() {
                return n1;
            }, t1.exports.set = function(t1) {
                n1 = t1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                function r1(t1, r1) {
                    return new e1(t1, r1);
                }
                t1.exports = {
                    normalizedFunctionString: function(t1) {
                        return t1.toString().replace(/function *\(/, "function (");
                    },
                    allocBuffer: "function" == typeof e1.alloc ? function() {
                        return e1.alloc.apply(e1, arguments);
                    } : r1,
                    toBuffer: "function" == typeof e1.from ? function() {
                        return e1.from.apply(e1, arguments);
                    } : r1
                };
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * ignore
 */ e1.internalToObjectOptions = {
                transform: !1,
                virtuals: !1,
                getters: !1,
                _skipDepopulateTopLevel: !0,
                depopulate: !0,
                flattenDecimals: !1
            };
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                /*!
 * Module dependencies.
 */ function n1(t1) {
                    return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                function o1(t1, e1) {
                    var r1;
                    if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                        if (Array.isArray(t1) || (r1 = function(t1, e1) {
                            if (!t1) return;
                            if ("string" == typeof t1) return i1(t1, e1);
                            var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                            "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                            if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                            if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return i1(t1, e1);
                        }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                            r1 && (t1 = r1);
                            var n1 = 0, o1 = function() {};
                            return {
                                s: o1,
                                n: function() {
                                    return n1 >= t1.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t1[n1++]
                                    };
                                },
                                e: function(t1) {
                                    throw t1;
                                },
                                f: o1
                            };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }
                    var s1, a1 = !0, u1 = !1;
                    return {
                        s: function() {
                            r1 = t1[Symbol.iterator]();
                        },
                        n: function() {
                            var t1 = r1.next();
                            return a1 = t1.done, t1;
                        },
                        e: function(t1) {
                            u1 = !0, s1 = t1;
                        },
                        f: function() {
                            try {
                                a1 || null == r1.return || r1.return();
                            } finally{
                                if (u1) throw s1;
                            }
                        }
                    };
                }
                function i1(t1, e1) {
                    (null == e1 || e1 > t1.length) && (e1 = t1.length);
                    for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                    return n1;
                }
                function s1(t1, e1) {
                    if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                }
                function a1(t1, e1) {
                    for(var r1 = 0; r1 < e1.length; r1++){
                        var n1 = e1[r1];
                        n1.enumerable = n1.enumerable || !1, n1.configurable = !0, "value" in n1 && (n1.writable = !0), Object.defineProperty(t1, n1.key, n1);
                    }
                }
                function u1(t1, e1, r1) {
                    return (u1 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t1, e1, r1) {
                        var n1 = function(t1, e1) {
                            for(; !Object.prototype.hasOwnProperty.call(t1, e1) && null !== (t1 = p1(t1)););
                            return t1;
                        }(t1, e1);
                        if (n1) {
                            var o1 = Object.getOwnPropertyDescriptor(n1, e1);
                            return o1.get ? o1.get.call(r1) : o1.value;
                        }
                    })(t1, e1, r1 || t1);
                }
                function c1(t1, e1) {
                    return (c1 = Object.setPrototypeOf || function(t1, e1) {
                        return t1.__proto__ = e1, t1;
                    })(t1, e1);
                }
                function l1(t1) {
                    var e1 = function() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                        } catch (t1) {
                            return !1;
                        }
                    }();
                    return function() {
                        var r1, n1 = p1(t1);
                        if (e1) {
                            var o1 = p1(this).constructor;
                            r1 = Reflect.construct(n1, arguments, o1);
                        } else r1 = n1.apply(this, arguments);
                        return f1(this, r1);
                    };
                }
                function f1(t1, e1) {
                    return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                        if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t1;
                    }(t1) : e1;
                }
                function p1(t1) {
                    return (p1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                        return t1.__proto__ || Object.getPrototypeOf(t1);
                    })(t1);
                }
                var h1 = r1(83), y1 = r1(6), d1 = r1(13), m1 = r1(86), _1 = r1(34), v1 = r1(17).internalToObjectOptions, g1 = r1(4), b1 = r1(2), w1 = r1(0).arrayAtomicsSymbol, O1 = r1(0).arrayParentSymbol, S1 = r1(0).arrayPathSymbol, A1 = r1(0).arraySchemaSymbol, j1 = r1(0).documentArrayParent, E1 = Array.prototype.push, $1 = function(t1) {
                    !function(t1, e1) {
                        if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                        t1.prototype = Object.create(e1 && e1.prototype, {
                            constructor: {
                                value: t1,
                                writable: !0,
                                configurable: !0
                            }
                        }), e1 && c1(t1, e1);
                    }(n1, t1);
                    var r1 = l1(n1);
                    function n1() {
                        return s1(this, n1), r1.apply(this, arguments);
                    }
                    return function(t1, e1, r1) {
                        e1 && a1(t1.prototype, e1), r1 && a1(t1, r1);
                    }(n1, [
                        {
                            key: "toBSON",
                            /*!
     * ignore
     */ value: function() {
                                return this.toObject(v1);
                            }
                        },
                        {
                            key: "map",
                            value: function() {
                                var t1 = u1(p1(n1.prototype), "map", this).apply(this, arguments);
                                return t1[A1] = null, t1[S1] = null, t1[O1] = null, t1;
                            }
                        },
                        {
                            key: "_cast",
                            value: function(t1, r1) {
                                if (null == this[A1]) return t1;
                                var n1 = this[A1].casterConstructor;
                                if ((n1.$isMongooseDocumentArray ? t1 && t1.isMongooseDocumentArray : t1 instanceof n1) || t1 && t1.constructor && t1.constructor.baseCasterConstructor === n1) return t1[j1] && t1.__parentArray || (t1[j1] = this[O1], t1.__parentArray = this), t1.$setIndex(r1), t1;
                                if (null == t1) return null;
                                if ((e1.isBuffer(t1) || t1 instanceof d1 || !b1.isObject(t1)) && (t1 = {
                                    _id: t1
                                }), t1 && n1.discriminators && n1.schema && n1.schema.options && n1.schema.options.discriminatorKey) {
                                    if ("string" == typeof t1[n1.schema.options.discriminatorKey] && n1.discriminators[t1[n1.schema.options.discriminatorKey]]) n1 = n1.discriminators[t1[n1.schema.options.discriminatorKey]];
                                    else {
                                        var o1 = _1(n1, t1[n1.schema.options.discriminatorKey]);
                                        o1 && (n1 = o1);
                                    }
                                }
                                return n1.$isMongooseDocumentArray ? n1.cast(t1, this, void 0, void 0, r1) : new n1(t1, this, void 0, void 0, r1);
                            }
                        },
                        {
                            key: "id",
                            value: function(t1) {
                                var e1, r1, n1;
                                try {
                                    e1 = m1(t1).toString();
                                } catch (t1) {
                                    e1 = null;
                                }
                                var i1, s1 = o1(this);
                                try {
                                    for(s1.s(); !(i1 = s1.n()).done;){
                                        var a1 = i1.value;
                                        if (a1 && null != (n1 = a1.get("_id"))) {
                                            if (n1 instanceof y1) {
                                                if (r1 || (r1 = String(t1)), r1 == n1._id) return a1;
                                            } else if (t1 instanceof d1 || n1 instanceof d1) {
                                                if (e1 == n1) return a1;
                                            } else if (t1 == n1 || b1.deepEqual(t1, n1)) return a1;
                                        }
                                    }
                                } catch (t1) {
                                    s1.e(t1);
                                } finally{
                                    s1.f();
                                }
                                return null;
                            }
                        },
                        {
                            key: "toObject",
                            value: function(t1) {
                                return [].concat(this.map(function(e1) {
                                    return null == e1 ? null : "function" != typeof e1.toObject ? e1 : e1.toObject(t1);
                                }));
                            }
                        },
                        {
                            key: "slice",
                            value: function() {
                                var t1 = u1(p1(n1.prototype), "slice", this).apply(this, arguments);
                                return t1[O1] = this[O1], t1[S1] = this[S1], t1;
                            }
                        },
                        {
                            key: "push",
                            value: function() {
                                var t1 = u1(p1(n1.prototype), "push", this).apply(this, arguments);
                                return P1(this), t1;
                            }
                        },
                        {
                            key: "pull",
                            value: function() {
                                var t1 = u1(p1(n1.prototype), "pull", this).apply(this, arguments);
                                return P1(this), t1;
                            }
                        },
                        {
                            key: "shift",
                            value: function() {
                                var t1 = u1(p1(n1.prototype), "shift", this).apply(this, arguments);
                                return P1(this), t1;
                            }
                        },
                        {
                            key: "splice",
                            value: function() {
                                var t1 = u1(p1(n1.prototype), "splice", this).apply(this, arguments);
                                return P1(this), t1;
                            }
                        },
                        {
                            key: "inspect",
                            value: function() {
                                return this.toObject();
                            }
                        },
                        {
                            key: "create",
                            value: function(t1) {
                                var e1 = this[A1].casterConstructor;
                                if (t1 && e1.discriminators && e1.schema && e1.schema.options && e1.schema.options.discriminatorKey) {
                                    if ("string" == typeof t1[e1.schema.options.discriminatorKey] && e1.discriminators[t1[e1.schema.options.discriminatorKey]]) e1 = e1.discriminators[t1[e1.schema.options.discriminatorKey]];
                                    else {
                                        var r1 = _1(e1, t1[e1.schema.options.discriminatorKey]);
                                        r1 && (e1 = r1);
                                    }
                                }
                                return new e1(t1, this);
                            }
                        },
                        {
                            key: "notify",
                            value: function(t1) {
                                var e1 = this;
                                return function r1(n1, o1) {
                                    for(var i1 = (o1 = o1 || e1).length; i1--;)if (null != o1[i1]) {
                                        switch(t1){
                                            case "save":
                                                n1 = e1[i1];
                                        }
                                        o1[i1].isMongooseArray ? r1(n1, o1[i1]) : o1[i1] && o1[i1].emit(t1, n1);
                                    }
                                };
                            }
                        },
                        {
                            key: "isMongooseDocumentArray",
                            get: function() {
                                return !0;
                            }
                        }
                    ]), n1;
                }(h1);
                /*!
 * If this is a document array, each element may contain single
 * populated paths, so we need to modify the top-level document's
 * populated cache. See gh-8247, gh-8265.
 */ function P1(t1) {
                    var e1 = t1[O1];
                    if (e1 && null != e1.$__.populated) {
                        var r1, n1 = o1(Object.keys(e1.$__.populated).filter(function(e1) {
                            return e1.startsWith(t1[S1] + ".");
                        }));
                        try {
                            var i1 = function() {
                                var n1 = r1.value, o1 = n1.slice((t1[S1] + ".").length);
                                if (!Array.isArray(e1.$__.populated[n1].value)) return "continue";
                                e1.$__.populated[n1].value = t1.map(function(t1) {
                                    return t1.populated(o1);
                                });
                            };
                            for(n1.s(); !(r1 = n1.n()).done;)i1();
                        } catch (t1) {
                            n1.e(t1);
                        } finally{
                            n1.f();
                        }
                    }
                }
                g1.inspect.custom && ($1.prototype[g1.inspect.custom] = $1.prototype.inspect), /*!
 * Module exports.
 */ t1.exports = function(t1, e1, r1) {
                    var n1 = new $1;
                    if (n1[w1] = {}, n1[A1] = void 0, Array.isArray(t1) && (t1 instanceof $1 && t1[S1] === e1 && t1[O1] === r1 && (n1[w1] = Object.assign({}, t1[w1])), t1.forEach(function(t1) {
                        E1.call(n1, t1);
                    })), n1[S1] = e1, r1 && r1 instanceof y1) for(n1[O1] = r1, n1[A1] = r1.schema.path(e1); null != n1 && null != n1[A1] && n1[A1].$isMongooseArray && !n1[A1].$isMongooseDocumentArray;)n1[A1] = n1[A1].casterConstructor;
                    return n1;
                };
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            var o1, i1 = "object" === ("undefined" == typeof Reflect ? "undefined" : n1(Reflect)) ? Reflect : null, s1 = i1 && "function" == typeof i1.apply ? i1.apply : function(t1, e1, r1) {
                return Function.prototype.apply.call(t1, e1, r1);
            };
            o1 = i1 && "function" == typeof i1.ownKeys ? i1.ownKeys : Object.getOwnPropertySymbols ? function(t1) {
                return Object.getOwnPropertyNames(t1).concat(Object.getOwnPropertySymbols(t1));
            } : function(t1) {
                return Object.getOwnPropertyNames(t1);
            };
            var a1 = Number.isNaN || function(t1) {
                return t1 != t1;
            };
            function u1() {
                u1.init.call(this);
            }
            t1.exports = u1, t1.exports.once = function(t1, e1) {
                return new Promise(function(r1, n1) {
                    function o1() {
                        void 0 !== i1 && t1.removeListener("error", i1), r1([].slice.call(arguments));
                    }
                    var i1;
                    "error" !== e1 && (i1 = function(r1) {
                        t1.removeListener(e1, o1), n1(r1);
                    }, t1.once("error", i1)), t1.once(e1, o1);
                });
            }, u1.EventEmitter = u1, u1.prototype._events = void 0, u1.prototype._eventsCount = 0, u1.prototype._maxListeners = void 0;
            var c1 = 10;
            function l1(t1) {
                if ("function" != typeof t1) throw new TypeError('The "listener" argument must be of type Function. Received type ' + n1(t1));
            }
            function f1(t1) {
                return void 0 === t1._maxListeners ? u1.defaultMaxListeners : t1._maxListeners;
            }
            function p1(t1, e1, r1, n1) {
                var o1, i1, s1, a1;
                if (l1(r1), void 0 === (i1 = t1._events) ? (i1 = t1._events = Object.create(null), t1._eventsCount = 0) : (void 0 !== i1.newListener && (t1.emit("newListener", e1, r1.listener ? r1.listener : r1), i1 = t1._events), s1 = i1[e1]), void 0 === s1) s1 = i1[e1] = r1, ++t1._eventsCount;
                else if ("function" == typeof s1 ? s1 = i1[e1] = n1 ? [
                    r1,
                    s1
                ] : [
                    s1,
                    r1
                ] : n1 ? s1.unshift(r1) : s1.push(r1), (o1 = f1(t1)) > 0 && s1.length > o1 && !s1.warned) {
                    s1.warned = !0;
                    var u1 = new Error("Possible EventEmitter memory leak detected. " + s1.length + " " + String(e1) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    u1.name = "MaxListenersExceededWarning", u1.emitter = t1, u1.type = e1, u1.count = s1.length, a1 = u1, console && console.warn && console.warn(a1);
                }
                return t1;
            }
            function h1() {
                if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
            }
            function y1(t1, e1, r1) {
                var n1 = {
                    fired: !1,
                    wrapFn: void 0,
                    target: t1,
                    type: e1,
                    listener: r1
                }, o1 = h1.bind(n1);
                return o1.listener = r1, n1.wrapFn = o1, o1;
            }
            function d1(t1, e1, r1) {
                var n1 = t1._events;
                if (void 0 === n1) return [];
                var o1 = n1[e1];
                return void 0 === o1 ? [] : "function" == typeof o1 ? r1 ? [
                    o1.listener || o1
                ] : [
                    o1
                ] : r1 ? function(t1) {
                    for(var e1 = new Array(t1.length), r1 = 0; r1 < e1.length; ++r1)e1[r1] = t1[r1].listener || t1[r1];
                    return e1;
                }(o1) : _1(o1, o1.length);
            }
            function m1(t1) {
                var e1 = this._events;
                if (void 0 !== e1) {
                    var r1 = e1[t1];
                    if ("function" == typeof r1) return 1;
                    if (void 0 !== r1) return r1.length;
                }
                return 0;
            }
            function _1(t1, e1) {
                for(var r1 = new Array(e1), n1 = 0; n1 < e1; ++n1)r1[n1] = t1[n1];
                return r1;
            }
            Object.defineProperty(u1, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return c1;
                },
                set: function(t1) {
                    if ("number" != typeof t1 || t1 < 0 || a1(t1)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t1 + ".");
                    c1 = t1;
                }
            }), u1.init = function() {
                void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
            }, u1.prototype.setMaxListeners = function(t1) {
                if ("number" != typeof t1 || t1 < 0 || a1(t1)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t1 + ".");
                return this._maxListeners = t1, this;
            }, u1.prototype.getMaxListeners = function() {
                return f1(this);
            }, u1.prototype.emit = function(t1) {
                for(var e1 = [], r1 = 1; r1 < arguments.length; r1++)e1.push(arguments[r1]);
                var n1 = "error" === t1, o1 = this._events;
                if (void 0 !== o1) n1 = n1 && void 0 === o1.error;
                else if (!n1) return !1;
                if (n1) {
                    var i1;
                    if (e1.length > 0 && (i1 = e1[0]), i1 instanceof Error) throw i1;
                    var a1 = new Error("Unhandled error." + (i1 ? " (" + i1.message + ")" : ""));
                    throw a1.context = i1, a1;
                }
                var u1 = o1[t1];
                if (void 0 === u1) return !1;
                if ("function" == typeof u1) s1(u1, this, e1);
                else {
                    var c1 = u1.length, l1 = _1(u1, c1);
                    for(r1 = 0; r1 < c1; ++r1)s1(l1[r1], this, e1);
                }
                return !0;
            }, u1.prototype.addListener = function(t1, e1) {
                return p1(this, t1, e1, !1);
            }, u1.prototype.on = u1.prototype.addListener, u1.prototype.prependListener = function(t1, e1) {
                return p1(this, t1, e1, !0);
            }, u1.prototype.once = function(t1, e1) {
                return l1(e1), this.on(t1, y1(this, t1, e1)), this;
            }, u1.prototype.prependOnceListener = function(t1, e1) {
                return l1(e1), this.prependListener(t1, y1(this, t1, e1)), this;
            }, u1.prototype.removeListener = function(t1, e1) {
                var r1, n1, o1, i1, s1;
                if (l1(e1), void 0 === (n1 = this._events)) return this;
                if (void 0 === (r1 = n1[t1])) return this;
                if (r1 === e1 || r1.listener === e1) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete n1[t1], n1.removeListener && this.emit("removeListener", t1, r1.listener || e1));
                else if ("function" != typeof r1) {
                    for(o1 = -1, i1 = r1.length - 1; i1 >= 0; i1--)if (r1[i1] === e1 || r1[i1].listener === e1) {
                        s1 = r1[i1].listener, o1 = i1;
                        break;
                    }
                    if (o1 < 0) return this;
                    0 === o1 ? r1.shift() : function(t1, e1) {
                        for(; e1 + 1 < t1.length; e1++)t1[e1] = t1[e1 + 1];
                        t1.pop();
                    }(r1, o1), 1 === r1.length && (n1[t1] = r1[0]), void 0 !== n1.removeListener && this.emit("removeListener", t1, s1 || e1);
                }
                return this;
            }, u1.prototype.off = u1.prototype.removeListener, u1.prototype.removeAllListeners = function(t1) {
                var e1, r1, n1;
                if (void 0 === (r1 = this._events)) return this;
                if (void 0 === r1.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r1[t1] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r1[t1]), this;
                if (0 === arguments.length) {
                    var o1, i1 = Object.keys(r1);
                    for(n1 = 0; n1 < i1.length; ++n1)"removeListener" !== (o1 = i1[n1]) && this.removeAllListeners(o1);
                    return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
                }
                if ("function" == typeof (e1 = r1[t1])) this.removeListener(t1, e1);
                else if (void 0 !== e1) for(n1 = e1.length - 1; n1 >= 0; n1--)this.removeListener(t1, e1[n1]);
                return this;
            }, u1.prototype.listeners = function(t1) {
                return d1(this, t1, !0);
            }, u1.prototype.rawListeners = function(t1) {
                return d1(this, t1, !1);
            }, u1.listenerCount = function(t1, e1) {
                return "function" == typeof t1.listenerCount ? t1.listenerCount(e1) : m1.call(t1, e1);
            }, u1.prototype.listenerCount = m1, u1.prototype.eventNames = function() {
                return this._eventsCount > 0 ? o1(this._events) : [];
            };
        },
        function(t1, e1, r1) {
            "use strict";
            t1.exports = r1(15).get().Decimal128;
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                /*!
 * Determines if `arg` is an object.
 *
 * @param {Object|Array|String|Function|RegExp|any} arg
 * @api private
 * @return {Boolean}
 */ t1.exports = function(t1) {
                    return !!e1.isBuffer(t1) || "[object Object]" === Object.prototype.toString.call(t1);
                };
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                function n1(t1) {
                    return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                var o1 = r1(114);
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function i1(t1, e1) {
                    if (t1 === e1) return 0;
                    for(var r1 = t1.length, n1 = e1.length, o1 = 0, i1 = Math.min(r1, n1); o1 < i1; ++o1)if (t1[o1] !== e1[o1]) {
                        r1 = t1[o1], n1 = e1[o1];
                        break;
                    }
                    return r1 < n1 ? -1 : n1 < r1 ? 1 : 0;
                }
                function s1(t1) {
                    return e1.Buffer && "function" == typeof e1.Buffer.isBuffer ? e1.Buffer.isBuffer(t1) : !(null == t1 || !t1._isBuffer);
                }
                var a1 = r1(4), u1 = Object.prototype.hasOwnProperty, c1 = Array.prototype.slice, l1 = "foo" === (function() {}).name;
                function f1(t1) {
                    return Object.prototype.toString.call(t1);
                }
                function p1(t1) {
                    return !s1(t1) && "function" == typeof e1.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t1) : !!t1 && (t1 instanceof DataView || !!(t1.buffer && t1.buffer instanceof ArrayBuffer)));
                }
                var h1 = t1.exports = g1, y1 = /\s*function\s+([^\(\s]*)\s*/;
                function d1(t1) {
                    if (a1.isFunction(t1)) {
                        if (l1) return t1.name;
                        var e1 = t1.toString().match(y1);
                        return e1 && e1[1];
                    }
                }
                function m1(t1, e1) {
                    return "string" == typeof t1 ? t1.length < e1 ? t1 : t1.slice(0, e1) : t1;
                }
                function _1(t1) {
                    if (l1 || !a1.isFunction(t1)) return a1.inspect(t1);
                    var e1 = d1(t1);
                    return "[Function" + (e1 ? ": " + e1 : "") + "]";
                }
                function v1(t1, e1, r1, n1, o1) {
                    throw new h1.AssertionError({
                        message: r1,
                        actual: t1,
                        expected: e1,
                        operator: n1,
                        stackStartFunction: o1
                    });
                }
                function g1(t1, e1) {
                    t1 || v1(t1, !0, e1, "==", h1.ok);
                }
                function b1(t1, e1, r1, o1) {
                    if (t1 === e1) return !0;
                    if (s1(t1) && s1(e1)) return 0 === i1(t1, e1);
                    if (a1.isDate(t1) && a1.isDate(e1)) return t1.getTime() === e1.getTime();
                    if (a1.isRegExp(t1) && a1.isRegExp(e1)) return t1.source === e1.source && t1.global === e1.global && t1.multiline === e1.multiline && t1.lastIndex === e1.lastIndex && t1.ignoreCase === e1.ignoreCase;
                    if (null !== t1 && "object" === n1(t1) || null !== e1 && "object" === n1(e1)) {
                        if (p1(t1) && p1(e1) && f1(t1) === f1(e1) && !(t1 instanceof Float32Array || t1 instanceof Float64Array)) return 0 === i1(new Uint8Array(t1.buffer), new Uint8Array(e1.buffer));
                        if (s1(t1) !== s1(e1)) return !1;
                        var u1 = (o1 = o1 || {
                            actual: [],
                            expected: []
                        }).actual.indexOf(t1);
                        return -1 !== u1 && u1 === o1.expected.indexOf(e1) || (o1.actual.push(t1), o1.expected.push(e1), function(t1, e1, r1, n1) {
                            if (null == t1 || null == e1) return !1;
                            if (a1.isPrimitive(t1) || a1.isPrimitive(e1)) return t1 === e1;
                            if (r1 && Object.getPrototypeOf(t1) !== Object.getPrototypeOf(e1)) return !1;
                            var o1 = w1(t1), i1 = w1(e1);
                            if (o1 && !i1 || !o1 && i1) return !1;
                            if (o1) return t1 = c1.call(t1), e1 = c1.call(e1), b1(t1, e1, r1);
                            var s1, u1, l1 = A1(t1), f1 = A1(e1);
                            if (l1.length !== f1.length) return !1;
                            for(l1.sort(), f1.sort(), u1 = l1.length - 1; u1 >= 0; u1--)if (l1[u1] !== f1[u1]) return !1;
                            for(u1 = l1.length - 1; u1 >= 0; u1--)if (s1 = l1[u1], !b1(t1[s1], e1[s1], r1, n1)) return !1;
                            return !0;
                        }(t1, e1, r1, o1));
                    }
                    return r1 ? t1 === e1 : t1 == e1;
                }
                function w1(t1) {
                    return "[object Arguments]" == Object.prototype.toString.call(t1);
                }
                function O1(t1, e1) {
                    if (!t1 || !e1) return !1;
                    if ("[object RegExp]" == Object.prototype.toString.call(e1)) return e1.test(t1);
                    try {
                        if (t1 instanceof e1) return !0;
                    } catch (t1) {}
                    return !Error.isPrototypeOf(e1) && !0 === e1.call({}, t1);
                }
                function S1(t1, e1, r1, n1) {
                    var o1;
                    if ("function" != typeof e1) throw new TypeError('"block" argument must be a function');
                    "string" == typeof r1 && (n1 = r1, r1 = null), o1 = function(t1) {
                        var e1;
                        try {
                            t1();
                        } catch (t1) {
                            e1 = t1;
                        }
                        return e1;
                    }(e1), n1 = (r1 && r1.name ? " (" + r1.name + ")." : ".") + (n1 ? " " + n1 : "."), t1 && !o1 && v1(o1, r1, "Missing expected exception" + n1);
                    var i1 = "string" == typeof n1, s1 = !t1 && o1 && !r1;
                    if ((!t1 && a1.isError(o1) && i1 && O1(o1, r1) || s1) && v1(o1, r1, "Got unwanted exception" + n1), t1 && o1 && r1 && !O1(o1, r1) || !t1 && o1) throw o1;
                }
                h1.AssertionError = function(t1) {
                    this.name = "AssertionError", this.actual = t1.actual, this.expected = t1.expected, this.operator = t1.operator, t1.message ? (this.message = t1.message, this.generatedMessage = !1) : (this.message = function(t1) {
                        return m1(_1(t1.actual), 128) + " " + t1.operator + " " + m1(_1(t1.expected), 128);
                    }(this), this.generatedMessage = !0);
                    var e1 = t1.stackStartFunction || v1;
                    if (Error.captureStackTrace) Error.captureStackTrace(this, e1);
                    else {
                        var r1 = new Error;
                        if (r1.stack) {
                            var n1 = r1.stack, o1 = d1(e1), i1 = n1.indexOf("\n" + o1);
                            if (i1 >= 0) {
                                var s1 = n1.indexOf("\n", i1 + 1);
                                n1 = n1.substring(s1 + 1);
                            }
                            this.stack = n1;
                        }
                    }
                }, a1.inherits(h1.AssertionError, Error), h1.fail = v1, h1.ok = g1, h1.equal = function(t1, e1, r1) {
                    t1 != e1 && v1(t1, e1, r1, "==", h1.equal);
                }, h1.notEqual = function(t1, e1, r1) {
                    t1 == e1 && v1(t1, e1, r1, "!=", h1.notEqual);
                }, h1.deepEqual = function(t1, e1, r1) {
                    b1(t1, e1, !1) || v1(t1, e1, r1, "deepEqual", h1.deepEqual);
                }, h1.deepStrictEqual = function(t1, e1, r1) {
                    b1(t1, e1, !0) || v1(t1, e1, r1, "deepStrictEqual", h1.deepStrictEqual);
                }, h1.notDeepEqual = function(t1, e1, r1) {
                    b1(t1, e1, !1) && v1(t1, e1, r1, "notDeepEqual", h1.notDeepEqual);
                }, h1.notDeepStrictEqual = function t1(e1, r1, n1) {
                    b1(e1, r1, !0) && v1(e1, r1, n1, "notDeepStrictEqual", t1);
                }, h1.strictEqual = function(t1, e1, r1) {
                    t1 !== e1 && v1(t1, e1, r1, "===", h1.strictEqual);
                }, h1.notStrictEqual = function(t1, e1, r1) {
                    t1 === e1 && v1(t1, e1, r1, "!==", h1.notStrictEqual);
                }, h1.throws = function(t1, e1, r1) {
                    S1(!0, t1, e1, r1);
                }, h1.doesNotThrow = function(t1, e1, r1) {
                    S1(!1, t1, e1, r1);
                }, h1.ifError = function(t1) {
                    if (t1) throw t1;
                }, h1.strict = o1(function t1(e1, r1) {
                    e1 || v1(e1, !0, r1, "==", t1);
                }, h1, {
                    equal: h1.strictEqual,
                    deepEqual: h1.deepStrictEqual,
                    notEqual: h1.notStrictEqual,
                    notDeepEqual: h1.notDeepStrictEqual
                }), h1.strict.strict = h1.strict;
                var A1 = Object.keys || function(t1) {
                    var e1 = [];
                    for(var r1 in t1)u1.call(t1, r1) && e1.push(r1);
                    return e1;
                };
            }).call(this, r1(11));
        },
        function(t1, e1) {
            function r1(t1, e1) {
                if (!(this instanceof r1)) return new r1(t1, e1);
                this._bsontype = "Long", this.low_ = 0 | t1, this.high_ = 0 | e1;
            }
            r1.prototype.toInt = function() {
                return this.low_;
            }, r1.prototype.toNumber = function() {
                return this.high_ * r1.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
            }, r1.prototype.toJSON = function() {
                return this.toString();
            }, r1.prototype.toString = function(t1) {
                var e1 = t1 || 10;
                if (e1 < 2 || 36 < e1) throw Error("radix out of range: " + e1);
                if (this.isZero()) return "0";
                if (this.isNegative()) {
                    if (this.equals(r1.MIN_VALUE)) {
                        var n1 = r1.fromNumber(e1), o1 = this.div(n1), i1 = o1.multiply(n1).subtract(this);
                        return o1.toString(e1) + i1.toInt().toString(e1);
                    }
                    return "-" + this.negate().toString(e1);
                }
                var s1 = r1.fromNumber(Math.pow(e1, 6));
                i1 = this;
                for(var a1 = ""; !i1.isZero();){
                    var u1 = i1.div(s1), c1 = i1.subtract(u1.multiply(s1)).toInt().toString(e1);
                    if ((i1 = u1).isZero()) return c1 + a1;
                    for(; c1.length < 6;)c1 = "0" + c1;
                    a1 = "" + c1 + a1;
                }
            }, r1.prototype.getHighBits = function() {
                return this.high_;
            }, r1.prototype.getLowBits = function() {
                return this.low_;
            }, r1.prototype.getLowBitsUnsigned = function() {
                return this.low_ >= 0 ? this.low_ : r1.TWO_PWR_32_DBL_ + this.low_;
            }, r1.prototype.getNumBitsAbs = function() {
                if (this.isNegative()) return this.equals(r1.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
                for(var t1 = 0 !== this.high_ ? this.high_ : this.low_, e1 = 31; e1 > 0 && 0 == (t1 & 1 << e1); e1--);
                return 0 !== this.high_ ? e1 + 33 : e1 + 1;
            }, r1.prototype.isZero = function() {
                return 0 === this.high_ && 0 === this.low_;
            }, r1.prototype.isNegative = function() {
                return this.high_ < 0;
            }, r1.prototype.isOdd = function() {
                return 1 == (1 & this.low_);
            }, r1.prototype.equals = function(t1) {
                return this.high_ === t1.high_ && this.low_ === t1.low_;
            }, r1.prototype.notEquals = function(t1) {
                return this.high_ !== t1.high_ || this.low_ !== t1.low_;
            }, r1.prototype.lessThan = function(t1) {
                return this.compare(t1) < 0;
            }, r1.prototype.lessThanOrEqual = function(t1) {
                return this.compare(t1) <= 0;
            }, r1.prototype.greaterThan = function(t1) {
                return this.compare(t1) > 0;
            }, r1.prototype.greaterThanOrEqual = function(t1) {
                return this.compare(t1) >= 0;
            }, r1.prototype.compare = function(t1) {
                if (this.equals(t1)) return 0;
                var e1 = this.isNegative(), r1 = t1.isNegative();
                return e1 && !r1 ? -1 : !e1 && r1 ? 1 : this.subtract(t1).isNegative() ? -1 : 1;
            }, r1.prototype.negate = function() {
                return this.equals(r1.MIN_VALUE) ? r1.MIN_VALUE : this.not().add(r1.ONE);
            }, r1.prototype.add = function(t1) {
                var e1 = this.high_ >>> 16, n1 = 65535 & this.high_, o1 = this.low_ >>> 16, i1 = 65535 & this.low_, s1 = t1.high_ >>> 16, a1 = 65535 & t1.high_, u1 = t1.low_ >>> 16, c1 = 0, l1 = 0, f1 = 0, p1 = 0;
                return f1 += (p1 += i1 + (65535 & t1.low_)) >>> 16, p1 &= 65535, l1 += (f1 += o1 + u1) >>> 16, f1 &= 65535, c1 += (l1 += n1 + a1) >>> 16, l1 &= 65535, c1 += e1 + s1, c1 &= 65535, r1.fromBits(f1 << 16 | p1, c1 << 16 | l1);
            }, r1.prototype.subtract = function(t1) {
                return this.add(t1.negate());
            }, r1.prototype.multiply = function(t1) {
                if (this.isZero()) return r1.ZERO;
                if (t1.isZero()) return r1.ZERO;
                if (this.equals(r1.MIN_VALUE)) return t1.isOdd() ? r1.MIN_VALUE : r1.ZERO;
                if (t1.equals(r1.MIN_VALUE)) return this.isOdd() ? r1.MIN_VALUE : r1.ZERO;
                if (this.isNegative()) return t1.isNegative() ? this.negate().multiply(t1.negate()) : this.negate().multiply(t1).negate();
                if (t1.isNegative()) return this.multiply(t1.negate()).negate();
                if (this.lessThan(r1.TWO_PWR_24_) && t1.lessThan(r1.TWO_PWR_24_)) return r1.fromNumber(this.toNumber() * t1.toNumber());
                var e1 = this.high_ >>> 16, n1 = 65535 & this.high_, o1 = this.low_ >>> 16, i1 = 65535 & this.low_, s1 = t1.high_ >>> 16, a1 = 65535 & t1.high_, u1 = t1.low_ >>> 16, c1 = 65535 & t1.low_, l1 = 0, f1 = 0, p1 = 0, h1 = 0;
                return p1 += (h1 += i1 * c1) >>> 16, h1 &= 65535, f1 += (p1 += o1 * c1) >>> 16, p1 &= 65535, f1 += (p1 += i1 * u1) >>> 16, p1 &= 65535, l1 += (f1 += n1 * c1) >>> 16, f1 &= 65535, l1 += (f1 += o1 * u1) >>> 16, f1 &= 65535, l1 += (f1 += i1 * a1) >>> 16, f1 &= 65535, l1 += e1 * c1 + n1 * u1 + o1 * a1 + i1 * s1, l1 &= 65535, r1.fromBits(p1 << 16 | h1, l1 << 16 | f1);
            }, r1.prototype.div = function(t1) {
                if (t1.isZero()) throw Error("division by zero");
                if (this.isZero()) return r1.ZERO;
                if (this.equals(r1.MIN_VALUE)) {
                    if (t1.equals(r1.ONE) || t1.equals(r1.NEG_ONE)) return r1.MIN_VALUE;
                    if (t1.equals(r1.MIN_VALUE)) return r1.ONE;
                    var e1 = this.shiftRight(1).div(t1).shiftLeft(1);
                    if (e1.equals(r1.ZERO)) return t1.isNegative() ? r1.ONE : r1.NEG_ONE;
                    var n1 = this.subtract(t1.multiply(e1));
                    return e1.add(n1.div(t1));
                }
                if (t1.equals(r1.MIN_VALUE)) return r1.ZERO;
                if (this.isNegative()) return t1.isNegative() ? this.negate().div(t1.negate()) : this.negate().div(t1).negate();
                if (t1.isNegative()) return this.div(t1.negate()).negate();
                var o1 = r1.ZERO;
                for(n1 = this; n1.greaterThanOrEqual(t1);){
                    e1 = Math.max(1, Math.floor(n1.toNumber() / t1.toNumber()));
                    for(var i1 = Math.ceil(Math.log(e1) / Math.LN2), s1 = i1 <= 48 ? 1 : Math.pow(2, i1 - 48), a1 = r1.fromNumber(e1), u1 = a1.multiply(t1); u1.isNegative() || u1.greaterThan(n1);)e1 -= s1, u1 = (a1 = r1.fromNumber(e1)).multiply(t1);
                    a1.isZero() && (a1 = r1.ONE), o1 = o1.add(a1), n1 = n1.subtract(u1);
                }
                return o1;
            }, r1.prototype.modulo = function(t1) {
                return this.subtract(this.div(t1).multiply(t1));
            }, r1.prototype.not = function() {
                return r1.fromBits(~this.low_, ~this.high_);
            }, r1.prototype.and = function(t1) {
                return r1.fromBits(this.low_ & t1.low_, this.high_ & t1.high_);
            }, r1.prototype.or = function(t1) {
                return r1.fromBits(this.low_ | t1.low_, this.high_ | t1.high_);
            }, r1.prototype.xor = function(t1) {
                return r1.fromBits(this.low_ ^ t1.low_, this.high_ ^ t1.high_);
            }, r1.prototype.shiftLeft = function(t1) {
                if (0 === (t1 &= 63)) return this;
                var e1 = this.low_;
                if (t1 < 32) {
                    var n1 = this.high_;
                    return r1.fromBits(e1 << t1, n1 << t1 | e1 >>> 32 - t1);
                }
                return r1.fromBits(0, e1 << t1 - 32);
            }, r1.prototype.shiftRight = function(t1) {
                if (0 === (t1 &= 63)) return this;
                var e1 = this.high_;
                if (t1 < 32) {
                    var n1 = this.low_;
                    return r1.fromBits(n1 >>> t1 | e1 << 32 - t1, e1 >> t1);
                }
                return r1.fromBits(e1 >> t1 - 32, e1 >= 0 ? 0 : -1);
            }, r1.prototype.shiftRightUnsigned = function(t1) {
                if (0 === (t1 &= 63)) return this;
                var e1 = this.high_;
                if (t1 < 32) {
                    var n1 = this.low_;
                    return r1.fromBits(n1 >>> t1 | e1 << 32 - t1, e1 >>> t1);
                }
                return 32 === t1 ? r1.fromBits(e1, 0) : r1.fromBits(e1 >>> t1 - 32, 0);
            }, r1.fromInt = function(t1) {
                if (-128 <= t1 && t1 < 128) {
                    var e1 = r1.INT_CACHE_[t1];
                    if (e1) return e1;
                }
                var n1 = new r1(0 | t1, t1 < 0 ? -1 : 0);
                return -128 <= t1 && t1 < 128 && (r1.INT_CACHE_[t1] = n1), n1;
            }, r1.fromNumber = function(t1) {
                return isNaN(t1) || !isFinite(t1) ? r1.ZERO : t1 <= -r1.TWO_PWR_63_DBL_ ? r1.MIN_VALUE : t1 + 1 >= r1.TWO_PWR_63_DBL_ ? r1.MAX_VALUE : t1 < 0 ? r1.fromNumber(-t1).negate() : new r1(t1 % r1.TWO_PWR_32_DBL_ | 0, t1 / r1.TWO_PWR_32_DBL_ | 0);
            }, r1.fromBits = function(t1, e1) {
                return new r1(t1, e1);
            }, r1.fromString = function(t1, e1) {
                if (0 === t1.length) throw Error("number format error: empty string");
                var n1 = e1 || 10;
                if (n1 < 2 || 36 < n1) throw Error("radix out of range: " + n1);
                if ("-" === t1.charAt(0)) return r1.fromString(t1.substring(1), n1).negate();
                if (t1.indexOf("-") >= 0) throw Error('number format error: interior "-" character: ' + t1);
                for(var o1 = r1.fromNumber(Math.pow(n1, 8)), i1 = r1.ZERO, s1 = 0; s1 < t1.length; s1 += 8){
                    var a1 = Math.min(8, t1.length - s1), u1 = parseInt(t1.substring(s1, s1 + a1), n1);
                    if (a1 < 8) {
                        var c1 = r1.fromNumber(Math.pow(n1, a1));
                        i1 = i1.multiply(c1).add(r1.fromNumber(u1));
                    } else i1 = (i1 = i1.multiply(o1)).add(r1.fromNumber(u1));
                }
                return i1;
            }, r1.INT_CACHE_ = {}, r1.TWO_PWR_16_DBL_ = 65536, r1.TWO_PWR_24_DBL_ = 16777216, r1.TWO_PWR_32_DBL_ = r1.TWO_PWR_16_DBL_ * r1.TWO_PWR_16_DBL_, r1.TWO_PWR_31_DBL_ = r1.TWO_PWR_32_DBL_ / 2, r1.TWO_PWR_48_DBL_ = r1.TWO_PWR_32_DBL_ * r1.TWO_PWR_16_DBL_, r1.TWO_PWR_64_DBL_ = r1.TWO_PWR_32_DBL_ * r1.TWO_PWR_32_DBL_, r1.TWO_PWR_63_DBL_ = r1.TWO_PWR_64_DBL_ / 2, r1.ZERO = r1.fromInt(0), r1.ONE = r1.fromInt(1), r1.NEG_ONE = r1.fromInt(-1), r1.MAX_VALUE = r1.fromBits(-1, 2147483647), r1.MIN_VALUE = r1.fromBits(0, -2147483648), r1.TWO_PWR_24_ = r1.fromInt(16777216), t1.exports = r1, t1.exports.Long = r1;
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                var n1 = r1(67), o1 = Symbol.for("mongoose:emitted");
                t1.exports = function(t1, r1, i1, s1) {
                    return "function" == typeof t1 ? r1(function(r1) {
                        if (null == r1) t1.apply(this, arguments);
                        else {
                            null != i1 && i1.listeners("error").length > 0 && !r1[o1] && (r1[o1] = !0, i1.emit("error", r1));
                            try {
                                t1(r1);
                            } catch (r1) {
                                return e1.nextTick(function() {
                                    throw r1;
                                });
                            }
                        }
                    }) : new (s1 = s1 || n1.get())(function(t1, e1) {
                        r1(function(r1, n1) {
                            return null != r1 ? (null != i1 && i1.listeners("error").length > 0 && !r1[o1] && (r1[o1] = !0, i1.emit("error", r1)), e1(r1)) : arguments.length > 2 ? t1(Array.prototype.slice.call(arguments, 1)) : void t1(n1);
                        });
                    });
                };
            }).call(this, r1(8));
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ var n1 = r1(7), o1 = r1(51), i1 = r1(21);
            function s1(t1, e1) {
                if (e1 && e1.default) {
                    var r1 = e1.default;
                    Array.isArray(r1) && 0 === r1.length ? e1.default = Array : !e1.shared && i1(r1) && 0 === Object.keys(r1).length && (e1.default = function() {
                        return {};
                    });
                }
                n1.call(this, t1, e1, "Mixed"), this[o1.schemaMixedSymbol] = !0;
            }
            s1.schemaName = "Mixed", s1.defaultOptions = {}, /*!
 * Inherits from SchemaType.
 */ s1.prototype = Object.create(n1.prototype), s1.prototype.constructor = s1, s1.get = n1.get, s1.set = n1.set, s1.prototype.cast = function(t1) {
                return t1;
            }, s1.prototype.castForQuery = function(t1, e1) {
                return 2 === arguments.length ? e1 : t1;
            }, /*!
 * Module exports.
 */ t1.exports = s1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ var n1 = r1(61)(), o1 = r1(19).EventEmitter, i1 = r1(31), s1 = r1(50), a1 = r1(17).internalToObjectOptions, u1 = r1(3), c1 = r1(24), l1 = r1(4), f1 = r1(0).documentArrayParent, p1 = r1(0).validatorErrorSymbol;
            function h1(t1, e1, r1, o1, i1) {
                null != e1 && e1.isMongooseDocumentArray ? (this.__parentArray = e1, this[f1] = e1.$parent()) : (this.__parentArray = void 0, this[f1] = void 0), this.$setIndex(i1), this.$isDocumentArrayElement = !0, n1.call(this, t1, o1, r1);
                var s1 = this;
                this.on("isNew", function(t1) {
                    s1.isNew = t1;
                }), s1.on("save", function() {
                    s1.constructor.emit("save", s1);
                });
            }
            /*!
 * Inherit from Document
 */ for(var y1 in h1.prototype = Object.create(n1.prototype), h1.prototype.constructor = h1, o1.prototype)h1[y1] = o1.prototype[y1];
            h1.prototype.toBSON = function() {
                return this.toObject(a1);
            }, /*!
 * ignore
 */ h1.prototype.$setIndex = function(t1) {
                if (this.__index = t1, null != u1(this, "$__.validationError", null)) for(var e1 = 0, r1 = Object.keys(this.$__.validationError.errors); e1 < r1.length; e1++){
                    var n1 = r1[e1];
                    this.invalidate(n1, this.$__.validationError.errors[n1]);
                }
            }, h1.prototype.markModified = function(t1) {
                if (this.$__.activePaths.modify(t1), this.__parentArray) {
                    var e1 = this.__parentArray.$path() + ".0." + t1;
                    this.isNew && this.ownerDocument().isSelected(e1) ? this.__parentArray._markModified() : this.__parentArray._markModified(this, t1);
                }
            }, /*!
 * ignore
 */ h1.prototype.populate = function() {
                throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.arr[0].populate("path")`, use `doc.populate("arr.0.path")`');
            }, h1.prototype.save = function(t1, e1) {
                var r1 = this;
                return "function" == typeof t1 && (e1 = t1, t1 = {}), (t1 = t1 || {}).suppressWarning || console.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app."), c1(e1, function(t1) {
                    r1.$__save(t1);
                });
            }, h1.prototype.$__save = function(t1) {
                var e1 = this;
                return s1(function() {
                    return t1(null, e1);
                });
            }, /*!
 * no-op for hooks
 */ h1.prototype.$__remove = function(t1) {
                return t1(null, this);
            }, h1.prototype.remove = function(t1, e1) {
                if ("function" != typeof t1 || e1 || (e1 = t1, t1 = void 0), !this.__parentArray || t1 && t1.noop) return e1 && e1(null), this;
                var r1;
                if (!this.willRemove) {
                    if (!(r1 = this._doc._id)) throw new Error("For your own good, Mongoose does not know how to remove an EmbeddedDocument that has no _id");
                    this.__parentArray.pull({
                        _id: r1
                    }), this.willRemove = !0, /*!
 * Registers remove event listeners for triggering
 * on subdocuments.
 *
 * @param {EmbeddedDocument} sub
 * @api private
 */ function(t1) {
                        var e1 = t1.ownerDocument();
                        function r1() {
                            e1.removeListener("save", r1), e1.removeListener("remove", r1), t1.emit("remove", t1), t1.constructor.emit("remove", t1), e1 = t1 = null;
                        }
                        e1.on("save", r1), e1.on("remove", r1);
                    }(this);
                }
                return e1 && e1(null), this;
            }, h1.prototype.update = function() {
                throw new Error("The #update method is not available on EmbeddedDocuments");
            }, h1.prototype.inspect = function() {
                return this.toObject({
                    transform: !1,
                    virtuals: !1,
                    flattenDecimals: !1
                });
            }, l1.inspect.custom && /*!
  * Avoid Node deprecation warning DEP0079
  */ (h1.prototype[l1.inspect.custom] = h1.prototype.inspect), h1.prototype.invalidate = function(t1, e1, r1) {
                if (n1.prototype.invalidate.call(this, t1, e1, r1), !this[f1] || null == this.__index) {
                    if (e1[p1] || e1 instanceof i1) return this.ownerDocument().$__.validationError;
                    throw e1;
                }
                var o1 = this.__index, s1 = [
                    this.__parentArray.$path(),
                    o1,
                    t1
                ].join(".");
                return this[f1].invalidate(s1, e1, r1), this.ownerDocument().$__.validationError;
            }, h1.prototype.$markValid = function(t1) {
                if (this[f1]) {
                    var e1 = this.__index;
                    if (void 0 !== e1) {
                        var r1 = [
                            this.__parentArray.$path(),
                            e1,
                            t1
                        ].join(".");
                        this[f1].$markValid(r1);
                    }
                }
            }, /*!
 * ignore
 */ h1.prototype.$ignore = function(t1) {
                if (n1.prototype.$ignore.call(this, t1), this[f1]) {
                    var e1 = this.__index;
                    if (void 0 !== e1) {
                        var r1 = [
                            this.__parentArray.$path(),
                            e1,
                            t1
                        ].join(".");
                        this[f1].$ignore(r1);
                    }
                }
            }, h1.prototype.$isValid = function(t1) {
                return void 0 === this.__index || !this[f1] || !this[f1].$__.validationError || !this[f1].$__.validationError.errors[this.$__fullPath(t1)];
            }, h1.prototype.ownerDocument = function() {
                if (this.$__.ownerDocument) return this.$__.ownerDocument;
                var t1 = this[f1];
                if (!t1) return this;
                for(; t1[f1] || t1.$parent;)t1 = t1[f1] || t1.$parent;
                return this.$__.ownerDocument = t1, this.$__.ownerDocument;
            }, h1.prototype.$__fullPath = function(t1) {
                if (!this.$__.fullPath) {
                    var e1 = this;
                    if (!e1[f1]) return t1;
                    for(var r1 = []; e1[f1] || e1.$parent;)e1[f1] ? r1.unshift(e1.__parentArray.$path()) : r1.unshift(e1.$basePath), e1 = e1[f1] || e1.$parent;
                    this.$__.fullPath = r1.join("."), this.$__.ownerDocument || (this.$__.ownerDocument = e1);
                }
                return t1 ? this.$__.fullPath + "." + t1 : this.$__.fullPath;
            }, h1.prototype.parent = function() {
                return this[f1];
            }, h1.prototype.parentArray = function() {
                return this.__parentArray;
            }, /*!
 * Module exports.
 */ t1.exports = h1;
        },
        function(t1, e1, r1) {
            (function(e1) {
                if (void 0 !== e1) var n1 = r1(1).Buffer;
                var o1 = r1(16);
                function i1(t1, e1) {
                    if (!(this instanceof i1)) return new i1(t1, e1);
                    if (!(null == t1 || "string" == typeof t1 || n1.isBuffer(t1) || t1 instanceof Uint8Array || Array.isArray(t1))) throw new Error("only String, Buffer, Uint8Array or Array accepted");
                    if (this._bsontype = "Binary", t1 instanceof Number ? (this.sub_type = t1, this.position = 0) : (this.sub_type = null == e1 ? s1 : e1, this.position = 0), null == t1 || t1 instanceof Number) void 0 !== n1 ? this.buffer = o1.allocBuffer(i1.BUFFER_SIZE) : "undefined" != typeof Uint8Array ? this.buffer = new Uint8Array(new ArrayBuffer(i1.BUFFER_SIZE)) : this.buffer = new Array(i1.BUFFER_SIZE), this.position = 0;
                    else {
                        if ("string" == typeof t1) {
                            if (void 0 !== n1) this.buffer = o1.toBuffer(t1);
                            else {
                                if ("undefined" == typeof Uint8Array && "[object Array]" !== Object.prototype.toString.call(t1)) throw new Error("only String, Buffer, Uint8Array or Array accepted");
                                this.buffer = a1(t1);
                            }
                        } else this.buffer = t1;
                        this.position = t1.length;
                    }
                }
                i1.prototype.put = function(t1) {
                    if (null != t1.length && "number" != typeof t1 && 1 !== t1.length) throw new Error("only accepts single character String, Uint8Array or Array");
                    if ("number" != typeof t1 && t1 < 0 || t1 > 255) throw new Error("only accepts number in a valid unsigned byte range 0-255");
                    var e1 = null;
                    if (e1 = "string" == typeof t1 ? t1.charCodeAt(0) : null != t1.length ? t1[0] : t1, this.buffer.length > this.position) this.buffer[this.position++] = e1;
                    else if (void 0 !== n1 && n1.isBuffer(this.buffer)) {
                        var r1 = o1.allocBuffer(i1.BUFFER_SIZE + this.buffer.length);
                        this.buffer.copy(r1, 0, 0, this.buffer.length), this.buffer = r1, this.buffer[this.position++] = e1;
                    } else {
                        r1 = null, r1 = "[object Uint8Array]" === Object.prototype.toString.call(this.buffer) ? new Uint8Array(new ArrayBuffer(i1.BUFFER_SIZE + this.buffer.length)) : new Array(i1.BUFFER_SIZE + this.buffer.length);
                        for(var s1 = 0; s1 < this.buffer.length; s1++)r1[s1] = this.buffer[s1];
                        this.buffer = r1, this.buffer[this.position++] = e1;
                    }
                }, i1.prototype.write = function(t1, e1) {
                    if (e1 = "number" == typeof e1 ? e1 : this.position, this.buffer.length < e1 + t1.length) {
                        var r1 = null;
                        if (void 0 !== n1 && n1.isBuffer(this.buffer)) r1 = o1.allocBuffer(this.buffer.length + t1.length), this.buffer.copy(r1, 0, 0, this.buffer.length);
                        else if ("[object Uint8Array]" === Object.prototype.toString.call(this.buffer)) {
                            r1 = new Uint8Array(new ArrayBuffer(this.buffer.length + t1.length));
                            for(var i1 = 0; i1 < this.position; i1++)r1[i1] = this.buffer[i1];
                        }
                        this.buffer = r1;
                    }
                    if (void 0 !== n1 && n1.isBuffer(t1) && n1.isBuffer(this.buffer)) t1.copy(this.buffer, e1, 0, t1.length), this.position = e1 + t1.length > this.position ? e1 + t1.length : this.position;
                    else if (void 0 !== n1 && "string" == typeof t1 && n1.isBuffer(this.buffer)) this.buffer.write(t1, e1, "binary"), this.position = e1 + t1.length > this.position ? e1 + t1.length : this.position;
                    else if ("[object Uint8Array]" === Object.prototype.toString.call(t1) || "[object Array]" === Object.prototype.toString.call(t1) && "string" != typeof t1) {
                        for(i1 = 0; i1 < t1.length; i1++)this.buffer[e1++] = t1[i1];
                        this.position = e1 > this.position ? e1 : this.position;
                    } else if ("string" == typeof t1) {
                        for(i1 = 0; i1 < t1.length; i1++)this.buffer[e1++] = t1.charCodeAt(i1);
                        this.position = e1 > this.position ? e1 : this.position;
                    }
                }, i1.prototype.read = function(t1, e1) {
                    if (e1 = e1 && e1 > 0 ? e1 : this.position, this.buffer.slice) return this.buffer.slice(t1, t1 + e1);
                    for(var r1 = "undefined" != typeof Uint8Array ? new Uint8Array(new ArrayBuffer(e1)) : new Array(e1), n1 = 0; n1 < e1; n1++)r1[n1] = this.buffer[t1++];
                    return r1;
                }, i1.prototype.value = function(t1) {
                    if ((t1 = null != t1 && t1) && void 0 !== n1 && n1.isBuffer(this.buffer) && this.buffer.length === this.position) return this.buffer;
                    if (void 0 !== n1 && n1.isBuffer(this.buffer)) return t1 ? this.buffer.slice(0, this.position) : this.buffer.toString("binary", 0, this.position);
                    if (t1) {
                        if (null != this.buffer.slice) return this.buffer.slice(0, this.position);
                        for(var e1 = "[object Uint8Array]" === Object.prototype.toString.call(this.buffer) ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position), r1 = 0; r1 < this.position; r1++)e1[r1] = this.buffer[r1];
                        return e1;
                    }
                    return u1(this.buffer, 0, this.position);
                }, i1.prototype.length = function() {
                    return this.position;
                }, i1.prototype.toJSON = function() {
                    return null != this.buffer ? this.buffer.toString("base64") : "";
                }, i1.prototype.toString = function(t1) {
                    return null != this.buffer ? this.buffer.slice(0, this.position).toString(t1) : "";
                };
                var s1 = 0, a1 = function(t1) {
                    for(var e1 = "undefined" != typeof Uint8Array ? new Uint8Array(new ArrayBuffer(t1.length)) : new Array(t1.length), r1 = 0; r1 < t1.length; r1++)e1[r1] = t1.charCodeAt(r1);
                    return e1;
                }, u1 = function(t1, e1, r1) {
                    for(var n1 = "", o1 = e1; o1 < r1; o1++)n1 += String.fromCharCode(t1[o1]);
                    return n1;
                };
                i1.BUFFER_SIZE = 256, i1.SUBTYPE_DEFAULT = 0, i1.SUBTYPE_FUNCTION = 1, i1.SUBTYPE_BYTE_ARRAY = 2, i1.SUBTYPE_UUID_OLD = 3, i1.SUBTYPE_UUID = 4, i1.SUBTYPE_MD5 = 5, i1.SUBTYPE_USER_DEFINED = 128, t1.exports = i1, t1.exports.Binary = i1;
            }).call(this, r1(11));
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1, e1) {
                var r1;
                if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                    if (Array.isArray(t1) || (r1 = function(t1, e1) {
                        if (!t1) return;
                        if ("string" == typeof t1) return o1(t1, e1);
                        var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                        "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                        if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                        if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return o1(t1, e1);
                    }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                        r1 && (t1 = r1);
                        var n1 = 0, i1 = function() {};
                        return {
                            s: i1,
                            n: function() {
                                return n1 >= t1.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t1[n1++]
                                };
                            },
                            e: function(t1) {
                                throw t1;
                            },
                            f: i1
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var s1, a1 = !0, u1 = !1;
                return {
                    s: function() {
                        r1 = t1[Symbol.iterator]();
                    },
                    n: function() {
                        var t1 = r1.next();
                        return a1 = t1.done, t1;
                    },
                    e: function(t1) {
                        u1 = !0, s1 = t1;
                    },
                    f: function() {
                        try {
                            a1 || null == r1.return || r1.return();
                        } finally{
                            if (u1) throw s1;
                        }
                    }
                };
            }
            function o1(t1, e1) {
                (null == e1 || e1 > t1.length) && (e1 = t1.length);
                for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                return n1;
            }
            var i1 = r1(64), s1 = r1(20), a1 = r1(13), u1 = r1(47), c1 = r1(29), l1 = r1(65), f1 = r1(66), p1 = r1(21), h1 = r1(0), y1 = r1(2);
            /*!
 * Object clone with Mongoose natives support.
 *
 * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.
 *
 * Functions are never cloned.
 *
 * @param {Object} obj the object to clone
 * @param {Object} options
 * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.
 * @return {Object} the cloned object
 * @api private
 */ function d1(t1, e1, r1) {
                if (null == t1) return t1;
                if (Array.isArray(t1)) return function(t1, e1) {
                    var r1, o1 = [], i1 = n1(t1);
                    try {
                        for(i1.s(); !(r1 = i1.n()).done;){
                            var s1 = r1.value;
                            o1.push(d1(s1, e1, !0));
                        }
                    } catch (t1) {
                        i1.e(t1);
                    } finally{
                        i1.f();
                    }
                    return o1;
                }(t1, e1);
                if (c1(t1)) return e1 && e1._skipSingleNestedGetters && t1.$isSingleNested && (e1 = Object.assign({}, e1, {
                    getters: !1
                })), y1.isPOJO(t1) && null != t1.$__ && null != t1._doc ? t1._doc : e1 && e1.json && "function" == typeof t1.toJSON ? t1.toJSON(e1) : t1.toObject(e1);
                if (t1.constructor) switch(l1(t1.constructor)){
                    case "Object":
                        return m1(t1, e1, r1);
                    case "Date":
                        return new t1.constructor(+t1);
                    case "RegExp":
                        return i1(t1);
                }
                return t1 instanceof a1 ? new a1(t1.id) : f1(t1, "Decimal128") ? e1 && e1.flattenDecimals ? t1.toJSON() : s1.fromString(t1.toString()) : !t1.constructor && p1(t1) ? m1(t1, e1, r1) : t1[h1.schemaTypeSymbol] ? t1.clone() : e1 && e1.bson && "function" == typeof t1.toBSON ? t1 : null != t1.valueOf ? t1.valueOf() : m1(t1, e1, r1);
            }
            /*!
 * ignore
 */ function m1(t1, e1, r1) {
                var n1, o1 = e1 && e1.minimize, i1 = {};
                for(var s1 in t1)if (!u1.has(s1)) {
                    var a1 = d1(t1[s1], e1);
                    o1 && void 0 === a1 || (!1 === o1 && void 0 === a1 ? delete i1[s1] : (n1 || (n1 = !0), i1[s1] = a1));
                }
                return o1 && !r1 ? n1 && i1 : i1;
            }
            t1.exports = d1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Returns if `v` is a mongoose object that has a `toObject()` method we can use.
 *
 * This is for compatibility with libs like Date.js which do foolish things to Natives.
 *
 * @param {any} v
 * @api private
 */ t1.exports = function(t1) {
                return null != t1 && (null != t1.$__ || t1.isMongooseArray || t1.isMongooseBuffer || t1.$isMongooseMap);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = [
                "find",
                "findOne",
                "update",
                "updateMany",
                "updateOne",
                "replaceOne",
                "remove",
                "count",
                "distinct",
                "findAndModify",
                "aggregate",
                "findStream",
                "deleteOne",
                "deleteMany"
            ];
            function o1() {}
            for(var i1 = 0, s1 = n1.length; i1 < s1; ++i1){
                var a1 = n1[i1];
                o1.prototype[a1] = u1(a1);
            }
            function u1(t1) {
                return function() {
                    throw new Error("collection." + t1 + " not implemented");
                };
            }
            t1.exports = o1, o1.methods = n1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module requirements
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                for(var r1 = 0; r1 < e1.length; r1++){
                    var n1 = e1[r1];
                    n1.enumerable = n1.enumerable || !1, n1.configurable = !0, "value" in n1 && (n1.writable = !0), Object.defineProperty(t1, n1.key, n1);
                }
            }
            function i1(t1, e1) {
                return (i1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function s1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = u1(t1);
                    if (e1) {
                        var o1 = u1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return a1(this, r1);
                };
            }
            function a1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function u1(t1) {
                return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var c1 = r1(14), l1 = r1(4), f1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && i1(t1, e1);
                }(u1, t1);
                var e1, r1, n1, a1 = s1(u1);
                function u1(t1) {
                    var e1, r1;
                    return function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, u1), r1 = t1 && "model" === t1.constructor.name ? t1.constructor.modelName + " validation failed" : "Validation failed", (e1 = a1.call(this, r1)).errors = {}, e1._message = r1, t1 && (t1.errors = e1.errors), e1;
                }
                return e1 = u1, r1 = [
                    {
                        key: "toString",
                        value: function() {
                            return this.name + ": " + p1(this);
                        }
                    },
                    {
                        key: "inspect",
                        value: function() {
                            return Object.assign(new Error(this.message), this);
                        }
                    },
                    {
                        key: "addError",
                        value: function(t1, e1) {
                            this.errors[t1] = e1, this.message = this._message + ": " + p1(this);
                        }
                    }
                ], o1(e1.prototype, r1), n1 && o1(e1, n1), u1;
            }(c1);
            /*!
 * ignore
 */ function p1(t1) {
                for(var e1, r1 = Object.keys(t1.errors || {}), n1 = r1.length, o1 = [], i1 = 0; i1 < n1; ++i1)e1 = r1[i1], t1 !== t1.errors[e1] && o1.push(e1 + ": " + t1.errors[e1].message);
                return o1.join(", ");
            }
            /*!
 * Module exports
 */ l1.inspect.custom && /*!
  * Avoid Node deprecation warning DEP0079
  */ (f1.prototype[l1.inspect.custom] = f1.prototype.inspect), Object.defineProperty(f1.prototype, "toJSON", {
                enumerable: !1,
                writable: !1,
                configurable: !0,
                value: function() {
                    return Object.assign({}, this, {
                        message: this.message
                    });
                }
            }), Object.defineProperty(f1.prototype, "name", {
                value: "ValidationError"
            }), t1.exports = f1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                return (o1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function i1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = a1(t1);
                    if (e1) {
                        var o1 = a1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return s1(this, r1);
                };
            }
            function s1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function a1(t1) {
                return (a1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var u1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && o1(t1, e1);
                }(r1, t1);
                var e1 = i1(r1);
                function r1(t1, n1, o1) {
                    var i1;
                    return function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, r1), n1 = n1 || "Field `" + t1 + "` is not in schema and strict mode is set to throw.", (i1 = e1.call(this, n1)).isImmutableError = !!o1, i1.path = t1, i1;
                }
                return r1;
            }(r1(5));
            Object.defineProperty(u1.prototype, "name", {
                value: "StrictModeError"
            }), t1.exports = u1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module requirements.
 */ var n1 = r1(78);
            /*!
 * @ignore
 */ /*!
 * @ignore
 */ function o1(t1) {
                return n1.cast()(t1);
            }
            e1.castToNumber = o1, e1.castArraysOfNumbers = function t1(e1, r1) {
                e1.forEach(function(n1, i1) {
                    Array.isArray(n1) ? t1(n1, r1) : e1[i1] = o1.call(r1, n1);
                });
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
* returns discriminator by discriminatorMapping.value
*
* @param {Model} model
* @param {string} value
*/ t1.exports = function(t1, e1) {
                var r1 = null;
                if (!t1.discriminators) return r1;
                for(var n1 in t1.discriminators){
                    var o1 = t1.discriminators[n1];
                    if (o1.schema && o1.schema.discriminatorMapping && o1.schema.discriminatorMapping.value == e1) {
                        r1 = o1;
                        break;
                    }
                }
                return r1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(59), o1 = r1(23), i1 = r1(36), s1 = r1(37), a1 = r1(38), u1 = r1(39), c1 = r1(40), l1 = r1(60), f1 = r1(41), p1 = r1(42), h1 = r1(43), y1 = r1(44), d1 = r1(45), m1 = r1(27), _1 = r1(102), v1 = r1(103), g1 = r1(105), b1 = r1(16), w1 = b1.allocBuffer(17825792), O1 = function() {};
            O1.prototype.serialize = function(t1, e1) {
                var r1 = "boolean" == typeof (e1 = e1 || {}).checkKeys && e1.checkKeys, n1 = "boolean" == typeof e1.serializeFunctions && e1.serializeFunctions, o1 = "boolean" != typeof e1.ignoreUndefined || e1.ignoreUndefined, i1 = "number" == typeof e1.minInternalBufferSize ? e1.minInternalBufferSize : 17825792;
                w1.length < i1 && (w1 = b1.allocBuffer(i1));
                var s1 = v1(w1, t1, r1, 0, 0, n1, o1, []), a1 = b1.allocBuffer(s1);
                return w1.copy(a1, 0, 0, a1.length), a1;
            }, O1.prototype.serializeWithBufferAndIndex = function(t1, e1, r1) {
                var n1 = "boolean" == typeof (r1 = r1 || {}).checkKeys && r1.checkKeys, o1 = "boolean" == typeof r1.serializeFunctions && r1.serializeFunctions, i1 = "boolean" != typeof r1.ignoreUndefined || r1.ignoreUndefined, s1 = "number" == typeof r1.index ? r1.index : 0;
                return v1(e1, t1, n1, s1 || 0, 0, o1, i1) - 1;
            }, O1.prototype.deserialize = function(t1, e1) {
                return _1(t1, e1);
            }, O1.prototype.calculateObjectSize = function(t1, e1) {
                var r1 = "boolean" == typeof (e1 = e1 || {}).serializeFunctions && e1.serializeFunctions, n1 = "boolean" != typeof e1.ignoreUndefined || e1.ignoreUndefined;
                return g1(t1, r1, n1);
            }, O1.prototype.deserializeStream = function(t1, e1, r1, n1, o1, i1) {
                i1 = null != i1 ? i1 : {};
                for(var s1 = e1, a1 = 0; a1 < r1; a1++){
                    var u1 = t1[s1] | t1[s1 + 1] << 8 | t1[s1 + 2] << 16 | t1[s1 + 3] << 24;
                    i1.index = s1, n1[o1 + a1] = this.deserialize(t1, i1), s1 += u1;
                }
                return s1;
            }, O1.BSON_INT32_MAX = 2147483647, O1.BSON_INT32_MIN = -2147483648, O1.BSON_INT64_MAX = Math.pow(2, 63) - 1, O1.BSON_INT64_MIN = -Math.pow(2, 63), O1.JS_INT_MAX = 9007199254740992, O1.JS_INT_MIN = -9007199254740992, O1.BSON_DATA_NUMBER = 1, O1.BSON_DATA_STRING = 2, O1.BSON_DATA_OBJECT = 3, O1.BSON_DATA_ARRAY = 4, O1.BSON_DATA_BINARY = 5, O1.BSON_DATA_OID = 7, O1.BSON_DATA_BOOLEAN = 8, O1.BSON_DATA_DATE = 9, O1.BSON_DATA_NULL = 10, O1.BSON_DATA_REGEXP = 11, O1.BSON_DATA_CODE = 13, O1.BSON_DATA_SYMBOL = 14, O1.BSON_DATA_CODE_W_SCOPE = 15, O1.BSON_DATA_INT = 16, O1.BSON_DATA_TIMESTAMP = 17, O1.BSON_DATA_LONG = 18, O1.BSON_DATA_MIN_KEY = 255, O1.BSON_DATA_MAX_KEY = 127, O1.BSON_BINARY_SUBTYPE_DEFAULT = 0, O1.BSON_BINARY_SUBTYPE_FUNCTION = 1, O1.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2, O1.BSON_BINARY_SUBTYPE_UUID = 3, O1.BSON_BINARY_SUBTYPE_MD5 = 4, O1.BSON_BINARY_SUBTYPE_USER_DEFINED = 128, t1.exports = O1, t1.exports.Code = f1, t1.exports.Map = n1, t1.exports.Symbol = c1, t1.exports.BSON = O1, t1.exports.DBRef = d1, t1.exports.Binary = m1, t1.exports.ObjectID = a1, t1.exports.Long = o1, t1.exports.Timestamp = s1, t1.exports.Double = i1, t1.exports.Int32 = l1, t1.exports.MinKey = h1, t1.exports.MaxKey = y1, t1.exports.BSONRegExp = u1, t1.exports.Decimal128 = p1;
        },
        function(t1, e1) {
            function r1(t1) {
                if (!(this instanceof r1)) return new r1(t1);
                this._bsontype = "Double", this.value = t1;
            }
            r1.prototype.valueOf = function() {
                return this.value;
            }, r1.prototype.toJSON = function() {
                return this.value;
            }, t1.exports = r1, t1.exports.Double = r1;
        },
        function(t1, e1) {
            function r1(t1, e1) {
                if (!(this instanceof r1)) return new r1(t1, e1);
                this._bsontype = "Timestamp", this.low_ = 0 | t1, this.high_ = 0 | e1;
            }
            r1.prototype.toInt = function() {
                return this.low_;
            }, r1.prototype.toNumber = function() {
                return this.high_ * r1.TWO_PWR_32_DBL_ + this.getLowBitsUnsigned();
            }, r1.prototype.toJSON = function() {
                return this.toString();
            }, r1.prototype.toString = function(t1) {
                var e1 = t1 || 10;
                if (e1 < 2 || 36 < e1) throw Error("radix out of range: " + e1);
                if (this.isZero()) return "0";
                if (this.isNegative()) {
                    if (this.equals(r1.MIN_VALUE)) {
                        var n1 = r1.fromNumber(e1), o1 = this.div(n1), i1 = o1.multiply(n1).subtract(this);
                        return o1.toString(e1) + i1.toInt().toString(e1);
                    }
                    return "-" + this.negate().toString(e1);
                }
                var s1 = r1.fromNumber(Math.pow(e1, 6));
                i1 = this;
                for(var a1 = ""; !i1.isZero();){
                    var u1 = i1.div(s1), c1 = i1.subtract(u1.multiply(s1)).toInt().toString(e1);
                    if ((i1 = u1).isZero()) return c1 + a1;
                    for(; c1.length < 6;)c1 = "0" + c1;
                    a1 = "" + c1 + a1;
                }
            }, r1.prototype.getHighBits = function() {
                return this.high_;
            }, r1.prototype.getLowBits = function() {
                return this.low_;
            }, r1.prototype.getLowBitsUnsigned = function() {
                return this.low_ >= 0 ? this.low_ : r1.TWO_PWR_32_DBL_ + this.low_;
            }, r1.prototype.getNumBitsAbs = function() {
                if (this.isNegative()) return this.equals(r1.MIN_VALUE) ? 64 : this.negate().getNumBitsAbs();
                for(var t1 = 0 !== this.high_ ? this.high_ : this.low_, e1 = 31; e1 > 0 && 0 == (t1 & 1 << e1); e1--);
                return 0 !== this.high_ ? e1 + 33 : e1 + 1;
            }, r1.prototype.isZero = function() {
                return 0 === this.high_ && 0 === this.low_;
            }, r1.prototype.isNegative = function() {
                return this.high_ < 0;
            }, r1.prototype.isOdd = function() {
                return 1 == (1 & this.low_);
            }, r1.prototype.equals = function(t1) {
                return this.high_ === t1.high_ && this.low_ === t1.low_;
            }, r1.prototype.notEquals = function(t1) {
                return this.high_ !== t1.high_ || this.low_ !== t1.low_;
            }, r1.prototype.lessThan = function(t1) {
                return this.compare(t1) < 0;
            }, r1.prototype.lessThanOrEqual = function(t1) {
                return this.compare(t1) <= 0;
            }, r1.prototype.greaterThan = function(t1) {
                return this.compare(t1) > 0;
            }, r1.prototype.greaterThanOrEqual = function(t1) {
                return this.compare(t1) >= 0;
            }, r1.prototype.compare = function(t1) {
                if (this.equals(t1)) return 0;
                var e1 = this.isNegative(), r1 = t1.isNegative();
                return e1 && !r1 ? -1 : !e1 && r1 ? 1 : this.subtract(t1).isNegative() ? -1 : 1;
            }, r1.prototype.negate = function() {
                return this.equals(r1.MIN_VALUE) ? r1.MIN_VALUE : this.not().add(r1.ONE);
            }, r1.prototype.add = function(t1) {
                var e1 = this.high_ >>> 16, n1 = 65535 & this.high_, o1 = this.low_ >>> 16, i1 = 65535 & this.low_, s1 = t1.high_ >>> 16, a1 = 65535 & t1.high_, u1 = t1.low_ >>> 16, c1 = 0, l1 = 0, f1 = 0, p1 = 0;
                return f1 += (p1 += i1 + (65535 & t1.low_)) >>> 16, p1 &= 65535, l1 += (f1 += o1 + u1) >>> 16, f1 &= 65535, c1 += (l1 += n1 + a1) >>> 16, l1 &= 65535, c1 += e1 + s1, c1 &= 65535, r1.fromBits(f1 << 16 | p1, c1 << 16 | l1);
            }, r1.prototype.subtract = function(t1) {
                return this.add(t1.negate());
            }, r1.prototype.multiply = function(t1) {
                if (this.isZero()) return r1.ZERO;
                if (t1.isZero()) return r1.ZERO;
                if (this.equals(r1.MIN_VALUE)) return t1.isOdd() ? r1.MIN_VALUE : r1.ZERO;
                if (t1.equals(r1.MIN_VALUE)) return this.isOdd() ? r1.MIN_VALUE : r1.ZERO;
                if (this.isNegative()) return t1.isNegative() ? this.negate().multiply(t1.negate()) : this.negate().multiply(t1).negate();
                if (t1.isNegative()) return this.multiply(t1.negate()).negate();
                if (this.lessThan(r1.TWO_PWR_24_) && t1.lessThan(r1.TWO_PWR_24_)) return r1.fromNumber(this.toNumber() * t1.toNumber());
                var e1 = this.high_ >>> 16, n1 = 65535 & this.high_, o1 = this.low_ >>> 16, i1 = 65535 & this.low_, s1 = t1.high_ >>> 16, a1 = 65535 & t1.high_, u1 = t1.low_ >>> 16, c1 = 65535 & t1.low_, l1 = 0, f1 = 0, p1 = 0, h1 = 0;
                return p1 += (h1 += i1 * c1) >>> 16, h1 &= 65535, f1 += (p1 += o1 * c1) >>> 16, p1 &= 65535, f1 += (p1 += i1 * u1) >>> 16, p1 &= 65535, l1 += (f1 += n1 * c1) >>> 16, f1 &= 65535, l1 += (f1 += o1 * u1) >>> 16, f1 &= 65535, l1 += (f1 += i1 * a1) >>> 16, f1 &= 65535, l1 += e1 * c1 + n1 * u1 + o1 * a1 + i1 * s1, l1 &= 65535, r1.fromBits(p1 << 16 | h1, l1 << 16 | f1);
            }, r1.prototype.div = function(t1) {
                if (t1.isZero()) throw Error("division by zero");
                if (this.isZero()) return r1.ZERO;
                if (this.equals(r1.MIN_VALUE)) {
                    if (t1.equals(r1.ONE) || t1.equals(r1.NEG_ONE)) return r1.MIN_VALUE;
                    if (t1.equals(r1.MIN_VALUE)) return r1.ONE;
                    var e1 = this.shiftRight(1).div(t1).shiftLeft(1);
                    if (e1.equals(r1.ZERO)) return t1.isNegative() ? r1.ONE : r1.NEG_ONE;
                    var n1 = this.subtract(t1.multiply(e1));
                    return e1.add(n1.div(t1));
                }
                if (t1.equals(r1.MIN_VALUE)) return r1.ZERO;
                if (this.isNegative()) return t1.isNegative() ? this.negate().div(t1.negate()) : this.negate().div(t1).negate();
                if (t1.isNegative()) return this.div(t1.negate()).negate();
                var o1 = r1.ZERO;
                for(n1 = this; n1.greaterThanOrEqual(t1);){
                    e1 = Math.max(1, Math.floor(n1.toNumber() / t1.toNumber()));
                    for(var i1 = Math.ceil(Math.log(e1) / Math.LN2), s1 = i1 <= 48 ? 1 : Math.pow(2, i1 - 48), a1 = r1.fromNumber(e1), u1 = a1.multiply(t1); u1.isNegative() || u1.greaterThan(n1);)e1 -= s1, u1 = (a1 = r1.fromNumber(e1)).multiply(t1);
                    a1.isZero() && (a1 = r1.ONE), o1 = o1.add(a1), n1 = n1.subtract(u1);
                }
                return o1;
            }, r1.prototype.modulo = function(t1) {
                return this.subtract(this.div(t1).multiply(t1));
            }, r1.prototype.not = function() {
                return r1.fromBits(~this.low_, ~this.high_);
            }, r1.prototype.and = function(t1) {
                return r1.fromBits(this.low_ & t1.low_, this.high_ & t1.high_);
            }, r1.prototype.or = function(t1) {
                return r1.fromBits(this.low_ | t1.low_, this.high_ | t1.high_);
            }, r1.prototype.xor = function(t1) {
                return r1.fromBits(this.low_ ^ t1.low_, this.high_ ^ t1.high_);
            }, r1.prototype.shiftLeft = function(t1) {
                if (0 === (t1 &= 63)) return this;
                var e1 = this.low_;
                if (t1 < 32) {
                    var n1 = this.high_;
                    return r1.fromBits(e1 << t1, n1 << t1 | e1 >>> 32 - t1);
                }
                return r1.fromBits(0, e1 << t1 - 32);
            }, r1.prototype.shiftRight = function(t1) {
                if (0 === (t1 &= 63)) return this;
                var e1 = this.high_;
                if (t1 < 32) {
                    var n1 = this.low_;
                    return r1.fromBits(n1 >>> t1 | e1 << 32 - t1, e1 >> t1);
                }
                return r1.fromBits(e1 >> t1 - 32, e1 >= 0 ? 0 : -1);
            }, r1.prototype.shiftRightUnsigned = function(t1) {
                if (0 === (t1 &= 63)) return this;
                var e1 = this.high_;
                if (t1 < 32) {
                    var n1 = this.low_;
                    return r1.fromBits(n1 >>> t1 | e1 << 32 - t1, e1 >>> t1);
                }
                return 32 === t1 ? r1.fromBits(e1, 0) : r1.fromBits(e1 >>> t1 - 32, 0);
            }, r1.fromInt = function(t1) {
                if (-128 <= t1 && t1 < 128) {
                    var e1 = r1.INT_CACHE_[t1];
                    if (e1) return e1;
                }
                var n1 = new r1(0 | t1, t1 < 0 ? -1 : 0);
                return -128 <= t1 && t1 < 128 && (r1.INT_CACHE_[t1] = n1), n1;
            }, r1.fromNumber = function(t1) {
                return isNaN(t1) || !isFinite(t1) ? r1.ZERO : t1 <= -r1.TWO_PWR_63_DBL_ ? r1.MIN_VALUE : t1 + 1 >= r1.TWO_PWR_63_DBL_ ? r1.MAX_VALUE : t1 < 0 ? r1.fromNumber(-t1).negate() : new r1(t1 % r1.TWO_PWR_32_DBL_ | 0, t1 / r1.TWO_PWR_32_DBL_ | 0);
            }, r1.fromBits = function(t1, e1) {
                return new r1(t1, e1);
            }, r1.fromString = function(t1, e1) {
                if (0 === t1.length) throw Error("number format error: empty string");
                var n1 = e1 || 10;
                if (n1 < 2 || 36 < n1) throw Error("radix out of range: " + n1);
                if ("-" === t1.charAt(0)) return r1.fromString(t1.substring(1), n1).negate();
                if (t1.indexOf("-") >= 0) throw Error('number format error: interior "-" character: ' + t1);
                for(var o1 = r1.fromNumber(Math.pow(n1, 8)), i1 = r1.ZERO, s1 = 0; s1 < t1.length; s1 += 8){
                    var a1 = Math.min(8, t1.length - s1), u1 = parseInt(t1.substring(s1, s1 + a1), n1);
                    if (a1 < 8) {
                        var c1 = r1.fromNumber(Math.pow(n1, a1));
                        i1 = i1.multiply(c1).add(r1.fromNumber(u1));
                    } else i1 = (i1 = i1.multiply(o1)).add(r1.fromNumber(u1));
                }
                return i1;
            }, r1.INT_CACHE_ = {}, r1.TWO_PWR_16_DBL_ = 65536, r1.TWO_PWR_24_DBL_ = 16777216, r1.TWO_PWR_32_DBL_ = r1.TWO_PWR_16_DBL_ * r1.TWO_PWR_16_DBL_, r1.TWO_PWR_31_DBL_ = r1.TWO_PWR_32_DBL_ / 2, r1.TWO_PWR_48_DBL_ = r1.TWO_PWR_32_DBL_ * r1.TWO_PWR_16_DBL_, r1.TWO_PWR_64_DBL_ = r1.TWO_PWR_32_DBL_ * r1.TWO_PWR_32_DBL_, r1.TWO_PWR_63_DBL_ = r1.TWO_PWR_64_DBL_ / 2, r1.ZERO = r1.fromInt(0), r1.ONE = r1.fromInt(1), r1.NEG_ONE = r1.fromInt(-1), r1.MAX_VALUE = r1.fromBits(-1, 2147483647), r1.MIN_VALUE = r1.fromBits(0, -2147483648), r1.TWO_PWR_24_ = r1.fromInt(16777216), t1.exports = r1, t1.exports.Timestamp = r1;
        },
        function(t1, e1, r1) {
            (function(e1, n1) {
                var o1 = "inspect", i1 = r1(16), s1 = parseInt(16777215 * Math.random(), 10), a1 = new RegExp("^[0-9a-fA-F]{24}$");
                try {
                    if (e1 && e1.from) {
                        var u1 = !0;
                        o1 = r1(4).inspect.custom || "inspect";
                    }
                } catch (t1) {
                    u1 = !1;
                }
                for(var c1 = function t1(e1) {
                    if (e1 instanceof t1) return e1;
                    if (!(this instanceof t1)) return new t1(e1);
                    if (this._bsontype = "ObjectID", null == e1 || "number" == typeof e1) return this.id = this.generate(e1), void (t1.cacheHexString && (this.__id = this.toString("hex")));
                    var r1 = t1.isValid(e1);
                    if (!r1 && null != e1) throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
                    if (r1 && "string" == typeof e1 && 24 === e1.length && u1) return new t1(i1.toBuffer(e1, "hex"));
                    if (r1 && "string" == typeof e1 && 24 === e1.length) return t1.createFromHexString(e1);
                    if (null == e1 || 12 !== e1.length) {
                        if (null != e1 && "function" == typeof e1.toHexString) return e1;
                        throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
                    }
                    this.id = e1, t1.cacheHexString && (this.__id = this.toString("hex"));
                }, l1 = [], f1 = 0; f1 < 256; f1++)l1[f1] = (f1 <= 15 ? "0" : "") + f1.toString(16);
                c1.prototype.toHexString = function() {
                    if (c1.cacheHexString && this.__id) return this.__id;
                    var t1 = "";
                    if (!this.id || !this.id.length) throw new Error("invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [" + JSON.stringify(this.id) + "]");
                    if (this.id instanceof h1) return t1 = y1(this.id), c1.cacheHexString && (this.__id = t1), t1;
                    for(var e1 = 0; e1 < this.id.length; e1++)t1 += l1[this.id.charCodeAt(e1)];
                    return c1.cacheHexString && (this.__id = t1), t1;
                }, c1.prototype.get_inc = function() {
                    return c1.index = (c1.index + 1) % 16777215;
                }, c1.prototype.getInc = function() {
                    return this.get_inc();
                }, c1.prototype.generate = function(t1) {
                    "number" != typeof t1 && (t1 = ~~(Date.now() / 1e3));
                    var e1 = (void 0 === n1 || 1 === n1.pid ? Math.floor(1e5 * Math.random()) : n1.pid) % 65535, r1 = this.get_inc(), o1 = i1.allocBuffer(12);
                    return o1[3] = 255 & t1, o1[2] = t1 >> 8 & 255, o1[1] = t1 >> 16 & 255, o1[0] = t1 >> 24 & 255, o1[6] = 255 & s1, o1[5] = s1 >> 8 & 255, o1[4] = s1 >> 16 & 255, o1[8] = 255 & e1, o1[7] = e1 >> 8 & 255, o1[11] = 255 & r1, o1[10] = r1 >> 8 & 255, o1[9] = r1 >> 16 & 255, o1;
                }, c1.prototype.toString = function(t1) {
                    return this.id && this.id.copy ? this.id.toString("string" == typeof t1 ? t1 : "hex") : this.toHexString();
                }, c1.prototype[o1] = c1.prototype.toString, c1.prototype.toJSON = function() {
                    return this.toHexString();
                }, c1.prototype.equals = function(t1) {
                    return t1 instanceof c1 ? this.toString() === t1.toString() : "string" == typeof t1 && c1.isValid(t1) && 12 === t1.length && this.id instanceof h1 ? t1 === this.id.toString("binary") : "string" == typeof t1 && c1.isValid(t1) && 24 === t1.length ? t1.toLowerCase() === this.toHexString() : "string" == typeof t1 && c1.isValid(t1) && 12 === t1.length ? t1 === this.id : !(null == t1 || !(t1 instanceof c1 || t1.toHexString)) && t1.toHexString() === this.toHexString();
                }, c1.prototype.getTimestamp = function() {
                    var t1 = new Date, e1 = this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
                    return t1.setTime(1e3 * Math.floor(e1)), t1;
                }, c1.index = ~~(16777215 * Math.random()), c1.createPk = function() {
                    return new c1;
                }, c1.createFromTime = function(t1) {
                    var e1 = i1.toBuffer([
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]);
                    return e1[3] = 255 & t1, e1[2] = t1 >> 8 & 255, e1[1] = t1 >> 16 & 255, e1[0] = t1 >> 24 & 255, new c1(e1);
                };
                var p1 = [];
                for(f1 = 0; f1 < 10;)p1[48 + f1] = f1++;
                for(; f1 < 16;)p1[55 + f1] = p1[87 + f1] = f1++;
                var h1 = e1, y1 = function(t1) {
                    return t1.toString("hex");
                };
                c1.createFromHexString = function(t1) {
                    if (void 0 === t1 || null != t1 && 24 !== t1.length) throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");
                    if (u1) return new c1(i1.toBuffer(t1, "hex"));
                    for(var e1 = new h1(12), r1 = 0, n1 = 0; n1 < 24;)e1[r1++] = p1[t1.charCodeAt(n1++)] << 4 | p1[t1.charCodeAt(n1++)];
                    return new c1(e1);
                }, c1.isValid = function(t1) {
                    return null != t1 && ("number" == typeof t1 || ("string" == typeof t1 ? 12 === t1.length || 24 === t1.length && a1.test(t1) : t1 instanceof c1 || t1 instanceof h1 || "function" == typeof t1.toHexString && (t1.id instanceof h1 || "string" == typeof t1.id) && (12 === t1.id.length || 24 === t1.id.length && a1.test(t1.id))));
                }, Object.defineProperty(c1.prototype, "generationTime", {
                    enumerable: !0,
                    get: function() {
                        return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
                    },
                    set: function(t1) {
                        this.id[3] = 255 & t1, this.id[2] = t1 >> 8 & 255, this.id[1] = t1 >> 16 & 255, this.id[0] = t1 >> 24 & 255;
                    }
                }), t1.exports = c1, t1.exports.ObjectID = c1, t1.exports.ObjectId = c1;
            }).call(this, r1(1).Buffer, r1(8));
        },
        function(t1, e1) {
            function r1(t1, e1) {
                if (!(this instanceof r1)) return new r1;
                this._bsontype = "BSONRegExp", this.pattern = t1 || "", this.options = e1 || "";
                for(var n1 = 0; n1 < this.options.length; n1++)if ("i" !== this.options[n1] && "m" !== this.options[n1] && "x" !== this.options[n1] && "l" !== this.options[n1] && "s" !== this.options[n1] && "u" !== this.options[n1]) throw new Error("the regular expression options [" + this.options[n1] + "] is not supported");
            }
            t1.exports = r1, t1.exports.BSONRegExp = r1;
        },
        function(t1, e1, r1) {
            (function(e1) {
                var n1 = e1 && r1(4).inspect.custom || "inspect";
                function o1(t1) {
                    if (!(this instanceof o1)) return new o1(t1);
                    this._bsontype = "Symbol", this.value = t1;
                }
                o1.prototype.valueOf = function() {
                    return this.value;
                }, o1.prototype.toString = function() {
                    return this.value;
                }, o1.prototype[n1] = function() {
                    return this.value;
                }, o1.prototype.toJSON = function() {
                    return this.value;
                }, t1.exports = o1, t1.exports.Symbol = o1;
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1) {
            var r1 = function t1(e1, r1) {
                if (!(this instanceof t1)) return new t1(e1, r1);
                this._bsontype = "Code", this.code = e1, this.scope = r1;
            };
            r1.prototype.toJSON = function() {
                return {
                    scope: this.scope,
                    code: this.code
                };
            }, t1.exports = r1, t1.exports.Code = r1;
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(23), o1 = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/, i1 = /^(\+|-)?(Infinity|inf)$/i, s1 = /^(\+|-)?NaN$/i, a1 = 6176, u1 = [
                124,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ].reverse(), c1 = [
                248,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ].reverse(), l1 = [
                120,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
            ].reverse(), f1 = /^([-+])?(\d+)?$/, p1 = r1(16), h1 = function(t1) {
                return !isNaN(parseInt(t1, 10));
            }, y1 = function(t1) {
                var e1 = n1.fromNumber(1e9), r1 = n1.fromNumber(0), o1 = 0;
                if (!(t1.parts[0] || t1.parts[1] || t1.parts[2] || t1.parts[3])) return {
                    quotient: t1,
                    rem: r1
                };
                for(o1 = 0; o1 <= 3; o1++)r1 = (r1 = r1.shiftLeft(32)).add(new n1(t1.parts[o1], 0)), t1.parts[o1] = r1.div(e1).low_, r1 = r1.modulo(e1);
                return {
                    quotient: t1,
                    rem: r1
                };
            }, d1 = function(t1) {
                this._bsontype = "Decimal128", this.bytes = t1;
            };
            d1.fromString = function(t1) {
                var e1, r1 = !1, y1 = !1, m1 = !1, _1 = 0, v1 = 0, g1 = 0, b1 = 0, w1 = 0, O1 = [
                    0
                ], S1 = 0, A1 = 0, j1 = 0, E1 = 0, $1 = 0, P1 = 0, x1 = [
                    0,
                    0
                ], N1 = [
                    0,
                    0
                ], T1 = 0;
                if ((t1 = t1.trim()).length >= 7e3) throw new Error(t1 + " not a valid Decimal128 string");
                var k1 = t1.match(o1), C1 = t1.match(i1), D1 = t1.match(s1);
                if (!k1 && !C1 && !D1 || 0 === t1.length) throw new Error(t1 + " not a valid Decimal128 string");
                if (k1 && k1[4] && void 0 === k1[2]) throw new Error(t1 + " not a valid Decimal128 string");
                if ("+" !== t1[T1] && "-" !== t1[T1] || (r1 = "-" === t1[T1++]), !h1(t1[T1]) && "." !== t1[T1]) {
                    if ("i" === t1[T1] || "I" === t1[T1]) return new d1(p1.toBuffer(r1 ? c1 : l1));
                    if ("N" === t1[T1]) return new d1(p1.toBuffer(u1));
                }
                for(; h1(t1[T1]) || "." === t1[T1];)if ("." !== t1[T1]) S1 < 34 && ("0" !== t1[T1] || m1) && (m1 || (w1 = v1), m1 = !0, O1[A1++] = parseInt(t1[T1], 10), S1 += 1), m1 && (g1 += 1), y1 && (b1 += 1), v1 += 1, T1 += 1;
                else {
                    if (y1) return new d1(p1.toBuffer(u1));
                    y1 = !0, T1 += 1;
                }
                if (y1 && !v1) throw new Error(t1 + " not a valid Decimal128 string");
                if ("e" === t1[T1] || "E" === t1[T1]) {
                    var R1 = t1.substr(++T1).match(f1);
                    if (!R1 || !R1[2]) return new d1(p1.toBuffer(u1));
                    $1 = parseInt(R1[0], 10), T1 += R1[0].length;
                }
                if (t1[T1]) return new d1(p1.toBuffer(u1));
                if (j1 = 0, S1) {
                    if (E1 = S1 - 1, _1 = g1, 0 !== $1 && 1 !== _1) for(; "0" === t1[w1 + _1 - 1];)_1 -= 1;
                } else j1 = 0, E1 = 0, O1[0] = 0, g1 = 1, S1 = 1, _1 = 0;
                for($1 <= b1 && b1 - $1 > 16384 ? $1 = -6176 : $1 -= b1; $1 > 6111;){
                    if ((E1 += 1) - j1 > 34) {
                        var B1 = O1.join("");
                        if (B1.match(/^0+$/)) {
                            $1 = 6111;
                            break;
                        }
                        return new d1(p1.toBuffer(r1 ? c1 : l1));
                    }
                    $1 -= 1;
                }
                for(; $1 < -6176 || S1 < g1;){
                    if (0 === E1) {
                        $1 = -6176, _1 = 0;
                        break;
                    }
                    if (S1 < g1 ? g1 -= 1 : E1 -= 1, !($1 < 6111)) {
                        if ((B1 = O1.join("")).match(/^0+$/)) {
                            $1 = 6111;
                            break;
                        }
                        return new d1(p1.toBuffer(r1 ? c1 : l1));
                    }
                    $1 += 1;
                }
                if (E1 - j1 + 1 < _1 && "0" !== t1[_1]) {
                    var M1 = v1;
                    y1 && -6176 === $1 && (w1 += 1, M1 += 1);
                    var I1 = parseInt(t1[w1 + E1 + 1], 10), F1 = 0;
                    if (I1 >= 5 && (F1 = 1, 5 === I1)) {
                        for(F1 = O1[E1] % 2 == 1, P1 = w1 + E1 + 2; P1 < M1; P1++)if (parseInt(t1[P1], 10)) {
                            F1 = 1;
                            break;
                        }
                    }
                    if (F1) {
                        for(var L1 = E1; L1 >= 0 && ++O1[L1] > 9; L1--)if (O1[L1] = 0, 0 === L1) {
                            if (!($1 < 6111)) return new d1(p1.toBuffer(r1 ? c1 : l1));
                            $1 += 1, O1[L1] = 1;
                        }
                    }
                }
                if (x1 = n1.fromNumber(0), N1 = n1.fromNumber(0), 0 === _1) x1 = n1.fromNumber(0), N1 = n1.fromNumber(0);
                else if (E1 - j1 < 17) for(L1 = j1, N1 = n1.fromNumber(O1[L1++]), x1 = new n1(0, 0); L1 <= E1; L1++)N1 = (N1 = N1.multiply(n1.fromNumber(10))).add(n1.fromNumber(O1[L1]));
                else {
                    for(L1 = j1, x1 = n1.fromNumber(O1[L1++]); L1 <= E1 - 17; L1++)x1 = (x1 = x1.multiply(n1.fromNumber(10))).add(n1.fromNumber(O1[L1]));
                    for(N1 = n1.fromNumber(O1[L1++]); L1 <= E1; L1++)N1 = (N1 = N1.multiply(n1.fromNumber(10))).add(n1.fromNumber(O1[L1]));
                }
                var U1, V1, q1, W1, H1 = function(t1, e1) {
                    if (!t1 && !e1) return {
                        high: n1.fromNumber(0),
                        low: n1.fromNumber(0)
                    };
                    var r1 = t1.shiftRightUnsigned(32), o1 = new n1(t1.getLowBits(), 0), i1 = e1.shiftRightUnsigned(32), s1 = new n1(e1.getLowBits(), 0), a1 = r1.multiply(i1), u1 = r1.multiply(s1), c1 = o1.multiply(i1), l1 = o1.multiply(s1);
                    return a1 = a1.add(u1.shiftRightUnsigned(32)), u1 = new n1(u1.getLowBits(), 0).add(c1).add(l1.shiftRightUnsigned(32)), {
                        high: a1 = a1.add(u1.shiftRightUnsigned(32)),
                        low: l1 = u1.shiftLeft(32).add(new n1(l1.getLowBits(), 0))
                    };
                }(x1, n1.fromString("100000000000000000"));
                H1.low = H1.low.add(N1), U1 = H1.low, V1 = N1, q1 = U1.high_ >>> 0, W1 = V1.high_ >>> 0, (q1 < W1 || q1 === W1 && U1.low_ >>> 0 < V1.low_ >>> 0) && (H1.high = H1.high.add(n1.fromNumber(1))), e1 = $1 + a1;
                var Y1 = {
                    low: n1.fromNumber(0),
                    high: n1.fromNumber(0)
                };
                H1.high.shiftRightUnsigned(49).and(n1.fromNumber(1)).equals(n1.fromNumber) ? (Y1.high = Y1.high.or(n1.fromNumber(3).shiftLeft(61)), Y1.high = Y1.high.or(n1.fromNumber(e1).and(n1.fromNumber(16383).shiftLeft(47))), Y1.high = Y1.high.or(H1.high.and(n1.fromNumber(0x7fffffffffff)))) : (Y1.high = Y1.high.or(n1.fromNumber(16383 & e1).shiftLeft(49)), Y1.high = Y1.high.or(H1.high.and(n1.fromNumber(562949953421311)))), Y1.low = H1.low, r1 && (Y1.high = Y1.high.or(n1.fromString("9223372036854775808")));
                var K1 = p1.allocBuffer(16);
                return T1 = 0, K1[T1++] = 255 & Y1.low.low_, K1[T1++] = Y1.low.low_ >> 8 & 255, K1[T1++] = Y1.low.low_ >> 16 & 255, K1[T1++] = Y1.low.low_ >> 24 & 255, K1[T1++] = 255 & Y1.low.high_, K1[T1++] = Y1.low.high_ >> 8 & 255, K1[T1++] = Y1.low.high_ >> 16 & 255, K1[T1++] = Y1.low.high_ >> 24 & 255, K1[T1++] = 255 & Y1.high.low_, K1[T1++] = Y1.high.low_ >> 8 & 255, K1[T1++] = Y1.high.low_ >> 16 & 255, K1[T1++] = Y1.high.low_ >> 24 & 255, K1[T1++] = 255 & Y1.high.high_, K1[T1++] = Y1.high.high_ >> 8 & 255, K1[T1++] = Y1.high.high_ >> 16 & 255, K1[T1++] = Y1.high.high_ >> 24 & 255, new d1(K1);
            };
            a1 = 6176, d1.prototype.toString = function() {
                for(var t1, e1, r1, o1, i1, s1, u1 = 0, c1 = new Array(36), l1 = 0; l1 < c1.length; l1++)c1[l1] = 0;
                var f1, p1, h1, d1, m1, _1 = 0, v1 = !1, g1 = {
                    parts: new Array(4)
                }, b1 = [];
                _1 = 0;
                var w1 = this.bytes;
                if (o1 = w1[_1++] | w1[_1++] << 8 | w1[_1++] << 16 | w1[_1++] << 24, r1 = w1[_1++] | w1[_1++] << 8 | w1[_1++] << 16 | w1[_1++] << 24, e1 = w1[_1++] | w1[_1++] << 8 | w1[_1++] << 16 | w1[_1++] << 24, t1 = w1[_1++] | w1[_1++] << 8 | w1[_1++] << 16 | w1[_1++] << 24, _1 = 0, ({
                    low: new n1(o1, r1),
                    high: new n1(e1, t1)
                }).high.lessThan(n1.ZERO) && b1.push("-"), (i1 = t1 >> 26 & 31) >> 3 == 3) {
                    if (30 === i1) return b1.join("") + "Infinity";
                    if (31 === i1) return "NaN";
                    s1 = t1 >> 15 & 16383, h1 = 8 + (t1 >> 14 & 1);
                } else h1 = t1 >> 14 & 7, s1 = t1 >> 17 & 16383;
                if (f1 = s1 - a1, g1.parts[0] = (16383 & t1) + ((15 & h1) << 14), g1.parts[1] = e1, g1.parts[2] = r1, g1.parts[3] = o1, 0 === g1.parts[0] && 0 === g1.parts[1] && 0 === g1.parts[2] && 0 === g1.parts[3]) v1 = !0;
                else for(m1 = 3; m1 >= 0; m1--){
                    var O1 = 0, S1 = y1(g1);
                    if (g1 = S1.quotient, O1 = S1.rem.low_) for(d1 = 8; d1 >= 0; d1--)c1[9 * m1 + d1] = O1 % 10, O1 = Math.floor(O1 / 10);
                }
                if (v1) u1 = 1, c1[_1] = 0;
                else for(u1 = 36, l1 = 0; !c1[_1];)l1++, u1 -= 1, _1 += 1;
                if ((p1 = u1 - 1 + f1) >= 34 || p1 <= -7 || f1 > 0) {
                    for(b1.push(c1[_1++]), (u1 -= 1) && b1.push("."), l1 = 0; l1 < u1; l1++)b1.push(c1[_1++]);
                    b1.push("E"), p1 > 0 ? b1.push("+" + p1) : b1.push(p1);
                } else if (f1 >= 0) for(l1 = 0; l1 < u1; l1++)b1.push(c1[_1++]);
                else {
                    var A1 = u1 + f1;
                    if (A1 > 0) for(l1 = 0; l1 < A1; l1++)b1.push(c1[_1++]);
                    else b1.push("0");
                    for(b1.push("."); A1++ < 0;)b1.push("0");
                    for(l1 = 0; l1 < u1 - Math.max(A1 - 1, 0); l1++)b1.push(c1[_1++]);
                }
                return b1.join("");
            }, d1.prototype.toJSON = function() {
                return {
                    $numberDecimal: this.toString()
                };
            }, t1.exports = d1, t1.exports.Decimal128 = d1;
        },
        function(t1, e1) {
            function r1() {
                if (!(this instanceof r1)) return new r1;
                this._bsontype = "MinKey";
            }
            t1.exports = r1, t1.exports.MinKey = r1;
        },
        function(t1, e1) {
            function r1() {
                if (!(this instanceof r1)) return new r1;
                this._bsontype = "MaxKey";
            }
            t1.exports = r1, t1.exports.MaxKey = r1;
        },
        function(t1, e1) {
            function r1(t1, e1, n1) {
                if (!(this instanceof r1)) return new r1(t1, e1, n1);
                this._bsontype = "DBRef", this.namespace = t1, this.oid = e1, this.db = n1;
            }
            r1.prototype.toJSON = function() {
                return {
                    $ref: this.namespace,
                    $id: this.oid,
                    $db: null == this.db ? "" : this.db
                };
            }, t1.exports = r1, t1.exports.DBRef = r1;
        },
        function(t1, e1, r1) {
            t1.exports = r1(112);
        },
        function(t1, e1, r1) {
            "use strict";
            t1.exports = new Set([
                "__proto__",
                "constructor",
                "prototype"
            ]);
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(49);
            /*!
 * ignore
 */ t1.exports = function(t1) {
                var e1 = null != this ? this.path : null;
                return n1(t1, e1);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(12);
            /*!
 * Given a value, cast it to a boolean, or throw a `CastError` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @param {String} [path] optional the path to set on the CastError
 * @return {Boolean|null|undefined}
 * @throws {CastError} if `value` is not one of the allowed values
 * @api private
 */ t1.exports = function(e1, r1) {
                if (t1.exports.convertToTrue.has(e1)) return !0;
                if (t1.exports.convertToFalse.has(e1)) return !1;
                if (null == e1) return e1;
                throw new n1("boolean", e1, r1);
            }, t1.exports.convertToTrue = new Set([
                !0,
                "true",
                1,
                "1",
                "yes"
            ]), t1.exports.convertToFalse = new Set([
                !1,
                "false",
                0,
                "0",
                "no"
            ]);
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                /*!
 * Centralize this so we can more easily work around issues with people
 * stubbing out `process.nextTick()` in tests using sinon:
 * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time
 * See gh-6074
 */ t1.exports = function(t1) {
                    return e1.nextTick(t1);
                };
            }).call(this, r1(8));
        },
        function(t1, e1, r1) {
            "use strict";
            e1.schemaMixedSymbol = Symbol.for("mongoose:schema_mixed"), e1.builtInMiddleware = Symbol.for("mongoose:built-in-middleware");
        },
        function(t1, e1, r1) {
            "use strict";
            (function(n1) {
                /*!
 * Module dependencies.
 */ function o1(t1, e1, r1) {
                    return e1 in t1 ? Object.defineProperty(t1, e1, {
                        value: r1,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t1[e1] = r1, t1;
                }
                function i1(t1) {
                    return (i1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                function s1(t1, e1) {
                    var r1;
                    if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                        if (Array.isArray(t1) || (r1 = function(t1, e1) {
                            if (!t1) return;
                            if ("string" == typeof t1) return a1(t1, e1);
                            var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                            "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                            if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                            if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return a1(t1, e1);
                        }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                            r1 && (t1 = r1);
                            var n1 = 0, o1 = function() {};
                            return {
                                s: o1,
                                n: function() {
                                    return n1 >= t1.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t1[n1++]
                                    };
                                },
                                e: function(t1) {
                                    throw t1;
                                },
                                f: o1
                            };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }
                    var i1, s1 = !0, u1 = !1;
                    return {
                        s: function() {
                            r1 = t1[Symbol.iterator]();
                        },
                        n: function() {
                            var t1 = r1.next();
                            return s1 = t1.done, t1;
                        },
                        e: function(t1) {
                            u1 = !0, i1 = t1;
                        },
                        f: function() {
                            try {
                                s1 || null == r1.return || r1.return();
                            } finally{
                                if (u1) throw i1;
                            }
                        }
                    };
                }
                function a1(t1, e1) {
                    (null == e1 || e1 > t1.length) && (e1 = t1.length);
                    for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                    return n1;
                }
                var u1, c1 = r1(19).EventEmitter, l1 = r1(136), f1 = r1(14), p1 = r1(7), h1 = r1(9), y1 = r1(137), d1 = r1(53), m1 = r1(74), _1 = r1(0).arrayParentSymbol, v1 = r1(3), g1 = r1(138), b1 = r1(139), w1 = r1(46), O1 = r1(15).get().ReadPreference, S1 = r1(140), A1 = r1(4), j1 = r1(2), E1 = r1(144), $1 = r1(145).middlewareFunctions, P1 = r1(76).middlewareFunctions, x1 = $1.concat(P1).reduce(function(t1, e1) {
                    return t1.add(e1);
                }, new Set), N1 = 0;
                function T1(t1, e1) {
                    if (!(this instanceof T1)) return new T1(t1, e1);
                    if (this.obj = t1, this.paths = {}, this.aliases = {}, this.subpaths = {}, this.virtuals = {}, this.singleNestedPaths = {}, this.nested = {}, this.inherits = {}, this.callQueue = [], this._indexes = [], this.methods = {}, this.methodOptions = {}, this.statics = {}, this.tree = {}, this.query = {}, this.childSchemas = [], this.plugins = [], this.$id = ++N1, this.s = {
                        hooks: new l1
                    }, this.options = this.defaultOptions(e1), Array.isArray(t1)) {
                        var r1, n1 = s1(t1);
                        try {
                            for(n1.s(); !(r1 = n1.n()).done;){
                                var o1 = r1.value;
                                this.add(o1);
                            }
                        } catch (t1) {
                            n1.e(t1);
                        } finally{
                            n1.f();
                        }
                    } else t1 && this.add(t1);
                    var i1 = t1 && t1._id && j1.isObject(t1._id);
                    !this.paths._id && !this.options.noId && this.options._id && !i1 && m1(this), this.setupTimestamp(this.options.timestamps);
                }
                /*!
 * Create virtual properties with alias field
 */ /*!
 * Inherit from EventEmitter.
 */ T1.prototype = Object.create(c1.prototype), T1.prototype.constructor = T1, T1.prototype.instanceOfSchema = !0, /*!
 * ignore
 */ Object.defineProperty(T1.prototype, "$schemaType", {
                    configurable: !1,
                    enumerable: !1,
                    writable: !0
                }), Object.defineProperty(T1.prototype, "childSchemas", {
                    configurable: !1,
                    enumerable: !0,
                    writable: !0
                }), T1.prototype.obj, T1.prototype.paths, T1.prototype.tree, T1.prototype.clone = function() {
                    var t1 = this, e1 = new (null == this.base ? T1 : this.base.Schema)({}, this._userProvidedOptions);
                    return e1.base = this.base, e1.obj = this.obj, e1.options = j1.clone(this.options), e1.callQueue = this.callQueue.map(function(t1) {
                        return t1;
                    }), e1.methods = j1.clone(this.methods), e1.methodOptions = j1.clone(this.methodOptions), e1.statics = j1.clone(this.statics), e1.query = j1.clone(this.query), e1.plugins = Array.prototype.slice.call(this.plugins), e1._indexes = j1.clone(this._indexes), e1.s.hooks = this.s.hooks.clone(), e1.tree = j1.clone(this.tree), e1.paths = j1.clone(this.paths), e1.nested = j1.clone(this.nested), e1.subpaths = j1.clone(this.subpaths), e1.singleNestedPaths = j1.clone(this.singleNestedPaths), e1.childSchemas = /*!
 * ignore
 */ function(t1) {
                        for(var e1 = [], r1 = 0, n1 = Object.keys(t1.paths); r1 < n1.length; r1++){
                            var o1 = n1[r1], i1 = t1.paths[o1];
                            (i1.$isMongooseDocumentArray || i1.$isSingleNested) && e1.push({
                                schema: i1.schema,
                                model: i1.caster
                            });
                        }
                        return e1;
                    }(e1), e1.virtuals = j1.clone(this.virtuals), e1.$globalPluginsApplied = this.$globalPluginsApplied, e1.$isRootDiscriminator = this.$isRootDiscriminator, e1.$implicitlyCreated = this.$implicitlyCreated, null != this.discriminatorMapping && (e1.discriminatorMapping = Object.assign({}, this.discriminatorMapping)), null != this.discriminators && (e1.discriminators = Object.assign({}, this.discriminators)), e1.aliases = Object.assign({}, this.aliases), e1.on("init", function(e1) {
                        return t1.emit("init", e1);
                    }), e1;
                }, T1.prototype.pick = function(t1, e1) {
                    var r1 = new T1({}, e1 || this.options);
                    if (!Array.isArray(t1)) throw new f1('Schema#pick() only accepts an array argument, got "' + i1(t1) + '"');
                    var n1, a1 = s1(t1);
                    try {
                        for(a1.s(); !(n1 = a1.n()).done;){
                            var u1 = n1.value;
                            if (this.nested[u1]) r1.add(o1({}, u1, v1(this.tree, u1)));
                            else {
                                var c1 = this.path(u1);
                                if (null == c1) throw new f1("Path `" + u1 + "` is not in the schema");
                                r1.add(o1({}, u1, c1));
                            }
                        }
                    } catch (t1) {
                        a1.e(t1);
                    } finally{
                        a1.f();
                    }
                    return r1;
                }, T1.prototype.defaultOptions = function(t1) {
                    t1 && !1 === t1.safe && (t1.safe = {
                        w: 0
                    }), t1 && t1.safe && 0 === t1.safe.w && (t1.versionKey = !1), this._userProvidedOptions = null == t1 ? {} : j1.clone(t1);
                    var e1 = v1(this, "base.options", {});
                    if ((t1 = j1.options({
                        strict: !("strict" in e1) || e1.strict,
                        strictQuery: "strictQuery" in e1 && e1.strictQuery,
                        bufferCommands: !0,
                        capped: !1,
                        versionKey: "__v",
                        optimisticConcurrency: !1,
                        discriminatorKey: "__t",
                        minimize: !0,
                        autoIndex: null,
                        shardKey: null,
                        read: null,
                        validateBeforeSave: !0,
                        noId: !1,
                        _id: !0,
                        noVirtualId: !1,
                        id: !0,
                        typeKey: "type",
                        typePojoToMixed: !("typePojoToMixed" in e1) || e1.typePojoToMixed
                    }, j1.clone(t1))).read && (t1.read = O1(t1.read)), t1.optimisticConcurrency && !t1.versionKey) throw new f1("Must set `versionKey` if using `optimisticConcurrency`");
                    return t1;
                }, T1.prototype.add = function(t1, e1) {
                    if (t1 instanceof T1 || null != t1 && t1.instanceOfSchema) return b1(this, t1), this;
                    !1 === t1._id && null == e1 && (this.options._id = !1), e1 = e1 || "";
                    for(var r1 = 0, n1 = Object.keys(t1); r1 < n1.length; r1++){
                        var i1 = n1[r1], a1 = e1 + i1;
                        if (null == t1[i1]) throw new TypeError("Invalid value for schema path `" + a1 + '`, got value "' + t1[i1] + '"');
                        if ("_id" !== i1 || !1 !== t1[i1]) {
                            if (t1[i1] instanceof d1 || "VirtualType" === v1(t1[i1], "constructor.name", null)) this.virtual(t1[i1]);
                            else {
                                if (Array.isArray(t1[i1]) && 1 === t1[i1].length && null == t1[i1][0]) throw new TypeError("Invalid value for schema Array path `" + a1 + '`, got value "' + t1[i1][0] + '"');
                                if (j1.isPOJO(t1[i1]) || t1[i1] instanceof h1) {
                                    if (Object.keys(t1[i1]).length < 1) e1 && (this.nested[e1.substr(0, e1.length - 1)] = !0), this.path(a1, t1[i1]);
                                    else if (!t1[i1][this.options.typeKey] || "type" === this.options.typeKey && t1[i1].type.type) this.nested[a1] = !0, this.add(t1[i1], a1 + ".");
                                    else if (!this.options.typePojoToMixed && j1.isPOJO(t1[i1][this.options.typeKey])) {
                                        e1 && (this.nested[e1.substr(0, e1.length - 1)] = !0);
                                        var u1 = new T1(t1[i1][this.options.typeKey], {
                                            typePojoToMixed: !1
                                        }), c1 = Object.assign({}, t1[i1], o1({}, this.options.typeKey, u1));
                                        this.path(e1 + i1, c1);
                                    } else e1 && (this.nested[e1.substr(0, e1.length - 1)] = !0), this.path(e1 + i1, t1[i1]);
                                } else e1 && (this.nested[e1.substr(0, e1.length - 1)] = !0), this.path(e1 + i1, t1[i1]);
                            }
                        }
                    }
                    return function(t1, e1) {
                        var r1, n1 = s1(e1 = e1 || Object.keys(t1.paths));
                        try {
                            for(n1.s(); !(r1 = n1.n()).done;){
                                var o1 = r1.value, i1 = v1(t1.paths[o1], "options");
                                if (null != i1) {
                                    var a1 = t1.paths[o1].path, u1 = i1.alias;
                                    if (u1) {
                                        if ("string" != typeof u1) throw new Error("Invalid value for alias option on " + a1 + ", got " + u1);
                                        t1.aliases[u1] = a1, t1.virtual(u1).get(function(t1) {
                                            return function() {
                                                return "function" == typeof this.get ? this.get(t1) : this[t1];
                                            };
                                        }(a1)).set(function(t1) {
                                            return function(e1) {
                                                return this.$set(t1, e1);
                                            };
                                        }(a1));
                                    }
                                }
                            }
                        } catch (t1) {
                            n1.e(t1);
                        } finally{
                            n1.f();
                        }
                    }(this, Object.keys(t1).map(function(t1) {
                        return e1 ? e1 + t1 : t1;
                    })), this;
                }, T1.reserved = Object.create(null), T1.prototype.reserved = T1.reserved;
                var k1 = T1.reserved;
                /*!
 * ignore
 */ function C1(t1) {
                    return /\.\d+/.test(t1) ? t1.replace(/\.\d+\./g, ".$.").replace(/\.\d+$/, ".$") : t1;
                }
                /*!
 * ignore
 */ function D1(t1, e1) {
                    for(var r1 = 0, n1 = Object.keys(t1.paths); r1 < n1.length; r1++){
                        var o1 = n1[r1];
                        if (o1.includes(".$*")) {
                            if (new RegExp("^" + o1.replace(/\.\$\*/g, "\\.[^.]+") + "$").test(e1)) return t1.paths[o1];
                        }
                    }
                    return null;
                }
                /*!
 * ignore. Deprecated re: #6405
 */ function R1(t1, e1) {
                    var r1 = e1.split(/\.(\d+)\.|\.(\d+)$/).filter(Boolean);
                    if (r1.length < 2) return t1.paths.hasOwnProperty(r1[0]) ? t1.paths[r1[0]] : "adhocOrUndefined";
                    var n1 = t1.path(r1[0]), o1 = !1;
                    if (!n1) return "adhocOrUndefined";
                    for(var i1 = r1.length - 1, s1 = 1; s1 < r1.length; ++s1){
                        o1 = !1;
                        var a1 = r1[s1];
                        if (s1 === i1 && n1 && !/\D/.test(a1)) {
                            n1 = n1.$isMongooseDocumentArray ? n1.$embeddedSchemaType : n1 instanceof u1.Array ? n1.caster : void 0;
                            break;
                        }
                        if (/\D/.test(a1)) {
                            if (!n1 || !n1.schema) {
                                n1 = void 0;
                                break;
                            }
                            o1 = "nested" === n1.schema.pathType(a1), n1 = n1.schema.path(a1);
                        } else n1 instanceof u1.Array && s1 !== i1 && (n1 = n1.caster);
                    }
                    return t1.subpaths[e1] = n1, n1 ? "real" : o1 ? "nested" : "adhocOrUndefined";
                }
                /*!
 * ignore
 */ k1.prototype = k1.emit = k1.listeners = k1.on = k1.removeListener = k1.collection = k1.errors = k1.get = k1.init = k1.isModified = k1.isNew = k1.populated = k1.remove = k1.save = k1.schema = k1.toObject = k1.validate = 1, T1.prototype.path = function(t1, e1) {
                    var r1 = C1(t1);
                    if (void 0 === e1) {
                        var n1 = function(t1, e1, r1) {
                            if (t1.paths.hasOwnProperty(e1)) return t1.paths[e1];
                            if (t1.subpaths.hasOwnProperty(r1)) return t1.subpaths[r1];
                            if (t1.singleNestedPaths.hasOwnProperty(r1) && "object" === i1(t1.singleNestedPaths[r1])) return t1.singleNestedPaths[r1];
                            return null;
                        }(this, t1, r1);
                        if (null != n1) return n1;
                        var o1 = D1(this, t1);
                        return null != o1 ? o1 : null != (n1 = this.hasMixedParent(r1)) ? n1 : /\.\d+\.?.*$/.test(t1) ? function(t1, e1) {
                            return R1(t1, e1), t1.subpaths[e1];
                        }(this, t1) : void 0;
                    }
                    var a1 = t1.split(".")[0];
                    if (k1[a1]) throw new Error("`" + a1 + "` may not be used as a schema pathname");
                    "object" === i1(e1) && j1.hasUserDefinedProperty(e1, "ref") && E1(e1.ref, t1);
                    var u1, c1 = t1.split(/\./), l1 = c1.pop(), f1 = this.tree, h1 = "", y1 = s1(c1);
                    try {
                        for(y1.s(); !(u1 = y1.n()).done;){
                            var d1 = u1.value;
                            if (h1 = h1 += (h1.length > 0 ? "." : "") + d1, f1[d1] || (this.nested[h1] = !0, f1[d1] = {}), "object" !== i1(f1[d1])) {
                                var m1 = "Cannot set nested path `" + t1 + "`. Parent path `" + h1 + "` already set to type " + f1[d1].name + ".";
                                throw new Error(m1);
                            }
                            f1 = f1[d1];
                        }
                    } catch (t1) {
                        y1.e(t1);
                    } finally{
                        y1.f();
                    }
                    f1[l1] = j1.clone(e1), this.paths[t1] = this.interpretAsType(t1, e1, this.options);
                    var _1 = this.paths[t1];
                    if (_1.$isSchemaMap) {
                        var v1 = t1 + ".$*", g1 = {
                            type: {}
                        };
                        if (j1.hasUserDefinedProperty(e1, "of")) g1 = j1.isPOJO(e1.of) && Object.keys(e1.of).length > 0 && !j1.hasUserDefinedProperty(e1.of, this.options.typeKey) ? new T1(e1.of) : e1.of;
                        this.paths[v1] = this.interpretAsType(v1, g1, this.options), _1.$__schemaType = this.paths[v1];
                    }
                    if (_1.$isSingleNested) {
                        for(var b1 in _1.schema.paths)this.singleNestedPaths[t1 + "." + b1] = _1.schema.paths[b1];
                        for(var w1 in _1.schema.singleNestedPaths)this.singleNestedPaths[t1 + "." + w1] = _1.schema.singleNestedPaths[w1];
                        for(var O1 in _1.schema.subpaths)this.singleNestedPaths[t1 + "." + O1] = _1.schema.subpaths[O1];
                        for(var S1 in _1.schema.nested)this.singleNestedPaths[t1 + "." + S1] = "nested";
                        Object.defineProperty(_1.schema, "base", {
                            configurable: !0,
                            enumerable: !1,
                            writable: !1,
                            value: this.base
                        }), _1.caster.base = this.base, this.childSchemas.push({
                            schema: _1.schema,
                            model: _1.caster
                        });
                    } else _1.$isMongooseDocumentArray && (Object.defineProperty(_1.schema, "base", {
                        configurable: !0,
                        enumerable: !1,
                        writable: !1,
                        value: this.base
                    }), _1.casterConstructor.base = this.base, this.childSchemas.push({
                        schema: _1.schema,
                        model: _1.casterConstructor
                    }));
                    if (_1.$isMongooseArray && _1.caster instanceof p1) {
                        for(var A1 = t1, $1 = _1, P1 = []; $1.$isMongooseArray;)A1 += ".$", $1.$isMongooseDocumentArray ? ($1.$embeddedSchemaType._arrayPath = A1, $1 = $1.$embeddedSchemaType.clone()) : ($1.caster._arrayPath = A1, $1 = $1.caster.clone()), $1.path = A1, P1.push($1);
                        for(var x1 = 0, N1 = P1; x1 < N1.length; x1++){
                            var B1 = N1[x1];
                            this.subpaths[B1.path] = B1;
                        }
                    }
                    if (_1.$isMongooseDocumentArray) {
                        for(var M1 = 0, I1 = Object.keys(_1.schema.paths); M1 < I1.length; M1++){
                            var F1 = I1[M1];
                            this.subpaths[t1 + "." + F1] = _1.schema.paths[F1], _1.schema.paths[F1].$isUnderneathDocArray = !0;
                        }
                        for(var L1 = 0, U1 = Object.keys(_1.schema.subpaths); L1 < U1.length; L1++){
                            var V1 = U1[L1];
                            this.subpaths[t1 + "." + V1] = _1.schema.subpaths[V1], _1.schema.subpaths[V1].$isUnderneathDocArray = !0;
                        }
                        for(var q1 = 0, W1 = Object.keys(_1.schema.singleNestedPaths); q1 < W1.length; q1++){
                            var H1 = W1[q1];
                            "object" === i1(_1.schema.singleNestedPaths[r1]) && (this.subpaths[t1 + "." + H1] = _1.schema.singleNestedPaths[H1], _1.schema.singleNestedPaths[H1].$isUnderneathDocArray = !0);
                        }
                    }
                    return this;
                }, Object.defineProperty(T1.prototype, "base", {
                    configurable: !0,
                    enumerable: !1,
                    writable: !0,
                    value: null
                }), T1.prototype.interpretAsType = function(t1, e1, r1) {
                    if (e1 instanceof p1) {
                        var o1 = e1.clone();
                        return o1.path = t1, o1;
                    }
                    var s1 = null != this.base ? this.base.Schema.Types : T1.Types;
                    if (!(j1.isPOJO(e1) || e1 instanceof h1) && "Object" !== j1.getFunctionName(e1.constructor)) {
                        var a1 = e1;
                        (e1 = {})[r1.typeKey] = a1;
                    }
                    var u1, c1 = !e1[r1.typeKey] || "type" === r1.typeKey && e1.type.type ? {} : e1[r1.typeKey];
                    if (j1.isPOJO(c1) || "mixed" === c1) return new s1.Mixed(t1, e1);
                    if (Array.isArray(c1) || c1 === Array || "array" === c1 || c1 === s1.Array) {
                        var l1 = c1 === Array || "array" === c1 ? e1.cast || e1.of : c1[0];
                        if (l1 && l1.instanceOfSchema) return new s1.DocumentArray(t1, l1, e1);
                        if (l1 && l1[r1.typeKey] && l1[r1.typeKey].instanceOfSchema) return new s1.DocumentArray(t1, l1[r1.typeKey], e1, l1);
                        if (Array.isArray(l1)) return new s1.Array(t1, this.interpretAsType(t1, l1, r1), e1);
                        if ("string" == typeof l1) l1 = s1[l1.charAt(0).toUpperCase() + l1.substring(1)];
                        else if (l1 && (!l1[r1.typeKey] || "type" === r1.typeKey && l1.type.type) && j1.isPOJO(l1)) {
                            if (Object.keys(l1).length) {
                                var f1 = {
                                    minimize: r1.minimize
                                };
                                r1.typeKey && (f1.typeKey = r1.typeKey), r1.hasOwnProperty("strict") && (f1.strict = r1.strict), r1.hasOwnProperty("typePojoToMixed") && (f1.typePojoToMixed = r1.typePojoToMixed), this._userProvidedOptions.hasOwnProperty("_id") ? f1._id = this._userProvidedOptions._id : T1.Types.DocumentArray.defaultOptions && null != T1.Types.DocumentArray.defaultOptions._id && (f1._id = T1.Types.DocumentArray.defaultOptions._id);
                                var y1 = new T1(l1, f1);
                                return y1.$implicitlyCreated = !0, new s1.DocumentArray(t1, y1, e1);
                            }
                            return new s1.Array(t1, s1.Mixed, e1);
                        }
                        if (l1 && (u1 = "string" == typeof (c1 = !l1[r1.typeKey] || "type" === r1.typeKey && l1.type.type ? l1 : l1[r1.typeKey]) ? c1 : c1.schemaName || j1.getFunctionName(c1), !s1.hasOwnProperty(u1))) throw new TypeError("Invalid schema configuration: " + "`".concat(u1, "` is not a valid type within the array `").concat(t1, "`.") + "See http://bit.ly/mongoose-schematypes for a list of valid schema types.");
                        return new s1.Array(t1, l1 || s1.Mixed, e1, r1);
                    }
                    if (c1 && c1.instanceOfSchema) return new s1.Embedded(c1, t1, e1);
                    if ((u1 = n1.isBuffer(c1) ? "Buffer" : "function" == typeof c1 || "object" === i1(c1) ? c1.schemaName || j1.getFunctionName(c1) : null == c1 ? "" + c1 : c1.toString()) && (u1 = u1.charAt(0).toUpperCase() + u1.substring(1)), "ObjectID" === u1 && (u1 = "ObjectId"), null == s1[u1]) throw new TypeError("Invalid schema configuration: `".concat(u1, "` is not ") + "a valid type at path `".concat(t1, "`. See ") + "http://bit.ly/mongoose-schematypes for a list of valid schema types.");
                    return new s1[u1](t1, e1);
                }, T1.prototype.eachPath = function(t1) {
                    for(var e1 = Object.keys(this.paths), r1 = e1.length, n1 = 0; n1 < r1; ++n1)t1(e1[n1], this.paths[e1[n1]]);
                    return this;
                }, T1.prototype.requiredPaths = function(t1) {
                    if (this._requiredpaths && !t1) return this._requiredpaths;
                    for(var e1 = Object.keys(this.paths), r1 = e1.length, n1 = []; r1--;){
                        var o1 = e1[r1];
                        this.paths[o1].isRequired && n1.push(o1);
                    }
                    return this._requiredpaths = n1, this._requiredpaths;
                }, T1.prototype.indexedPaths = function() {
                    return this._indexedpaths || (this._indexedpaths = this.indexes()), this._indexedpaths;
                }, T1.prototype.pathType = function(t1) {
                    var e1 = C1(t1);
                    if (this.paths.hasOwnProperty(t1)) return "real";
                    if (this.virtuals.hasOwnProperty(t1)) return "virtual";
                    if (this.nested.hasOwnProperty(t1)) return "nested";
                    if (this.subpaths.hasOwnProperty(e1) || this.subpaths.hasOwnProperty(t1)) return "real";
                    var r1 = this.singleNestedPaths.hasOwnProperty(e1) || this.singleNestedPaths.hasOwnProperty(t1);
                    return r1 ? "nested" === r1 ? "nested" : "real" : null != D1(this, t1) ? "real" : /\.\d+\.|\.\d+$/.test(t1) ? R1(this, t1) : "adhocOrUndefined";
                }, T1.prototype.hasMixedParent = function(t1) {
                    var e1 = t1.split(/\./g);
                    t1 = "";
                    for(var r1 = 0; r1 < e1.length; ++r1)if ((t1 = r1 > 0 ? t1 + "." + e1[r1] : e1[r1]) in this.paths && this.paths[t1] instanceof u1.Mixed) return this.paths[t1];
                    return null;
                }, T1.prototype.setupTimestamp = function(t1) {
                    return S1(this, t1);
                }, T1.prototype.queue = function(t1, e1) {
                    return this.callQueue.push([
                        t1,
                        e1
                    ]), this;
                }, T1.prototype.pre = function(t1) {
                    if (t1 instanceof RegExp) {
                        var e1, r1 = Array.prototype.slice.call(arguments, 1), n1 = s1(x1);
                        try {
                            for(n1.s(); !(e1 = n1.n()).done;){
                                var o1 = e1.value;
                                t1.test(o1) && this.pre.apply(this, [
                                    o1
                                ].concat(r1));
                            }
                        } catch (t1) {
                            n1.e(t1);
                        } finally{
                            n1.f();
                        }
                        return this;
                    }
                    if (Array.isArray(t1)) {
                        var i1, a1 = Array.prototype.slice.call(arguments, 1), u1 = s1(t1);
                        try {
                            for(u1.s(); !(i1 = u1.n()).done;){
                                var c1 = i1.value;
                                this.pre.apply(this, [
                                    c1
                                ].concat(a1));
                            }
                        } catch (t1) {
                            u1.e(t1);
                        } finally{
                            u1.f();
                        }
                        return this;
                    }
                    return this.s.hooks.pre.apply(this.s.hooks, arguments), this;
                }, T1.prototype.post = function(t1) {
                    if (t1 instanceof RegExp) {
                        var e1, r1 = Array.prototype.slice.call(arguments, 1), n1 = s1(x1);
                        try {
                            for(n1.s(); !(e1 = n1.n()).done;){
                                var o1 = e1.value;
                                t1.test(o1) && this.post.apply(this, [
                                    o1
                                ].concat(r1));
                            }
                        } catch (t1) {
                            n1.e(t1);
                        } finally{
                            n1.f();
                        }
                        return this;
                    }
                    if (Array.isArray(t1)) {
                        var i1, a1 = Array.prototype.slice.call(arguments, 1), u1 = s1(t1);
                        try {
                            for(u1.s(); !(i1 = u1.n()).done;){
                                var c1 = i1.value;
                                this.post.apply(this, [
                                    c1
                                ].concat(a1));
                            }
                        } catch (t1) {
                            u1.e(t1);
                        } finally{
                            u1.f();
                        }
                        return this;
                    }
                    return this.s.hooks.post.apply(this.s.hooks, arguments), this;
                }, T1.prototype.plugin = function(t1, e1) {
                    if ("function" != typeof t1) throw new Error('First param to `schema.plugin()` must be a function, got "' + i1(t1) + '"');
                    if (e1 && e1.deduplicate) {
                        var r1, n1 = s1(this.plugins);
                        try {
                            for(n1.s(); !(r1 = n1.n()).done;){
                                if (r1.value.fn === t1) return this;
                            }
                        } catch (t1) {
                            n1.e(t1);
                        } finally{
                            n1.f();
                        }
                    }
                    return this.plugins.push({
                        fn: t1,
                        opts: e1
                    }), t1(this, e1), this;
                }, T1.prototype.method = function(t1, e1, r1) {
                    if ("string" != typeof t1) for(var n1 in t1)this.methods[n1] = t1[n1], this.methodOptions[n1] = j1.clone(r1);
                    else this.methods[t1] = e1, this.methodOptions[t1] = j1.clone(r1);
                    return this;
                }, T1.prototype.static = function(t1, e1) {
                    if ("string" != typeof t1) for(var r1 in t1)this.statics[r1] = t1[r1];
                    else this.statics[t1] = e1;
                    return this;
                }, T1.prototype.index = function(t1, e1) {
                    return t1 || (t1 = {}), e1 || (e1 = {}), e1.expires && j1.expires(e1), this._indexes.push([
                        t1,
                        e1
                    ]), this;
                }, T1.prototype.set = function(t1, e1, r1) {
                    if (1 === arguments.length) return this.options[t1];
                    switch(t1){
                        case "read":
                            this.options[t1] = O1(e1, r1), this._userProvidedOptions[t1] = this.options[t1];
                            break;
                        case "safe":
                            B1(this.options, e1), this._userProvidedOptions[t1] = this.options[t1];
                            break;
                        case "timestamps":
                            this.setupTimestamp(e1), this.options[t1] = e1, this._userProvidedOptions[t1] = this.options[t1];
                            break;
                        case "_id":
                            this.options[t1] = e1, this._userProvidedOptions[t1] = this.options[t1], e1 && !this.paths._id ? m1(this) : !e1 && null != this.paths._id && this.paths._id.auto && this.remove("_id");
                            break;
                        default:
                            this.options[t1] = e1, this._userProvidedOptions[t1] = this.options[t1];
                    }
                    return this;
                };
                /*!
 * ignore
 */ var B1 = A1.deprecate(function(t1, e1) {
                    t1.safe = !1 === e1 ? {
                        w: 0
                    } : e1;
                }, "Mongoose: The `safe` option for schemas is deprecated. Use the `writeConcern` option instead: http://bit.ly/mongoose-write-concern");
                T1.prototype.get = function(t1) {
                    return this.options[t1];
                };
                var M1 = "2d 2dsphere hashed text".split(" ");
                /*!
 * ignore
 */ function I1(t1, e1) {
                    var r1, n1 = e1.split("."), o1 = n1.pop(), i1 = t1.tree, a1 = s1(n1);
                    try {
                        for(a1.s(); !(r1 = a1.n()).done;)i1 = i1[r1.value];
                    } catch (t1) {
                        a1.e(t1);
                    } finally{
                        a1.f();
                    }
                    delete i1[o1];
                }
                /*!
 * ignore
 */ function F1(t1) {
                    return t1.startsWith("$[") && t1.endsWith("]");
                }
                /*!
 * Module exports.
 */ Object.defineProperty(T1, "indexTypes", {
                    get: function() {
                        return M1;
                    },
                    set: function() {
                        throw new Error("Cannot overwrite Schema.indexTypes");
                    }
                }), T1.prototype.indexes = function() {
                    return g1(this);
                }, T1.prototype.virtual = function(t1, e1) {
                    var r1 = this;
                    if (t1 instanceof d1 || null != t1 && "VirtualType" === t1.constructor.name) return this.virtual(t1.path, t1.options);
                    if (e1 = new y1(e1), j1.hasUserDefinedProperty(e1, [
                        "ref",
                        "refPath"
                    ])) {
                        if (null == e1.localField) throw new Error("Reference virtuals require `localField` option");
                        if (null == e1.foreignField) throw new Error("Reference virtuals require `foreignField` option");
                        this.pre("init", function(r1) {
                            if (w1.has(t1, r1)) {
                                var n1 = w1.get(t1, r1);
                                this.$$populatedVirtuals || (this.$$populatedVirtuals = {}), e1.justOne || e1.count ? this.$$populatedVirtuals[t1] = Array.isArray(n1) ? n1[0] : n1 : this.$$populatedVirtuals[t1] = Array.isArray(n1) ? n1 : null == n1 ? [] : [
                                    n1
                                ], w1.unset(t1, r1);
                            }
                        });
                        var n1 = this.virtual(t1);
                        return n1.options = e1, n1.get(function(e1) {
                            return this.$$populatedVirtuals && this.$$populatedVirtuals.hasOwnProperty(t1) ? this.$$populatedVirtuals[t1] : null != e1 ? e1 : void 0;
                        }).set(function(r1) {
                            this.$$populatedVirtuals || (this.$$populatedVirtuals = {}), e1.justOne || e1.count ? (this.$$populatedVirtuals[t1] = Array.isArray(r1) ? r1[0] : r1, "object" !== i1(this.$$populatedVirtuals[t1]) && (this.$$populatedVirtuals[t1] = e1.count ? r1 : null)) : (this.$$populatedVirtuals[t1] = Array.isArray(r1) ? r1 : null == r1 ? [] : [
                                r1
                            ], this.$$populatedVirtuals[t1] = this.$$populatedVirtuals[t1].filter(function(t1) {
                                return t1 && "object" === i1(t1);
                            }));
                        });
                    }
                    var o1 = this.virtuals, s1 = t1.split(".");
                    if ("real" === this.pathType(t1)) throw new Error('Virtual path "' + t1 + '" conflicts with a real path in the schema');
                    o1[t1] = s1.reduce(function(r1, n1, o1) {
                        return r1[n1] || (r1[n1] = o1 === s1.length - 1 ? new d1(e1, t1) : {}), r1[n1];
                    }, this.tree);
                    for(var a1 = s1[0], u1 = 0; u1 < s1.length - 1; ++u1){
                        if (null != this.paths[a1] && this.paths[a1].$isMongooseDocumentArray) {
                            if ("break" === function() {
                                var t1 = s1.slice(u1 + 1).join(".");
                                return r1.paths[a1].schema.virtual(t1).get(function(e1, r1, n1) {
                                    var o1 = n1.__parentArray[_1], i1 = a1 + "." + n1.__index + "." + t1;
                                    return o1.get(i1);
                                }), "break";
                            }()) break;
                        }
                        a1 += "." + s1[u1 + 1];
                    }
                    return o1[t1];
                }, T1.prototype.virtualpath = function(t1) {
                    return this.virtuals.hasOwnProperty(t1) ? this.virtuals[t1] : null;
                }, T1.prototype.remove = function(t1) {
                    return "string" == typeof t1 && (t1 = [
                        t1
                    ]), Array.isArray(t1) && t1.forEach(function(t1) {
                        if (null != this.path(t1) || this.nested[t1]) {
                            if (this.nested[t1]) {
                                var e1, r1 = s1(Object.keys(this.paths).concat(Object.keys(this.nested)));
                                try {
                                    for(r1.s(); !(e1 = r1.n()).done;){
                                        var n1 = e1.value;
                                        n1.startsWith(t1 + ".") && (delete this.paths[n1], delete this.nested[n1], I1(this, n1));
                                    }
                                } catch (t1) {
                                    r1.e(t1);
                                } finally{
                                    r1.f();
                                }
                                return delete this.nested[t1], void I1(this, t1);
                            }
                            delete this.paths[t1], I1(this, t1);
                        }
                    }, this), this;
                }, T1.prototype.loadClass = function(t1, e1) {
                    return t1 === Object.prototype || t1 === Function.prototype || t1.prototype.hasOwnProperty("$isMongooseModelPrototype") || (this.loadClass(Object.getPrototypeOf(t1)), e1 || Object.getOwnPropertyNames(t1).forEach(function(e1) {
                        if (!e1.match(/^(length|name|prototype)$/)) {
                            var r1 = Object.getOwnPropertyDescriptor(t1, e1);
                            "function" == typeof r1.value && this.static(e1, r1.value);
                        }
                    }, this), Object.getOwnPropertyNames(t1.prototype).forEach(function(r1) {
                        if (!r1.match(/^(constructor)$/)) {
                            var n1 = Object.getOwnPropertyDescriptor(t1.prototype, r1);
                            e1 || "function" == typeof n1.value && this.method(r1, n1.value), "function" == typeof n1.get && this.virtual(r1).get(n1.get), "function" == typeof n1.set && this.virtual(r1).set(n1.set);
                        }
                    }, this)), this;
                }, /*!
 * ignore
 */ T1.prototype._getSchema = function(t1) {
                    var e1 = this.path(t1), r1 = [];
                    if (e1) return e1.$fullPath = t1, e1;
                    for(var n1 = t1.split("."), o1 = 0; o1 < n1.length; ++o1)("$" === n1[o1] || F1(n1[o1])) && (n1[o1] = "0");
                    return function t1(e1, n1) {
                        for(var o1, i1, s1 = e1.length + 1; s1--;)if (i1 = e1.slice(0, s1).join("."), o1 = n1.path(i1)) {
                            if (r1.push(i1), o1.caster) {
                                if (o1.caster instanceof u1.Mixed) return o1.caster.$fullPath = r1.join("."), o1.caster;
                                if (s1 !== e1.length && o1.schema) {
                                    var a1 = void 0;
                                    return "$" === e1[s1] || F1(e1[s1]) ? s1 + 1 === e1.length ? o1 : ((a1 = t1(e1.slice(s1 + 1), o1.schema)) && (a1.$isUnderneathDocArray = a1.$isUnderneathDocArray || !o1.schema.$isSingleNested), a1) : ((a1 = t1(e1.slice(s1), o1.schema)) && (a1.$isUnderneathDocArray = a1.$isUnderneathDocArray || !o1.schema.$isSingleNested), a1);
                                }
                            } else if (o1.$isSchemaMap) return s1 + 1 >= e1.length ? o1.$__schemaType : t1(e1.slice(s1 + 1), o1.$__schemaType.schema);
                            return o1.$fullPath = r1.join("."), o1;
                        }
                    }(n1, this);
                }, /*!
 * ignore
 */ T1.prototype._getPathType = function(t1) {
                    if (this.path(t1)) return "real";
                    return function t1(e1, r1) {
                        for(var n1, o1, i1 = e1.length + 1; i1--;){
                            if (o1 = e1.slice(0, i1).join("."), n1 = r1.path(o1)) return n1.caster ? n1.caster instanceof u1.Mixed ? {
                                schema: n1,
                                pathType: "mixed"
                            } : i1 !== e1.length && n1.schema ? "$" === e1[i1] || F1(e1[i1]) ? i1 === e1.length - 1 ? {
                                schema: n1,
                                pathType: "nested"
                            } : t1(e1.slice(i1 + 1), n1.schema) : t1(e1.slice(i1), n1.schema) : {
                                schema: n1,
                                pathType: n1.$isSingleNested ? "nested" : "array"
                            } : {
                                schema: n1,
                                pathType: "real"
                            };
                            if (i1 === e1.length && r1.nested[o1]) return {
                                schema: r1,
                                pathType: "nested"
                            };
                        }
                        return {
                            schema: n1 || r1,
                            pathType: "undefined"
                        };
                    }(t1.split("."), this);
                }, t1.exports = e1 = T1, T1.Types = u1 = r1(54), /*!
 * ignore
 */ e1.ObjectId = u1.ObjectId;
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1, e1) {
                this.path = e1, this.getters = [], this.setters = [], this.options = Object.assign({}, t1);
            }
            n1.prototype._applyDefaultGetters = function() {
                if (!(this.getters.length > 0 || this.setters.length > 0)) {
                    var t1 = "$" + this.path;
                    this.getters.push(function() {
                        return this[t1];
                    }), this.setters.push(function(e1) {
                        this[t1] = e1;
                    });
                }
            }, /*!
 * ignore
 */ n1.prototype.clone = function() {
                var t1 = new n1(this.options, this.path);
                return t1.getters = [].concat(this.getters), t1.setters = [].concat(this.setters), t1;
            }, n1.prototype.get = function(t1) {
                return this.getters.push(t1), this;
            }, n1.prototype.set = function(t1) {
                return this.setters.push(t1), this;
            }, n1.prototype.applyGetters = function(t1, e1) {
                for(var r1 = t1, n1 = this.getters.length - 1; n1 >= 0; n1--)r1 = this.getters[n1].call(e1, r1, this, e1);
                return r1;
            }, n1.prototype.applySetters = function(t1, e1) {
                for(var r1 = t1, n1 = this.setters.length - 1; n1 >= 0; n1--)r1 = this.setters[n1].call(e1, r1, this, e1);
                return r1;
            }, /*!
 * exports
 */ t1.exports = n1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module exports.
 */ e1.String = r1(146), e1.Number = r1(78), e1.Boolean = r1(150), e1.DocumentArray = r1(151), e1.Embedded = r1(158), e1.Array = r1(55), e1.Buffer = r1(160), e1.Date = r1(162), e1.ObjectId = r1(165), e1.Mixed = r1(25), e1.Decimal128 = e1.Decimal = r1(167), e1.Map = r1(169), e1.Oid = e1.ObjectId, e1.Object = e1.Mixed, e1.Bool = e1.Boolean, e1.ObjectID = e1.ObjectId;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1, e1) {
                var r1;
                if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                    if (Array.isArray(t1) || (r1 = function(t1, e1) {
                        if (!t1) return;
                        if ("string" == typeof t1) return o1(t1, e1);
                        var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                        "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                        if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                        if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return o1(t1, e1);
                    }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                        r1 && (t1 = r1);
                        var n1 = 0, i1 = function() {};
                        return {
                            s: i1,
                            n: function() {
                                return n1 >= t1.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t1[n1++]
                                };
                            },
                            e: function(t1) {
                                throw t1;
                            },
                            f: i1
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var s1, a1 = !0, u1 = !1;
                return {
                    s: function() {
                        r1 = t1[Symbol.iterator]();
                    },
                    n: function() {
                        var t1 = r1.next();
                        return a1 = t1.done, t1;
                    },
                    e: function(t1) {
                        u1 = !0, s1 = t1;
                    },
                    f: function() {
                        try {
                            a1 || null == r1.return || r1.return();
                        } finally{
                            if (u1) throw s1;
                        }
                    }
                };
            }
            function o1(t1, e1) {
                (null == e1 || e1 > t1.length) && (e1 = t1.length);
                for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                return n1;
            }
            var i1, s1, a1 = r1(48), u1 = r1(72), c1 = r1(14), l1 = r1(152), f1 = r1(7), p1 = f1.CastError, h1 = r1(25), y1 = r1(153), d1 = r1(154), m1 = r1(3), _1 = r1(80), v1 = r1(4), g1 = r1(2), b1 = r1(33).castToNumber, w1 = r1(81), O1 = r1(34), S1 = Symbol("mongoose#isNestedArray");
            function A1(t1, e1, n1, o1) {
                s1 || (s1 = r1(56).Embedded);
                var i1, a1, u1 = "type";
                if (o1 && o1.typeKey && (u1 = o1.typeKey), this.schemaOptions = o1, e1) {
                    var c1 = {};
                    g1.isPOJO(e1) && (e1[u1] ? (delete (c1 = g1.clone(e1))[u1], e1 = e1[u1]) : e1 = h1), e1 === Object && (e1 = h1);
                    var l1 = "string" == typeof e1 ? e1 : g1.getFunctionName(e1), p1 = r1(54), y1 = p1.hasOwnProperty(l1) ? p1[l1] : e1;
                    this.casterConstructor = y1, this.casterConstructor instanceof A1 && (this.casterConstructor[S1] = !0), "function" != typeof y1 || y1.$isArraySubdocument || y1.$isSchemaMap ? this.caster = y1 : this.caster = new y1(null, c1), this.$embeddedSchemaType = this.caster, this.caster instanceof s1 || (this.caster.path = t1);
                }
                if (this.$isMongooseArray = !0, f1.call(this, t1, n1, "Array"), null != this.defaultValue && (i1 = this.defaultValue, a1 = "function" == typeof i1), !("defaultValue" in this) || void 0 !== this.defaultValue) {
                    var d1 = function() {
                        var t1 = [];
                        return a1 ? t1 = i1.call(this) : null != i1 && (t1 = t1.concat(i1)), t1;
                    };
                    d1.$runBeforeSetters = !a1, this.default(d1);
                }
            }
            A1.schemaName = "Array", A1.options = {
                castNonArrays: !0
            }, A1.defaultOptions = {}, A1.set = f1.set, /*!
 * Inherits from SchemaType.
 */ A1.prototype = Object.create(f1.prototype), A1.prototype.constructor = A1, A1.prototype.OptionsConstructor = l1, /*!
 * ignore
 */ A1._checkRequired = f1.prototype.checkRequired, A1.checkRequired = f1.checkRequired, A1.prototype.checkRequired = function(t1, e1) {
                return f1._isRef(this, t1, e1, !0) ? !!t1 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : A1.checkRequired())(t1);
            }, A1.prototype.enum = function() {
                for(var t1 = this;;){
                    var e1 = m1(t1, "caster.instance");
                    if ("Array" !== e1) {
                        if ("String" !== e1 && "Number" !== e1) throw new Error("`enum` can only be set on an array of strings or numbers , not " + e1);
                        break;
                    }
                    t1 = t1.caster;
                }
                return t1.caster.enum.apply(t1.caster, arguments), this;
            }, A1.prototype.applyGetters = function(t1, e1) {
                return this.caster.options && this.caster.options.ref ? t1 : f1.prototype.applyGetters.call(this, t1, e1);
            }, A1.prototype._applySetters = function(t1, e1, r1, n1) {
                if (this.casterConstructor instanceof A1 && A1.options.castNonArrays && !this[S1]) {
                    for(var o1 = 0, i1 = this; null != i1 && i1 instanceof A1 && !i1.$isMongooseDocumentArray;)++o1, i1 = i1.casterConstructor;
                    if (null != t1 && t1.length > 0) {
                        var s1 = y1(t1);
                        if (s1.min === s1.max && s1.max < o1 && s1.containsNonArrayItem) for(var a1 = s1.max; a1 < o1; ++a1)t1 = [
                            t1
                        ];
                    }
                }
                return f1.prototype._applySetters.call(this, t1, e1, r1, n1);
            }, A1.prototype.cast = function(t1, e1, n1, o1, s1) {
                var a1, u1;
                if (i1 || (i1 = r1(56).Array), Array.isArray(t1)) {
                    if (!t1.length && e1) {
                        var l1 = e1.schema.indexedPaths(), f1 = this.path;
                        for(a1 = 0, u1 = l1.length; a1 < u1; ++a1){
                            var y1 = l1[a1][0][f1];
                            if ("2dsphere" === y1 || "2d" === y1) return;
                        }
                        var d1 = this.path.endsWith(".coordinates") ? this.path.substr(0, this.path.lastIndexOf(".")) : null;
                        if (null != d1) for(a1 = 0, u1 = l1.length; a1 < u1; ++a1){
                            if ("2dsphere" === l1[a1][0][d1]) return;
                        }
                    }
                    if (t1 && t1.isMongooseArray ? t1 && t1.isMongooseArray && (t1 = i1(t1, this._arrayPath || this.path, e1)) : t1 = i1(t1, this._arrayPath || this.path, e1), null != e1 && null != e1.$__ && e1.populated(this.path)) return t1;
                    if (this.caster && this.casterConstructor !== h1) try {
                        for(a1 = 0, u1 = t1.length; a1 < u1; a1++){
                            if ("Number" === this.caster.instance && void 0 === t1[a1]) throw new c1("Mongoose number arrays disallow storing undefined");
                            var m1 = {};
                            null != s1 && null != s1.arrayPath ? m1.arrayPath = s1.arrayPath + "." + a1 : null != this.caster._arrayPath && (m1.arrayPath = this.caster._arrayPath.slice(0, -2) + "." + a1), t1[a1] = this.caster.cast(t1[a1], e1, n1, void 0, m1);
                        }
                    } catch (e1) {
                        throw new p1("[" + e1.kind + "]", v1.inspect(t1), this.path, e1, this);
                    }
                    return t1;
                }
                if (n1 || A1.options.castNonArrays) return e1 && n1 && e1.markModified(this.path), this.cast([
                    t1
                ], e1, n1);
                throw new p1("Array", v1.inspect(t1), this.path, null, this);
            }, /*!
 * Ignore
 */ A1.prototype.discriminator = function(t1, e1) {
                for(var r1 = this; r1.$isMongooseArray && !r1.$isMongooseDocumentArray;)if (null == (r1 = r1.casterConstructor) || "function" == typeof r1) throw new c1("You can only add an embedded discriminator on a document array, " + this.path + " is a plain array");
                return r1.discriminator(t1, e1);
            }, /*!
 * ignore
 */ A1.prototype.clone = function() {
                var t1 = Object.assign({}, this.options), e1 = new this.constructor(this.path, this.caster, t1, this.schemaOptions);
                return e1.validators = this.validators.slice(), void 0 !== this.requiredValidator && (e1.requiredValidator = this.requiredValidator), e1;
            }, A1.prototype.castForQuery = function(t1, e1) {
                var r1, n1, o1 = this;
                if (2 === arguments.length) {
                    if (!(r1 = this.$conditionalHandlers[t1])) throw new Error("Can't use " + t1 + " with Array.");
                    n1 = r1.call(this, e1);
                } else {
                    n1 = t1;
                    var i1 = this.casterConstructor;
                    if (n1 && i1.discriminators && i1.schema && i1.schema.options && i1.schema.options.discriminatorKey) {
                        if ("string" == typeof n1[i1.schema.options.discriminatorKey] && i1.discriminators[n1[i1.schema.options.discriminatorKey]]) i1 = i1.discriminators[n1[i1.schema.options.discriminatorKey]];
                        else {
                            var s1 = O1(i1, n1[i1.schema.options.discriminatorKey]);
                            s1 && (i1 = s1);
                        }
                    }
                    var a1 = this.casterConstructor.prototype, u1 = a1 && (a1.castForQuery || a1.cast);
                    !u1 && i1.castForQuery && (u1 = i1.castForQuery);
                    var c1 = this.caster;
                    Array.isArray(n1) ? (this.setters.reverse().forEach(function(t1) {
                        n1 = t1.call(o1, n1, o1);
                    }), n1 = n1.map(function(t1) {
                        return g1.isObject(t1) && t1.$elemMatch ? t1 : u1 ? t1 = u1.call(c1, t1) : null != t1 ? t1 = new i1(t1) : t1;
                    })) : u1 ? n1 = u1.call(c1, n1) : null != n1 && (n1 = new i1(n1));
                }
                return n1;
            };
            var j1 = A1.prototype.$conditionalHandlers = {};
            function E1(t1) {
                return function(e1) {
                    if (!Array.isArray(e1)) throw new TypeError("conditional " + t1 + " requires an array");
                    var r1, o1 = [], i1 = n1(e1);
                    try {
                        for(i1.s(); !(r1 = i1.n()).done;){
                            var s1 = r1.value;
                            o1.push(d1(this.casterConstructor.schema, s1));
                        }
                    } catch (t1) {
                        i1.e(t1);
                    } finally{
                        i1.f();
                    }
                    return o1;
                };
            }
            j1.$all = function(t1) {
                return Array.isArray(t1) || (t1 = [
                    t1
                ]), t1 = t1.map(function(t1) {
                    if (g1.isObject(t1)) {
                        var e1 = {};
                        return e1[this.path] = t1, d1(this.casterConstructor.schema, e1)[this.path];
                    }
                    return t1;
                }, this), this.castForQuery(t1);
            }, j1.$options = String, j1.$elemMatch = function(t1) {
                for(var e1 = Object.keys(t1), r1 = e1.length, n1 = 0; n1 < r1; ++n1){
                    var o1 = e1[n1], i1 = t1[o1];
                    _1(o1) && null != i1 && (t1[o1] = this.castForQuery(o1, i1));
                }
                var s1 = m1(this, "casterConstructor.schema.options.discriminatorKey"), a1 = m1(this, "casterConstructor.schema.discriminators", {});
                return null != s1 && null != t1[s1] && null != a1[t1[s1]] ? d1(a1[t1[s1]], t1) : d1(this.casterConstructor.schema, t1);
            }, j1.$geoIntersects = w1.cast$geoIntersects, j1.$or = E1("$or"), j1.$and = E1("$and"), j1.$nor = E1("$nor"), j1.$near = j1.$nearSphere = w1.cast$near, j1.$within = j1.$geoWithin = w1.cast$within, j1.$size = j1.$minDistance = j1.$maxDistance = b1, j1.$exists = a1, j1.$type = u1, j1.$eq = j1.$gt = j1.$gte = j1.$lt = j1.$lte = j1.$ne = j1.$regex = A1.prototype.castForQuery, j1.$nin = f1.prototype.$conditionalHandlers.$nin, j1.$in = f1.prototype.$conditionalHandlers.$in, /*!
 * Module exports.
 */ t1.exports = A1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module exports.
 */ e1.Array = r1(82), e1.Buffer = r1(85), e1.Document = e1.Embedded = r1(26), e1.DocumentArray = r1(18), e1.Decimal128 = r1(20), e1.ObjectId = r1(13), e1.Map = r1(87), e1.Subdocument = r1(89);
        },
        function(t1, e1, r1) {
            "use strict";
            var n1, o1 = r1(0).documentSchemaSymbol, i1 = r1(3), s1 = r1(17).internalToObjectOptions, a1 = r1(2), u1 = r1(0).getSymbol, c1 = r1(0).scopeSymbol;
            /*!
 * Compiles schemas.
 */ function l1(t1, e1, o1, i1) {
                n1 = n1 || r1(6);
                for(var s1, u1, c1 = Object.keys(t1), l1 = c1.length, p1 = 0; p1 < l1; ++p1)s1 = t1[u1 = c1[p1]], f1(u1, a1.isPOJO(s1) && Object.keys(s1).length && (!s1[i1.typeKey] || "type" === i1.typeKey && s1.type.type) ? s1 : null, e1, o1, c1, i1);
            }
            /*!
 * Defines the accessor named prop on the incoming prototype.
 */ function f1(t1, e1, f1, p1, h1, y1) {
                n1 = n1 || r1(6);
                var d1 = (p1 ? p1 + "." : "") + t1;
                p1 = p1 || "", e1 ? Object.defineProperty(f1, t1, {
                    enumerable: !0,
                    configurable: !0,
                    get: function() {
                        var t1, r1, s1 = this;
                        if (this.$__.getters || (this.$__.getters = {}), !this.$__.getters[d1]) {
                            var u1 = Object.create(n1.prototype, (t1 = this, r1 = {}, Object.getOwnPropertyNames(t1).forEach(function(e1) {
                                r1[e1] = Object.getOwnPropertyDescriptor(t1, e1), r1[e1].get ? delete r1[e1] : r1[e1].enumerable = -1 === [
                                    "isNew",
                                    "$__",
                                    "errors",
                                    "_doc",
                                    "$locals",
                                    "$op",
                                    "__parentArray",
                                    "__index",
                                    "$isDocumentArrayElement"
                                ].indexOf(e1);
                            }), r1));
                            p1 || (u1.$__[c1] = this), u1.$__.nestedPath = d1, Object.defineProperty(u1, "schema", {
                                enumerable: !1,
                                configurable: !0,
                                writable: !1,
                                value: f1.schema
                            }), Object.defineProperty(u1, o1, {
                                enumerable: !1,
                                configurable: !0,
                                writable: !1,
                                value: f1.schema
                            }), Object.defineProperty(u1, "toObject", {
                                enumerable: !1,
                                configurable: !0,
                                writable: !1,
                                value: function() {
                                    return a1.clone(s1.get(d1, null, {
                                        virtuals: i1(this, "schema.options.toObject.virtuals", null)
                                    }));
                                }
                            }), Object.defineProperty(u1, "$__get", {
                                enumerable: !1,
                                configurable: !0,
                                writable: !1,
                                value: function() {
                                    return s1.get(d1, null, {
                                        virtuals: i1(this, "schema.options.toObject.virtuals", null)
                                    });
                                }
                            }), Object.defineProperty(u1, "toJSON", {
                                enumerable: !1,
                                configurable: !0,
                                writable: !1,
                                value: function() {
                                    return s1.get(d1, null, {
                                        virtuals: i1(s1, "schema.options.toJSON.virtuals", null)
                                    });
                                }
                            }), Object.defineProperty(u1, "$__isNested", {
                                enumerable: !1,
                                configurable: !0,
                                writable: !1,
                                value: !0
                            });
                            var h1 = Object.freeze({
                                minimize: !0,
                                virtuals: !1,
                                getters: !1,
                                transform: !1
                            });
                            Object.defineProperty(u1, "$isEmpty", {
                                enumerable: !1,
                                configurable: !0,
                                writable: !1,
                                value: function() {
                                    return 0 === Object.keys(this.get(d1, null, h1) || {}).length;
                                }
                            }), Object.defineProperty(u1, "$__parent", {
                                enumerable: !1,
                                configurable: !0,
                                writable: !1,
                                value: this
                            }), l1(e1, u1, d1, y1), this.$__.getters[d1] = u1;
                        }
                        return this.$__.getters[d1];
                    },
                    set: function(t1) {
                        null != t1 && t1.$__isNested ? t1 = t1.$__get() : t1 instanceof n1 && !t1.$__isNested && (t1 = t1.toObject(s1)), (this.$__[c1] || this).$set(d1, t1);
                    }
                }) : Object.defineProperty(f1, t1, {
                    enumerable: !0,
                    configurable: !0,
                    get: function() {
                        return this[u1].call(this.$__[c1] || this, d1);
                    },
                    set: function(t1) {
                        this.$set.call(this.$__[c1] || this, d1, t1);
                    }
                });
            }
            /*!
 * exports
 */ e1.compile = l1, e1.defineKey = f1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * ignore
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            t1.exports = function(t1) {
                return null == t1 || "object" !== n1(t1) || !("$meta" in t1) && !("$slice" in t1);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                if (void 0 !== e1.Map) t1.exports = e1.Map, t1.exports.Map = e1.Map;
                else {
                    var r1 = function(t1) {
                        this._keys = [], this._values = {};
                        for(var e1 = 0; e1 < t1.length; e1++)if (null != t1[e1]) {
                            var r1 = t1[e1], n1 = r1[0], o1 = r1[1];
                            this._keys.push(n1), this._values[n1] = {
                                v: o1,
                                i: this._keys.length - 1
                            };
                        }
                    };
                    r1.prototype.clear = function() {
                        this._keys = [], this._values = {};
                    }, r1.prototype.delete = function(t1) {
                        var e1 = this._values[t1];
                        return null != e1 && (delete this._values[t1], this._keys.splice(e1.i, 1), !0);
                    }, r1.prototype.entries = function() {
                        var t1 = this, e1 = 0;
                        return {
                            next: function() {
                                var r1 = t1._keys[e1++];
                                return {
                                    value: void 0 !== r1 ? [
                                        r1,
                                        t1._values[r1].v
                                    ] : void 0,
                                    done: void 0 === r1
                                };
                            }
                        };
                    }, r1.prototype.forEach = function(t1, e1) {
                        e1 = e1 || this;
                        for(var r1 = 0; r1 < this._keys.length; r1++){
                            var n1 = this._keys[r1];
                            t1.call(e1, this._values[n1].v, n1, e1);
                        }
                    }, r1.prototype.get = function(t1) {
                        return this._values[t1] ? this._values[t1].v : void 0;
                    }, r1.prototype.has = function(t1) {
                        return null != this._values[t1];
                    }, r1.prototype.keys = function() {
                        var t1 = this, e1 = 0;
                        return {
                            next: function() {
                                var r1 = t1._keys[e1++];
                                return {
                                    value: void 0 !== r1 ? r1 : void 0,
                                    done: void 0 === r1
                                };
                            }
                        };
                    }, r1.prototype.set = function(t1, e1) {
                        return this._values[t1] ? (this._values[t1].v = e1, this) : (this._keys.push(t1), this._values[t1] = {
                            v: e1,
                            i: this._keys.length - 1
                        }, this);
                    }, r1.prototype.values = function() {
                        var t1 = this, e1 = 0;
                        return {
                            next: function() {
                                var r1 = t1._keys[e1++];
                                return {
                                    value: void 0 !== r1 ? t1._values[r1].v : void 0,
                                    done: void 0 === r1
                                };
                            }
                        };
                    }, Object.defineProperty(r1.prototype, "size", {
                        enumerable: !0,
                        get: function() {
                            return this._keys.length;
                        }
                    }), t1.exports = r1, t1.exports.Map = r1;
                }
            }).call(this, r1(11));
        },
        function(t1, e1) {
            var r1 = function t1(e1) {
                if (!(this instanceof t1)) return new t1(e1);
                this._bsontype = "Int32", this.value = e1;
            };
            r1.prototype.valueOf = function() {
                return this.value;
            }, r1.prototype.toJSON = function() {
                return this.value;
            }, t1.exports = r1, t1.exports.Int32 = r1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ var n1 = r1(6), o1 = r1(178), i1 = !1;
            t1.exports = function() {
                return i1 ? o1 : n1;
            }, /*!
 * ignore
 */ t1.exports.setBrowser = function(t1) {
                i1 = t1;
            };
        },
        function(t1, e1) {
            t1.exports = function(t1, e1, r1) {
                var n1 = [], o1 = t1.length;
                if (0 === o1) return n1;
                var i1 = e1 < 0 ? Math.max(0, e1 + o1) : e1 || 0;
                for(void 0 !== r1 && (o1 = r1 < 0 ? r1 + o1 : r1); o1-- > i1;)n1[o1 - i1] = t1[o1];
                return n1;
            };
        },
        function(t1, e1, r1) {
            /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ var n1 = r1(1), o1 = n1.Buffer;
            function i1(t1, e1) {
                for(var r1 in t1)e1[r1] = t1[r1];
            }
            function s1(t1, e1, r1) {
                return o1(t1, e1, r1);
            }
            o1.from && o1.alloc && o1.allocUnsafe && o1.allocUnsafeSlow ? t1.exports = n1 : (i1(n1, e1), e1.Buffer = s1), s1.prototype = Object.create(o1.prototype), i1(o1, s1), s1.from = function(t1, e1, r1) {
                if ("number" == typeof t1) throw new TypeError("Argument must not be a number");
                return o1(t1, e1, r1);
            }, s1.alloc = function(t1, e1, r1) {
                if ("number" != typeof t1) throw new TypeError("Argument must be a number");
                var n1 = o1(t1);
                return void 0 !== e1 ? "string" == typeof r1 ? n1.fill(e1, r1) : n1.fill(e1) : n1.fill(0), n1;
            }, s1.allocUnsafe = function(t1) {
                if ("number" != typeof t1) throw new TypeError("Argument must be a number");
                return o1(t1);
            }, s1.allocUnsafeSlow = function(t1) {
                if ("number" != typeof t1) throw new TypeError("Argument must be a number");
                return n1.SlowBuffer(t1);
            };
        },
        function(t1, e1) {
            function r1(t1) {
                return (r1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            var n1 = Object.prototype.toString;
            t1.exports = function(t1) {
                if ("object" != r1(e1 = t1) || "[object RegExp]" != n1.call(e1)) throw new TypeError("Not a RegExp");
                var e1, o1 = [];
                t1.global && o1.push("g"), t1.multiline && o1.push("m"), t1.ignoreCase && o1.push("i"), t1.dotAll && o1.push("s"), t1.unicode && o1.push("u"), t1.sticky && o1.push("y");
                var i1 = new RegExp(t1.source, o1.join(""));
                return "number" == typeof t1.lastIndex && (i1.lastIndex = t1.lastIndex), i1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            t1.exports = function(t1) {
                return t1.name ? t1.name : (t1.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(3);
            /*!
 * Get the bson type, if it exists
 */ t1.exports = function(t1, e1) {
                return n1(t1, "_bsontype", void 0) === e1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                /*!
 * ignore
 */ var n1 = r1(22), o1 = r1(115), i1 = {
                    _promise: null,
                    get: function() {
                        return i1._promise;
                    },
                    set: function(t1) {
                        n1.ok("function" == typeof t1, "mongoose.Promise must be a function, got ".concat(t1)), i1._promise = t1, o1.Promise = t1;
                    }
                };
                /*!
 * Use native promises by default
 */ i1.set(e1.Promise), t1.exports = i1;
            }).call(this, r1(11));
        },
        function(t1, e1, r1) {
            "use strict";
            (function(t1, n1) {
                /*!
 * Module dependencies.
 */ function o1(t1) {
                    return (o1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                var i1 = r1(117).Buffer, s1 = r1(64), a1 = e1.clone = function t1(r1, n1) {
                    if (null == r1) return r1;
                    if (Array.isArray(r1)) return e1.cloneArray(r1, n1);
                    if (r1.constructor) {
                        if (/ObjectI[dD]$/.test(r1.constructor.name)) return "function" == typeof r1.clone ? r1.clone() : new r1.constructor(r1.id);
                        if ("ReadPreference" === r1.constructor.name) return new r1.constructor(r1.mode, t1(r1.tags, n1));
                        if ("Binary" == r1._bsontype && r1.buffer && r1.value) return "function" == typeof r1.clone ? r1.clone() : new r1.constructor(r1.value(!0), r1.sub_type);
                        if ("Date" === r1.constructor.name || "Function" === r1.constructor.name) return new r1.constructor(+r1);
                        if ("RegExp" === r1.constructor.name) return s1(r1);
                        if ("Buffer" === r1.constructor.name) return e1.cloneBuffer(r1);
                    }
                    return c1(r1) ? e1.cloneObject(r1, n1) : r1.valueOf ? r1.valueOf() : void 0;
                };
                /*!
 * ignore
 */ e1.cloneObject = function(t1, e1) {
                    var r1, n1, o1, i1 = e1 && e1.minimize, s1 = {};
                    for(o1 in t1)n1 = a1(t1[o1], e1), i1 && void 0 === n1 || (r1 || (r1 = !0), s1[o1] = n1);
                    return i1 ? r1 && s1 : s1;
                }, e1.cloneArray = function(t1, e1) {
                    for(var r1 = [], n1 = 0, o1 = t1.length; n1 < o1; n1++)r1.push(a1(t1[n1], e1));
                    return r1;
                }, e1.tick = function(t1) {
                    if ("function" == typeof t1) return function() {
                        var e1 = arguments;
                        l1(function() {
                            t1.apply(this, e1);
                        });
                    };
                }, e1.merge = function t1(r1, n1) {
                    for(var o1, i1 = Object.keys(n1), s1 = i1.length; s1--;)void 0 === r1[o1 = i1[s1]] ? r1[o1] = n1[o1] : e1.isObject(n1[o1]) ? t1(r1[o1], n1[o1]) : r1[o1] = n1[o1];
                }, e1.mergeClone = function t1(r1, n1) {
                    for(var o1, i1 = Object.keys(n1), s1 = i1.length; s1--;)void 0 === r1[o1 = i1[s1]] ? r1[o1] = a1(n1[o1]) : e1.isObject(n1[o1]) ? t1(r1[o1], n1[o1]) : r1[o1] = a1(n1[o1]);
                }, e1.readPref = function(t1) {
                    switch(t1){
                        case "p":
                            t1 = "primary";
                            break;
                        case "pp":
                            t1 = "primaryPreferred";
                            break;
                        case "s":
                            t1 = "secondary";
                            break;
                        case "sp":
                            t1 = "secondaryPreferred";
                            break;
                        case "n":
                            t1 = "nearest";
                    }
                    return t1;
                }, e1.readConcern = function(t1) {
                    if ("string" == typeof t1) {
                        switch(t1){
                            case "l":
                                t1 = "local";
                                break;
                            case "a":
                                t1 = "available";
                                break;
                            case "m":
                                t1 = "majority";
                                break;
                            case "lz":
                                t1 = "linearizable";
                                break;
                            case "s":
                                t1 = "snapshot";
                        }
                        t1 = {
                            level: t1
                        };
                    }
                    return t1;
                };
                var u1 = Object.prototype.toString;
                e1.toString = function(t1) {
                    return u1.call(t1);
                };
                var c1 = e1.isObject = function(t1) {
                    return "[object Object]" == e1.toString(t1);
                };
                e1.isArray = function(t1) {
                    return Array.isArray(t1) || "object" == o1(t1) && "[object Array]" == e1.toString(t1);
                }, e1.keys = Object.keys || function(t1) {
                    var e1 = [];
                    for(var r1 in t1)t1.hasOwnProperty(r1) && e1.push(r1);
                    return e1;
                }, e1.create = "function" == typeof Object.create ? Object.create : function(t1) {
                    if (arguments.length > 1) throw new Error("Adding properties is not supported");
                    function e1() {}
                    return e1.prototype = t1, new e1;
                }, e1.inherits = function(t1, r1) {
                    t1.prototype = e1.create(r1.prototype), t1.prototype.constructor = t1;
                };
                var l1 = e1.soon = "function" == typeof t1 ? t1 : n1.nextTick;
                e1.cloneBuffer = function(t1) {
                    var e1 = i1.alloc(t1.length);
                    return t1.copy(e1, 0, 0, t1.length), e1;
                }, e1.isArgumentsObject = function(t1) {
                    return "[object Arguments]" === Object.prototype.toString.call(t1);
                };
            }).call(this, r1(69).setImmediate, r1(8));
        },
        function(t1, e1, r1) {
            (function(t1) {
                var n1 = void 0 !== t1 && t1 || "undefined" != typeof self && self || window, o1 = Function.prototype.apply;
                function i1(t1, e1) {
                    this._id = t1, this._clearFn = e1;
                }
                e1.setTimeout = function() {
                    return new i1(o1.call(setTimeout, n1, arguments), clearTimeout);
                }, e1.setInterval = function() {
                    return new i1(o1.call(setInterval, n1, arguments), clearInterval);
                }, e1.clearTimeout = e1.clearInterval = function(t1) {
                    t1 && t1.close();
                }, i1.prototype.unref = i1.prototype.ref = function() {}, i1.prototype.close = function() {
                    this._clearFn.call(n1, this._id);
                }, e1.enroll = function(t1, e1) {
                    clearTimeout(t1._idleTimeoutId), t1._idleTimeout = e1;
                }, e1.unenroll = function(t1) {
                    clearTimeout(t1._idleTimeoutId), t1._idleTimeout = -1;
                }, e1._unrefActive = e1.active = function(t1) {
                    clearTimeout(t1._idleTimeoutId);
                    var e1 = t1._idleTimeout;
                    e1 >= 0 && (t1._idleTimeoutId = setTimeout(function() {
                        t1._onTimeout && t1._onTimeout();
                    }, e1));
                }, r1(116), e1.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== t1 && t1.setImmediate || this && this.setImmediate, e1.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== t1 && t1.clearImmediate || this && this.clearImmediate;
            }).call(this, r1(11));
        },
        function(t1, e1, r1) {
            "use strict";
            (function(t1, r1, n1, o1) {
                function i1(t1) {
                    return (i1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                e1.isNode = void 0 !== t1 && "object" == i1(r1) && "object" == (void 0 === n1 ? "undefined" : i1(n1)) && "function" == typeof o1 && t1.argv, e1.isMongo = !e1.isNode && "function" == typeof printjson && "function" == typeof ObjectId && "function" == typeof rs && "function" == typeof sh, e1.isBrowser = !e1.isNode && !e1.isMongo && "undefined" != typeof window, e1.type = e1.isNode ? "node" : e1.isMongo ? "mongo" : e1.isBrowser ? "browser" : "unknown";
            }).call(this, r1(8), r1(122)(t1), r1(11), r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                for(var r1 = 0; r1 < e1.length; r1++){
                    var n1 = e1[r1];
                    n1.enumerable = n1.enumerable || !1, n1.configurable = !0, "value" in n1 && (n1.writable = !0), Object.defineProperty(t1, n1.key, n1);
                }
            }
            function i1(t1, e1) {
                return (i1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function s1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = u1(t1);
                    if (e1) {
                        var o1 = u1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return a1(this, r1);
                };
            }
            function a1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function u1(t1) {
                return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var c1 = r1(5), l1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && i1(t1, e1);
                }(u1, t1);
                var e1, r1, n1, a1 = s1(u1);
                function u1(t1) {
                    var e1;
                    !function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, u1);
                    var r1 = t1.message;
                    r1 || (r1 = c1.messages.general.default);
                    var n1 = f1(r1, t1);
                    return e1 = a1.call(this, n1), t1 = Object.assign({}, t1, {
                        message: n1
                    }), e1.properties = t1, e1.kind = t1.type, e1.path = t1.path, e1.value = t1.value, e1.reason = t1.reason, e1;
                }
                /*!
   * toString helper
   * TODO remove? This defaults to `${this.name}: ${this.message}`
   */ return e1 = u1, r1 = [
                    {
                        key: "toString",
                        value: function() {
                            return this.message;
                        }
                    },
                    {
                        key: "toJSON",
                        value: function() {
                            return Object.assign({
                                name: this.name,
                                message: this.message
                            }, this);
                        }
                    }
                ], o1(e1.prototype, r1), n1 && o1(e1, n1), u1;
            }(c1);
            /*!
 * Formats error messages
 */ function f1(t1, e1) {
                if ("function" == typeof t1) return t1(e1);
                for(var r1 = 0, n1 = Object.keys(e1); r1 < n1.length; r1++){
                    var o1 = n1[r1];
                    "message" !== o1 && (t1 = t1.replace("{" + o1.toUpperCase() + "}", e1[o1]));
                }
                return t1;
            }
            /*!
 * exports
 */ Object.defineProperty(l1.prototype, "name", {
                value: "ValidatorError"
            }), /*!
 * The object used to define this validator. Not enumerable to hide
 * it from `require('util').inspect()` output re: gh-3925
 */ Object.defineProperty(l1.prototype, "properties", {
                enumerable: !1,
                writable: !0,
                value: null
            }), l1.prototype.formatMessage = f1, t1.exports = l1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * ignore
 */ t1.exports = function(t1) {
                if (Array.isArray(t1)) {
                    if (!t1.every(function(t1) {
                        return "number" == typeof t1 || "string" == typeof t1;
                    })) throw new Error("$type array values must be strings or numbers");
                    return t1;
                }
                if ("number" != typeof t1 && "string" != typeof t1) throw new Error("$type parameter must be number, string, or array of numbers and strings");
                return t1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                return (o1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function i1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = a1(t1);
                    if (e1) {
                        var o1 = a1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return s1(this, r1);
                };
            }
            function s1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function a1(t1) {
                return (a1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var u1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && o1(t1, e1);
                }(r1, t1);
                var e1 = i1(r1);
                function r1(t1, n1) {
                    var o1;
                    !function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, r1);
                    var i1 = Array.isArray(n1) ? "array" : "primitive value";
                    return (o1 = e1.call(this, "Tried to set nested object field `" + t1 + "` to ".concat(i1, " `") + n1 + "` and strict mode is set to throw.")).path = t1, o1;
                }
                return r1;
            }(r1(5));
            Object.defineProperty(u1.prototype, "name", {
                value: "ObjectExpectedError"
            }), t1.exports = u1;
        },
        function(t1, e1, r1) {
            "use strict";
            t1.exports = function(t1) {
                var e1 = {
                    _id: {
                        auto: !0
                    }
                };
                e1._id[t1.options.typeKey] = "ObjectId", t1.add(e1);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            t1.exports = /*!
 * ignore
 */ function(t1, e1) {
                if (null == t1) return null;
                if ("boolean" == typeof t1) return e1;
                if ("boolean" == typeof t1[e1]) return t1[e1] ? e1 : null;
                if (!(e1 in t1)) return e1;
                return t1[e1];
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(51), o1 = r1(24);
            /*!
 * Register hooks for this model
 *
 * @param {Model} model
 * @param {Schema} schema
 */ function i1(t1, e1, r1) {
                var s1 = {
                    useErrorHandlers: !0,
                    numCallbackParams: 1,
                    nullResultByDefault: !0,
                    contextParameter: !0
                }, a1 = (r1 = r1 || {}).decorateDoc ? t1 : t1.prototype;
                t1.$appliedHooks = !0;
                for(var u1 = 0, c1 = Object.keys(e1.paths); u1 < c1.length; u1++){
                    var l1 = c1[u1], f1 = e1.paths[l1], p1 = null;
                    if (f1.$isSingleNested) p1 = f1.caster;
                    else {
                        if (!f1.$isMongooseDocumentArray) continue;
                        p1 = f1.Constructor;
                    }
                    if (!p1.$appliedHooks && (i1(p1, f1.schema, r1), null != p1.discriminators)) for(var h1 = 0, y1 = Object.keys(p1.discriminators); h1 < y1.length; h1++){
                        var d1 = y1[h1];
                        i1(p1.discriminators[d1], p1.discriminators[d1].schema, r1);
                    }
                }
                var m1 = e1.s.hooks.filter(function(t1) {
                    return "updateOne" === t1.name || "deleteOne" === t1.name ? !!t1.document : "remove" !== t1.name && "init" !== t1.name || null == t1.document || !!t1.document;
                }).filter(function(t1) {
                    return !e1.methods[t1.name] || !t1.fn[n1.builtInMiddleware];
                });
                t1._middleware = m1, a1.$__originalValidate = a1.$__originalValidate || a1.$__validate;
                for(var _1 = 0, v1 = [
                    "save",
                    "validate",
                    "remove",
                    "deleteOne"
                ]; _1 < v1.length; _1++){
                    var g1 = v1[_1], b1 = "validate" === g1 ? "$__originalValidate" : "$__".concat(g1), w1 = m1.createWrapper(g1, a1[b1], null, s1);
                    a1["$__".concat(g1)] = w1;
                }
                a1.$__init = m1.createWrapperSync("init", a1.$__init, null, s1);
                for(var O1 = Object.keys(e1.methods), S1 = Object.assign({}, s1, {
                    checkForPromise: !0
                }), A1 = function() {
                    var e1 = E1[j1];
                    if (!m1.hasHooks(e1)) return "continue";
                    var r1 = a1[e1];
                    a1[e1] = function() {
                        var r1 = this, n1 = Array.prototype.slice.call(arguments), i1 = n1.slice(-1).pop(), s1 = "function" == typeof i1 ? n1.slice(0, n1.length - 1) : n1;
                        return o1(i1, function(t1) {
                            return r1["$__".concat(e1)].apply(r1, s1.concat([
                                t1
                            ]));
                        }, t1.events);
                    }, a1["$__".concat(e1)] = m1.createWrapper(e1, r1, null, S1);
                }, j1 = 0, E1 = O1; j1 < E1.length; j1++)A1();
            }
            /*!
 * ignore
 */ t1.exports = i1, /*!
 * ignore
 */ i1.middlewareFunctions = [
                "deleteOne",
                "save",
                "validate",
                "remove",
                "updateOne",
                "init"
            ];
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(12);
            /*!
 * Given a value, cast it to a string, or throw a `CastError` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @param {String} [path] optional the path to set on the CastError
 * @return {string|null|undefined}
 * @throws {CastError}
 * @api private
 */ t1.exports = function(t1, e1) {
                if (null == t1) return t1;
                if (t1._id && "string" == typeof t1._id) return t1._id;
                if (t1.toString && t1.toString !== Object.prototype.toString && !Array.isArray(t1)) return t1.toString();
                throw new n1("string", t1, e1);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                /*!
 * Module requirements.
 */ var n1, o1 = r1(5), i1 = r1(148), s1 = r1(7), a1 = r1(149), u1 = r1(79), c1 = r1(2), l1 = r1(0).populateModelSymbol, f1 = s1.CastError;
                function p1(t1, e1) {
                    s1.call(this, t1, e1, "Number");
                }
                /*!
 * ignore
 */ function h1(t1) {
                    return this.cast(t1);
                }
                p1.get = s1.get, p1.set = s1.set, /*!
 * ignore
 */ p1._cast = a1, p1.cast = function(t1) {
                    return 0 === arguments.length || (!1 === t1 && (t1 = function(t1) {
                        if ("number" != typeof t1) throw new Error;
                        return t1;
                    }), this._cast = t1), this._cast;
                }, p1.schemaName = "Number", p1.defaultOptions = {}, /*!
 * Inherits from SchemaType.
 */ p1.prototype = Object.create(s1.prototype), p1.prototype.constructor = p1, p1.prototype.OptionsConstructor = i1, /*!
 * ignore
 */ p1._checkRequired = function(t1) {
                    return "number" == typeof t1 || t1 instanceof Number;
                }, p1.checkRequired = s1.checkRequired, p1.prototype.checkRequired = function(t1, e1) {
                    return s1._isRef(this, t1, e1, !0) ? !!t1 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : p1.checkRequired())(t1);
                }, p1.prototype.min = function(t1, e1) {
                    if (this.minValidator && (this.validators = this.validators.filter(function(t1) {
                        return t1.validator !== this.minValidator;
                    }, this)), null != t1) {
                        var r1 = e1 || o1.messages.Number.min;
                        r1 = r1.replace(/{MIN}/, t1), this.validators.push({
                            validator: this.minValidator = function(e1) {
                                return null == e1 || e1 >= t1;
                            },
                            message: r1,
                            type: "min",
                            min: t1
                        });
                    }
                    return this;
                }, p1.prototype.max = function(t1, e1) {
                    if (this.maxValidator && (this.validators = this.validators.filter(function(t1) {
                        return t1.validator !== this.maxValidator;
                    }, this)), null != t1) {
                        var r1 = e1 || o1.messages.Number.max;
                        r1 = r1.replace(/{MAX}/, t1), this.validators.push({
                            validator: this.maxValidator = function(e1) {
                                return null == e1 || e1 <= t1;
                            },
                            message: r1,
                            type: "max",
                            max: t1
                        });
                    }
                    return this;
                }, p1.prototype.enum = function(t1, e1) {
                    return this.enumValidator && (this.validators = this.validators.filter(function(t1) {
                        return t1.validator !== this.enumValidator;
                    }, this)), Array.isArray(t1) || (t1 = Array.prototype.slice.call(arguments), e1 = o1.messages.Number.enum), e1 = null == e1 ? o1.messages.Number.enum : e1, this.enumValidator = function(e1) {
                        return null == e1 || -1 !== t1.indexOf(e1);
                    }, this.validators.push({
                        validator: this.enumValidator,
                        message: e1,
                        type: "enum",
                        enumValues: t1
                    }), this;
                }, p1.prototype.cast = function(t1, o1, i1) {
                    if (s1._isRef(this, t1, o1, i1)) {
                        if (null == t1) return t1;
                        if (n1 || (n1 = r1(6)), t1 instanceof n1) return t1.$__.wasPopulated = !0, t1;
                        if ("number" == typeof t1) return t1;
                        if (e1.isBuffer(t1) || !c1.isObject(t1)) throw new f1("Number", t1, this.path, null, this);
                        var a1 = o1.$__fullPath(this.path), u1 = new ((o1.ownerDocument ? o1.ownerDocument() : o1).populated(a1, !0)).options[l1](t1);
                        return u1.$__.wasPopulated = !0, u1;
                    }
                    var h1 = t1 && void 0 !== t1._id ? t1._id : t1, y1 = "function" == typeof this.constructor.cast ? this.constructor.cast() : p1.cast();
                    try {
                        return y1(h1);
                    } catch (t1) {
                        throw new f1("Number", h1, this.path, t1, this);
                    }
                }, p1.prototype.$conditionalHandlers = c1.options(s1.prototype.$conditionalHandlers, {
                    $bitsAllClear: u1,
                    $bitsAnyClear: u1,
                    $bitsAllSet: u1,
                    $bitsAnySet: u1,
                    $gt: h1,
                    $gte: h1,
                    $lt: h1,
                    $lte: h1,
                    $mod: function(t1) {
                        var e1 = this;
                        return Array.isArray(t1) ? t1.map(function(t1) {
                            return e1.cast(t1);
                        }) : [
                            this.cast(t1)
                        ];
                    }
                }), p1.prototype.castForQuery = function(t1, e1) {
                    var r1;
                    if (2 === arguments.length) {
                        if (!(r1 = this.$conditionalHandlers[t1])) throw new f1("number", e1, this.path, null, this);
                        return r1.call(this, e1);
                    }
                    return e1 = this._castForQuery(t1);
                }, /*!
 * Module exports.
 */ t1.exports = p1;
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                /*!
 * Module requirements.
 */ var n1 = r1(12);
                /*!
 * ignore
 */ /*!
 * ignore
 */ function o1(t1, e1) {
                    var r1 = Number(e1);
                    if (isNaN(r1)) throw new n1("number", e1, t1);
                    return r1;
                }
                t1.exports = function(t1) {
                    var r1 = this;
                    return Array.isArray(t1) ? t1.map(function(t1) {
                        return o1(r1.path, t1);
                    }) : e1.isBuffer(t1) ? t1 : o1(r1.path, t1);
                };
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = new Set([
                "$ref",
                "$id",
                "$db"
            ]);
            t1.exports = function(t1) {
                return t1.startsWith("$") && !n1.has(t1);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module requirements.
 */ var n1 = r1(33).castArraysOfNumbers, o1 = r1(33).castToNumber;
            function i1(t1, e1) {
                switch(t1.$geometry.type){
                    case "Polygon":
                    case "LineString":
                    case "Point":
                        n1(t1.$geometry.coordinates, e1);
                }
                return s1(e1, t1), t1;
            }
            function s1(t1, e1) {
                e1.$maxDistance && (e1.$maxDistance = o1.call(t1, e1.$maxDistance)), e1.$minDistance && (e1.$minDistance = o1.call(t1, e1.$minDistance));
            }
            /*!
 * ignore
 */ e1.cast$geoIntersects = function(t1) {
                if (!t1.$geometry) return;
                return i1(t1, this), t1;
            }, e1.cast$near = function(t1) {
                var e1 = r1(55);
                if (Array.isArray(t1)) return n1(t1, this), t1;
                if (s1(this, t1), t1 && t1.$geometry) return i1(t1, this);
                if (!Array.isArray(t1)) throw new TypeError("$near must be either an array or an object with a $geometry property");
                return e1.prototype.castForQuery.call(this, t1);
            }, e1.cast$within = function(t1) {
                var e1 = this;
                if (s1(this, t1), t1.$box || t1.$polygon) {
                    var r1 = t1.$box ? "$box" : "$polygon";
                    t1[r1].forEach(function(t1) {
                        if (!Array.isArray(t1)) throw new TypeError("Invalid $within $box argument. Expected an array, received " + t1);
                        t1.forEach(function(r1, n1) {
                            t1[n1] = o1.call(e1, r1);
                        });
                    });
                } else if (t1.$center || t1.$centerSphere) {
                    var n1 = t1.$center ? "$center" : "$centerSphere";
                    t1[n1].forEach(function(r1, i1) {
                        Array.isArray(r1) ? r1.forEach(function(t1, n1) {
                            r1[n1] = o1.call(e1, t1);
                        }) : t1[n1][i1] = o1.call(e1, r1);
                    });
                } else t1.$geometry && i1(t1, this);
                return t1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ var n1 = r1(83), o1 = r1(6), i1 = r1(0).arrayAtomicsSymbol, s1 = r1(0).arrayParentSymbol, a1 = r1(0).arrayPathSymbol, u1 = r1(0).arraySchemaSymbol, c1 = Array.prototype.push;
            /*!
 * Module exports.
 */ t1.exports = function(t1, e1, r1) {
                var l1 = new n1;
                if (l1[i1] = {}, Array.isArray(t1)) {
                    for(var f1 = t1.length, p1 = 0; p1 < f1; ++p1)c1.call(l1, t1[p1]);
                    l1[i1] = t1[i1] || {};
                }
                return l1[a1] = e1, l1[u1] = void 0, r1 && r1 instanceof o1 && (l1[s1] = r1, l1[u1] = r1.schema.path(e1)), l1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                function n1(t1) {
                    return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                function o1(t1, e1) {
                    var r1;
                    if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                        if (Array.isArray(t1) || (r1 = function(t1, e1) {
                            if (!t1) return;
                            if ("string" == typeof t1) return i1(t1, e1);
                            var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                            "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                            if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                            if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return i1(t1, e1);
                        }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                            r1 && (t1 = r1);
                            var n1 = 0, o1 = function() {};
                            return {
                                s: o1,
                                n: function() {
                                    return n1 >= t1.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t1[n1++]
                                    };
                                },
                                e: function(t1) {
                                    throw t1;
                                },
                                f: o1
                            };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }
                    var s1, a1 = !0, u1 = !1;
                    return {
                        s: function() {
                            r1 = t1[Symbol.iterator]();
                        },
                        n: function() {
                            var t1 = r1.next();
                            return a1 = t1.done, t1;
                        },
                        e: function(t1) {
                            u1 = !0, s1 = t1;
                        },
                        f: function() {
                            try {
                                a1 || null == r1.return || r1.return();
                            } finally{
                                if (u1) throw s1;
                            }
                        }
                    };
                }
                function i1(t1, e1) {
                    (null == e1 || e1 > t1.length) && (e1 = t1.length);
                    for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                    return n1;
                }
                function s1(t1, e1) {
                    if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                }
                function a1(t1, e1) {
                    for(var r1 = 0; r1 < e1.length; r1++){
                        var n1 = e1[r1];
                        n1.enumerable = n1.enumerable || !1, n1.configurable = !0, "value" in n1 && (n1.writable = !0), Object.defineProperty(t1, n1.key, n1);
                    }
                }
                function u1(t1, e1, r1) {
                    return (u1 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t1, e1, r1) {
                        var n1 = function(t1, e1) {
                            for(; !Object.prototype.hasOwnProperty.call(t1, e1) && null !== (t1 = y1(t1)););
                            return t1;
                        }(t1, e1);
                        if (n1) {
                            var o1 = Object.getOwnPropertyDescriptor(n1, e1);
                            return o1.get ? o1.get.call(r1) : o1.value;
                        }
                    })(t1, e1, r1 || t1);
                }
                function c1(t1, e1) {
                    return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                        if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t1;
                    }(t1) : e1;
                }
                function l1(t1) {
                    var e1 = "function" == typeof Map ? new Map : void 0;
                    return (l1 = function(t1) {
                        if (null === t1 || (r1 = t1, -1 === Function.toString.call(r1).indexOf("[native code]"))) return t1;
                        var r1;
                        if ("function" != typeof t1) throw new TypeError("Super expression must either be null or a function");
                        if (void 0 !== e1) {
                            if (e1.has(t1)) return e1.get(t1);
                            e1.set(t1, n1);
                        }
                        function n1() {
                            return f1(t1, arguments, y1(this).constructor);
                        }
                        return n1.prototype = Object.create(t1.prototype, {
                            constructor: {
                                value: n1,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), h1(n1, t1);
                    })(t1);
                }
                function f1(t1, e1, r1) {
                    return (f1 = p1() ? Reflect.construct : function(t1, e1, r1) {
                        var n1 = [
                            null
                        ];
                        n1.push.apply(n1, e1);
                        var o1 = new (Function.bind.apply(t1, n1));
                        return r1 && h1(o1, r1.prototype), o1;
                    }).apply(null, arguments);
                }
                function p1() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }
                function h1(t1, e1) {
                    return (h1 = Object.setPrototypeOf || function(t1, e1) {
                        return t1.__proto__ = e1, t1;
                    })(t1, e1);
                }
                function y1(t1) {
                    return (y1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                        return t1.__proto__ || Object.getPrototypeOf(t1);
                    })(t1);
                }
                var d1 = r1(6), m1 = r1(26), _1 = r1(14), v1 = r1(13), g1 = r1(84), b1 = r1(3), w1 = r1(17).internalToObjectOptions, O1 = r1(2), S1 = r1(4), A1 = r1(0).arrayAtomicsSymbol, j1 = r1(0).arrayParentSymbol, E1 = r1(0).arrayPathSymbol, $1 = r1(0).arraySchemaSymbol, P1 = r1(0).populateModelSymbol, x1 = Symbol("mongoose#Array#sliced"), N1 = Array.prototype.push, T1 = Symbol("mongoose#MongooseCoreArray#validators"), k1 = function(t1) {
                    !function(t1, e1) {
                        if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                        t1.prototype = Object.create(e1 && e1.prototype, {
                            constructor: {
                                value: t1,
                                writable: !0,
                                configurable: !0
                            }
                        }), e1 && h1(t1, e1);
                    }(S1, t1);
                    var r1, n1, o1, i1, l1, f1 = (r1 = S1, n1 = p1(), function() {
                        var t1, e1 = y1(r1);
                        if (n1) {
                            var o1 = y1(this).constructor;
                            t1 = Reflect.construct(e1, arguments, o1);
                        } else t1 = e1.apply(this, arguments);
                        return c1(this, t1);
                    });
                    function S1() {
                        return s1(this, S1), f1.apply(this, arguments);
                    }
                    return o1 = S1, i1 = [
                        {
                            key: "$__getAtomics",
                            value: function() {
                                var t1 = [], e1 = Object.keys(this[A1]), r1 = e1.length, n1 = Object.assign({}, w1, {
                                    _isNested: !0
                                });
                                if (0 === r1) return t1[0] = [
                                    "$set",
                                    this.toObject(n1)
                                ], t1;
                                for(; r1--;){
                                    var o1 = e1[r1], i1 = this[A1][o1];
                                    O1.isMongooseObject(i1) ? i1 = i1.toObject(n1) : Array.isArray(i1) ? i1 = this.toObject.call(i1, n1) : null != i1 && Array.isArray(i1.$each) ? i1.$each = this.toObject.call(i1.$each, n1) : null != i1 && "function" == typeof i1.valueOf && (i1 = i1.valueOf()), "$addToSet" === o1 && (i1 = {
                                        $each: i1
                                    }), t1.push([
                                        o1,
                                        i1
                                    ]);
                                }
                                return t1;
                            }
                        },
                        {
                            key: "$atomics",
                            value: function() {
                                return this[A1];
                            }
                        },
                        {
                            key: "$parent",
                            value: function() {
                                return this[j1];
                            }
                        },
                        {
                            key: "$path",
                            value: function() {
                                return this[E1];
                            }
                        },
                        {
                            key: "$shift",
                            value: function() {
                                if (this._registerAtomic("$pop", -1), this._markModified(), !this._shifted) return this._shifted = !0, [].shift.call(this);
                            }
                        },
                        {
                            key: "$pop",
                            value: function() {
                                if (this._registerAtomic("$pop", 1), this._markModified(), !this._popped) return this._popped = !0, [].pop.call(this);
                            }
                        },
                        {
                            key: "$schema",
                            value: function() {
                                return this[$1];
                            }
                        },
                        {
                            key: "_cast",
                            value: function(t1) {
                                var r1, n1 = !1;
                                return this[j1] && (n1 = this[j1].populated(this[E1], !0)), n1 && null != t1 ? (r1 = n1.options[P1], (e1.isBuffer(t1) || t1 instanceof v1 || !O1.isObject(t1)) && (t1 = {
                                    _id: t1
                                }), t1.schema && t1.schema.discriminatorMapping && void 0 !== t1.schema.discriminatorMapping.key || (t1 = new r1(t1)), this[$1].caster.applySetters(t1, this[j1], !0)) : this[$1].caster.applySetters(t1, this[j1], !1);
                            }
                        },
                        {
                            key: "_mapCast",
                            value: function(t1, e1) {
                                return this._cast(t1, this.length + e1);
                            }
                        },
                        {
                            key: "_markModified",
                            value: function(t1, e1) {
                                var r1, n1 = this[j1];
                                if (n1) {
                                    if (r1 = this[E1], arguments.length && (r1 = null != e1 ? r1 + "." + this.indexOf(t1) + "." + e1 : r1 + "." + t1), null != r1 && r1.endsWith(".$")) return this;
                                    n1.markModified(r1, arguments.length > 0 ? t1 : n1);
                                }
                                return this;
                            }
                        },
                        {
                            key: "_registerAtomic",
                            value: function(t1, e1) {
                                if (!this[x1]) {
                                    if ("$set" === t1) return this[A1] = {
                                        $set: e1
                                    }, g1(this[j1], this[E1]), this._markModified(), this;
                                    var r1, n1 = this[A1];
                                    if ("$pop" === t1 && !("$pop" in n1)) {
                                        var o1 = this;
                                        this[j1].once("save", function() {
                                            o1._popped = o1._shifted = null;
                                        });
                                    }
                                    if (this[A1].$set || Object.keys(n1).length && !(t1 in n1)) return this[A1] = {
                                        $set: this
                                    }, this;
                                    if ("$pullAll" === t1 || "$addToSet" === t1) n1[t1] || (n1[t1] = []), n1[t1] = n1[t1].concat(e1);
                                    else if ("$pullDocs" === t1) {
                                        var i1 = n1.$pull || (n1.$pull = {});
                                        e1[0] instanceof m1 ? (r1 = i1.$or || (i1.$or = []), Array.prototype.push.apply(r1, e1.map(function(t1) {
                                            return t1.toObject({
                                                transform: !1,
                                                virtuals: !1
                                            });
                                        }))) : (r1 = i1._id || (i1._id = {
                                            $in: []
                                        })).$in = r1.$in.concat(e1);
                                    } else "$push" === t1 ? (n1.$push = n1.$push || {
                                        $each: []
                                    }, null != e1 && O1.hasUserDefinedProperty(e1, "$each") ? n1.$push = e1 : n1.$push.$each = n1.$push.$each.concat(e1)) : n1[t1] = e1;
                                    return this;
                                }
                            }
                        },
                        {
                            key: "addToSet",
                            value: function() {
                                C1(this, arguments);
                                var t1 = [].map.call(arguments, this._mapCast, this);
                                t1 = this[$1].applySetters(t1, this[j1]);
                                var e1 = [], r1 = "";
                                return t1[0] instanceof m1 ? r1 = "doc" : t1[0] instanceof Date && (r1 = "date"), t1.forEach(function(t1) {
                                    var n1, o1 = +t1;
                                    switch(r1){
                                        case "doc":
                                            n1 = this.some(function(e1) {
                                                return e1.equals(t1);
                                            });
                                            break;
                                        case "date":
                                            n1 = this.some(function(t1) {
                                                return +t1 === o1;
                                            });
                                            break;
                                        default:
                                            n1 = ~this.indexOf(t1);
                                    }
                                    n1 || ([].push.call(this, t1), this._registerAtomic("$addToSet", t1), this._markModified(), [].push.call(e1, t1));
                                }, this), e1;
                            }
                        },
                        {
                            key: "hasAtomics",
                            value: function() {
                                return O1.isPOJO(this[A1]) ? Object.keys(this[A1]).length : 0;
                            }
                        },
                        {
                            key: "includes",
                            value: function(t1, e1) {
                                return -1 !== this.indexOf(t1, e1);
                            }
                        },
                        {
                            key: "indexOf",
                            value: function(t1, e1) {
                                t1 instanceof v1 && (t1 = t1.toString()), e1 = null == e1 ? 0 : e1;
                                for(var r1 = this.length, n1 = e1; n1 < r1; ++n1)if (t1 == this[n1]) return n1;
                                return -1;
                            }
                        },
                        {
                            key: "inspect",
                            value: function() {
                                return JSON.stringify(this);
                            }
                        },
                        {
                            key: "nonAtomicPush",
                            value: function() {
                                var t1 = [].map.call(arguments, this._mapCast, this), e1 = [].push.apply(this, t1);
                                return this._registerAtomic("$set", this), this._markModified(), e1;
                            }
                        },
                        {
                            key: "pop",
                            value: function() {
                                var t1 = [].pop.call(this);
                                return this._registerAtomic("$set", this), this._markModified(), t1;
                            }
                        },
                        {
                            key: "pull",
                            value: function() {
                                for(var t1, e1 = [].map.call(arguments, this._cast, this), r1 = this[j1].get(this[E1]), n1 = r1.length; n1--;)if ((t1 = r1[n1]) instanceof d1) {
                                    var o1 = e1.some(function(e1) {
                                        return t1.equals(e1);
                                    });
                                    o1 && [].splice.call(r1, n1, 1);
                                } else ~r1.indexOf.call(e1, t1) && [].splice.call(r1, n1, 1);
                                return e1[0] instanceof m1 ? this._registerAtomic("$pullDocs", e1.map(function(t1) {
                                    return t1.$__getValue("_id") || t1;
                                })) : this._registerAtomic("$pullAll", e1), this._markModified(), g1(this[j1], this[E1]) > 0 && this._registerAtomic("$set", this), this;
                            }
                        },
                        {
                            key: "push",
                            value: function() {
                                var t1 = arguments, e1 = t1, r1 = null != t1[0] && O1.hasUserDefinedProperty(t1[0], "$each");
                                if (r1 && (e1 = t1[0], t1 = t1[0].$each), null == this[$1]) return N1.apply(this, t1);
                                C1(this, t1);
                                var n1, o1 = this[j1];
                                t1 = [].map.call(t1, this._mapCast, this), t1 = this[$1].applySetters(t1, o1, void 0, void 0, {
                                    skipDocumentArrayCast: !0
                                });
                                var i1 = this[A1];
                                if (r1) {
                                    if (e1.$each = t1, b1(i1, "$push.$each.length", 0) > 0 && i1.$push.$position != i1.$position) throw new _1("Cannot call `Array#push()` multiple times with different `$position`");
                                    null != e1.$position ? ([].splice.apply(this, [
                                        e1.$position,
                                        0
                                    ].concat(t1)), n1 = this.length) : n1 = [].push.apply(this, t1);
                                } else {
                                    if (b1(i1, "$push.$each.length", 0) > 0 && null != i1.$push.$position) throw new _1("Cannot call `Array#push()` multiple times with different `$position`");
                                    e1 = t1, n1 = [].push.apply(this, t1);
                                }
                                return this._registerAtomic("$push", e1), this._markModified(), n1;
                            }
                        },
                        {
                            key: "remove",
                            value: function() {
                                return this.pull.apply(this, arguments);
                            }
                        },
                        {
                            key: "set",
                            value: function(t1, e1) {
                                var r1 = this._cast(e1, t1);
                                return this[t1] = r1, this._markModified(t1), this;
                            }
                        },
                        {
                            key: "shift",
                            value: function() {
                                var t1 = [].shift.call(this);
                                return this._registerAtomic("$set", this), this._markModified(), t1;
                            }
                        },
                        {
                            key: "sort",
                            value: function() {
                                var t1 = [].sort.apply(this, arguments);
                                return this._registerAtomic("$set", this), t1;
                            }
                        },
                        {
                            key: "splice",
                            value: function() {
                                var t1;
                                if (C1(this, Array.prototype.slice.call(arguments, 2)), arguments.length) {
                                    var e1;
                                    if (null == this[$1]) e1 = arguments;
                                    else {
                                        e1 = [];
                                        for(var r1 = 0; r1 < arguments.length; ++r1)e1[r1] = r1 < 2 ? arguments[r1] : this._cast(arguments[r1], arguments[0] + (r1 - 2));
                                    }
                                    t1 = [].splice.apply(this, e1), this._registerAtomic("$set", this);
                                }
                                return t1;
                            }
                        },
                        {
                            key: "slice",
                            value: function() {
                                var t1 = u1(y1(S1.prototype), "slice", this).apply(this, arguments);
                                return t1[j1] = this[j1], t1[$1] = this[$1], t1[A1] = this[A1], t1[x1] = !0, t1;
                            }
                        },
                        {
                            key: "toBSON",
                            value: function() {
                                return this.toObject(w1);
                            }
                        },
                        {
                            key: "toObject",
                            value: function(t1) {
                                return t1 && t1.depopulate ? ((t1 = O1.clone(t1))._isNested = !0, [].concat(this).map(function(e1) {
                                    return e1 instanceof d1 ? e1.toObject(t1) : e1;
                                })) : [].concat(this);
                            }
                        },
                        {
                            key: "unshift",
                            value: function() {
                                var t1;
                                return C1(this, arguments), null == this[$1] ? t1 = arguments : (t1 = [].map.call(arguments, this._cast, this), t1 = this[$1].applySetters(t1, this[j1])), [].unshift.apply(this, t1), this._registerAtomic("$set", this), this._markModified(), this.length;
                            }
                        },
                        {
                            key: "isMongooseArray",
                            get: function() {
                                return !0;
                            }
                        },
                        {
                            key: "validators",
                            get: function() {
                                return this[T1];
                            },
                            set: function(t1) {
                                this[T1] = t1;
                            }
                        }
                    ], a1(o1.prototype, i1), l1 && a1(o1, l1), S1;
                }(l1(Array));
                /*!
 * ignore
 */ function C1(t1, e1) {
                    var r1, n1, i1, s1 = null == t1 ? null : b1(t1[$1], "caster.options.ref", null);
                    0 === t1.length && e1.length > 0 && /*!
 * ignore
 */ function(t1, e1) {
                        if (!e1) return !1;
                        var r1, n1 = o1(t1);
                        try {
                            for(n1.s(); !(r1 = n1.n()).done;){
                                var i1 = r1.value;
                                if (null == i1) return !1;
                                var s1 = i1.constructor;
                                if (!(i1 instanceof d1) || s1.modelName !== e1 && s1.baseModelName !== e1) return !1;
                            }
                        } catch (t1) {
                            n1.e(t1);
                        } finally{
                            n1.f();
                        }
                        return !0;
                    }(e1, s1) && t1[j1].populated(t1[E1], [], (r1 = {}, n1 = P1, i1 = e1[0].constructor, n1 in r1 ? Object.defineProperty(r1, n1, {
                        value: i1,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : r1[n1] = i1, r1));
                }
                S1.inspect.custom && (k1.prototype[S1.inspect.custom] = k1.prototype.inspect), t1.exports = k1;
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * ignore
 */ t1.exports = function(t1, e1, r1) {
                var n1 = (r1 = r1 || {}).skipDocArrays, o1 = 0;
                if (!t1) return o1;
                for(var i1 = 0, s1 = Object.keys(t1.$__.activePaths.states.modify); i1 < s1.length; i1++){
                    var a1 = s1[i1];
                    if (n1) {
                        var u1 = t1.schema.path(a1);
                        if (u1 && u1.$isMongooseDocumentArray) continue;
                    }
                    a1.startsWith(e1 + ".") && (delete t1.$__.activePaths.states.modify[a1], ++o1);
                }
                return o1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ var n1 = r1(15).get().Binary, o1 = r1(2), i1 = r1(63).Buffer;
            function s1(t1, e1, r1) {
                var n1, a1, c1, l1, f1, p1 = arguments.length;
                return n1 = 0 === p1 || null == arguments[0] ? 0 : t1, Array.isArray(e1) ? (c1 = e1[0], l1 = e1[1]) : a1 = e1, f1 = "number" == typeof n1 || n1 instanceof Number ? i1.alloc(n1) : i1.from(n1, a1, r1), o1.decorate(f1, s1.mixin), f1.isMongooseBuffer = !0, f1[s1.pathSymbol] = c1, f1[u1] = l1, f1._subtype = 0, f1;
            }
            var a1 = Symbol.for("mongoose#Buffer#_path"), u1 = Symbol.for("mongoose#Buffer#_parent");
            s1.pathSymbol = a1, /*!
 * Inherit from Buffer.
 */ s1.mixin = {
                _subtype: void 0,
                _markModified: function() {
                    var t1 = this[u1];
                    return t1 && t1.markModified(this[s1.pathSymbol]), this;
                },
                write: function() {
                    var t1 = i1.prototype.write.apply(this, arguments);
                    return t1 > 0 && this._markModified(), t1;
                },
                copy: function(t1) {
                    var e1 = i1.prototype.copy.apply(this, arguments);
                    return t1 && t1.isMongooseBuffer && t1._markModified(), e1;
                }
            }, /*!
 * Compile other Buffer methods marking this buffer as modified.
 */ "writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 writeFloat writeDouble fill utf8Write binaryWrite asciiWrite set writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE writeInt16LE writeInt16BE writeInt32LE writeInt32BE writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE".split(" ").forEach(function(t1) {
                i1.prototype[t1] && (s1.mixin[t1] = function() {
                    var e1 = i1.prototype[t1].apply(this, arguments);
                    return this._markModified(), e1;
                });
            }), s1.mixin.toObject = function(t1) {
                var e1 = "number" == typeof t1 ? t1 : this._subtype || 0;
                return new n1(i1.from(this), e1);
            }, s1.mixin.toBSON = function() {
                return new n1(this, this._subtype || 0);
            }, s1.mixin.equals = function(t1) {
                if (!i1.isBuffer(t1)) return !1;
                if (this.length !== t1.length) return !1;
                for(var e1 = 0; e1 < this.length; ++e1)if (this[e1] !== t1[e1]) return !1;
                return !0;
            }, s1.mixin.subtype = function(t1) {
                if ("number" != typeof t1) throw new TypeError("Invalid subtype. Expected a number");
                this._subtype !== t1 && this._markModified(), this._subtype = t1;
            }, /*!
 * Module exports.
 */ s1.Binary = n1, t1.exports = s1;
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(15).get().ObjectId, o1 = r1(22);
            t1.exports = function(t1) {
                if (null == t1) return t1;
                if (t1 instanceof n1) return t1;
                if (t1._id) {
                    if (t1._id instanceof n1) return t1._id;
                    if (t1._id.toString instanceof Function) return new n1(t1._id.toString());
                }
                if (t1.toString instanceof Function) return new n1(t1.toString());
                o1.ok(!1);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                var r1;
                if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                    if (Array.isArray(t1) || (r1 = function(t1, e1) {
                        if (!t1) return;
                        if ("string" == typeof t1) return i1(t1, e1);
                        var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                        "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                        if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                        if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return i1(t1, e1);
                    }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                        r1 && (t1 = r1);
                        var n1 = 0, o1 = function() {};
                        return {
                            s: o1,
                            n: function() {
                                return n1 >= t1.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t1[n1++]
                                };
                            },
                            e: function(t1) {
                                throw t1;
                            },
                            f: o1
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var s1, a1 = !0, u1 = !1;
                return {
                    s: function() {
                        r1 = t1[Symbol.iterator]();
                    },
                    n: function() {
                        var t1 = r1.next();
                        return a1 = t1.done, t1;
                    },
                    e: function(t1) {
                        u1 = !0, s1 = t1;
                    },
                    f: function() {
                        try {
                            a1 || null == r1.return || r1.return();
                        } finally{
                            if (u1) throw s1;
                        }
                    }
                };
            }
            function i1(t1, e1) {
                (null == e1 || e1 > t1.length) && (e1 = t1.length);
                for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                return n1;
            }
            function s1(t1, e1) {
                for(var r1 = 0; r1 < e1.length; r1++){
                    var n1 = e1[r1];
                    n1.enumerable = n1.enumerable || !1, n1.configurable = !0, "value" in n1 && (n1.writable = !0), Object.defineProperty(t1, n1.key, n1);
                }
            }
            function a1(t1, e1, r1) {
                return (a1 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t1, e1, r1) {
                    var n1 = function(t1, e1) {
                        for(; !Object.prototype.hasOwnProperty.call(t1, e1) && null !== (t1 = h1(t1)););
                        return t1;
                    }(t1, e1);
                    if (n1) {
                        var o1 = Object.getOwnPropertyDescriptor(n1, e1);
                        return o1.get ? o1.get.call(r1) : o1.value;
                    }
                })(t1, e1, r1 || t1);
            }
            function u1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function c1(t1) {
                var e1 = "function" == typeof Map ? new Map : void 0;
                return (c1 = function(t1) {
                    if (null === t1 || (r1 = t1, -1 === Function.toString.call(r1).indexOf("[native code]"))) return t1;
                    var r1;
                    if ("function" != typeof t1) throw new TypeError("Super expression must either be null or a function");
                    if (void 0 !== e1) {
                        if (e1.has(t1)) return e1.get(t1);
                        e1.set(t1, n1);
                    }
                    function n1() {
                        return l1(t1, arguments, h1(this).constructor);
                    }
                    return n1.prototype = Object.create(t1.prototype, {
                        constructor: {
                            value: n1,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), p1(n1, t1);
                })(t1);
            }
            function l1(t1, e1, r1) {
                return (l1 = f1() ? Reflect.construct : function(t1, e1, r1) {
                    var n1 = [
                        null
                    ];
                    n1.push.apply(n1, e1);
                    var o1 = new (Function.bind.apply(t1, n1));
                    return r1 && p1(o1, r1.prototype), o1;
                }).apply(null, arguments);
            }
            function f1() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                } catch (t1) {
                    return !1;
                }
            }
            function p1(t1, e1) {
                return (p1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function h1(t1) {
                return (h1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var y1 = r1(25), d1 = r1(2).deepEqual, m1 = r1(3), _1 = r1(88), v1 = r1(4), g1 = r1(47), b1 = r1(0).populateModelSymbol, w1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && p1(t1, e1);
                }(v1, t1);
                var e1, r1, n1, i1, c1, l1 = (e1 = v1, r1 = f1(), function() {
                    var t1, n1 = h1(e1);
                    if (r1) {
                        var o1 = h1(this).constructor;
                        t1 = Reflect.construct(n1, arguments, o1);
                    } else t1 = n1.apply(this, arguments);
                    return u1(this, t1);
                });
                function v1(t1, e1, r1, n1) {
                    var o1;
                    return function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, v1), null != t1 && "Object" === t1.constructor.name && (t1 = Object.keys(t1).reduce(function(e1, r1) {
                        return e1.concat([
                            [
                                r1,
                                t1[r1]
                            ]
                        ]);
                    }, [])), (o1 = l1.call(this, t1)).$__parent = null != r1 && null != r1.$__ ? r1 : null, o1.$__path = e1, o1.$__schemaType = null == n1 ? new y1(e1) : n1, o1.$__runDeferred(), o1;
                }
                return n1 = v1, i1 = [
                    {
                        key: "$init",
                        value: function(t1, e1) {
                            O1(t1), a1(h1(v1.prototype), "set", this).call(this, t1, e1), null != e1 && e1.$isSingleNested && (e1.$basePath = this.$__path + "." + t1);
                        }
                    },
                    {
                        key: "$__set",
                        value: function(t1, e1) {
                            a1(h1(v1.prototype), "set", this).call(this, t1, e1);
                        }
                    },
                    {
                        key: "get",
                        value: function(t1, e1) {
                            return !1 === (e1 = e1 || {}).getters ? a1(h1(v1.prototype), "get", this).call(this, t1) : this.$__schemaType.applyGetters(a1(h1(v1.prototype), "get", this).call(this, t1), this.$__parent);
                        }
                    },
                    {
                        key: "set",
                        value: function(t1, e1) {
                            if (O1(t1), e1 = _1(e1), null == this.$__schemaType) return this.$__deferred = this.$__deferred || [], void this.$__deferred.push({
                                key: t1,
                                value: e1
                            });
                            var r1 = this.$__path + "." + t1, n1 = null != this.$__parent && this.$__parent.$__ ? this.$__parent.populated(r1) || this.$__parent.populated(this.$__path) : null, o1 = this.get(t1);
                            if (null != n1) null == e1.$__ && (e1 = new n1.options[b1](e1)), e1.$__.wasPopulated = !0;
                            else try {
                                e1 = this.$__schemaType.applySetters(e1, this.$__parent, !1, this.get(t1));
                            } catch (t1) {
                                if (null != this.$__parent && null != this.$__parent.$__) return void this.$__parent.invalidate(r1, t1);
                                throw t1;
                            }
                            a1(h1(v1.prototype), "set", this).call(this, t1, e1), null != e1 && e1.$isSingleNested && (e1.$basePath = this.$__path + "." + t1);
                            var i1 = this.$__parent;
                            null == i1 || null == i1.$__ || d1(e1, o1) || i1.markModified(this.$__path + "." + t1);
                        }
                    },
                    {
                        key: "clear",
                        value: function() {
                            a1(h1(v1.prototype), "clear", this).call(this);
                            var t1 = this.$__parent;
                            null != t1 && t1.markModified(this.$__path);
                        }
                    },
                    {
                        key: "delete",
                        value: function(t1) {
                            this.set(t1, void 0), a1(h1(v1.prototype), "delete", this).call(this, t1);
                        }
                    },
                    {
                        key: "toBSON",
                        value: function() {
                            return new Map(this);
                        }
                    },
                    {
                        key: "toObject",
                        value: function(t1) {
                            if (m1(t1, "flattenMaps")) {
                                var e1, r1 = {}, n1 = o1(this.keys());
                                try {
                                    for(n1.s(); !(e1 = n1.n()).done;){
                                        var i1 = e1.value;
                                        r1[i1] = this.get(i1);
                                    }
                                } catch (t1) {
                                    n1.e(t1);
                                } finally{
                                    n1.f();
                                }
                                return r1;
                            }
                            return new Map(this);
                        }
                    },
                    {
                        key: "toJSON",
                        value: function() {
                            var t1, e1 = {}, r1 = o1(this.keys());
                            try {
                                for(r1.s(); !(t1 = r1.n()).done;){
                                    var n1 = t1.value;
                                    e1[n1] = this.get(n1);
                                }
                            } catch (t1) {
                                r1.e(t1);
                            } finally{
                                r1.f();
                            }
                            return e1;
                        }
                    },
                    {
                        key: "inspect",
                        value: function() {
                            return new Map(this);
                        }
                    },
                    {
                        key: "$__runDeferred",
                        value: function() {
                            if (this.$__deferred) {
                                var t1, e1 = o1(this.$__deferred);
                                try {
                                    for(e1.s(); !(t1 = e1.n()).done;){
                                        var r1 = t1.value;
                                        this.set(r1.key, r1.value);
                                    }
                                } catch (t1) {
                                    e1.e(t1);
                                } finally{
                                    e1.f();
                                }
                                this.$__deferred = null;
                            }
                        }
                    }
                ], s1(n1.prototype, i1), c1 && s1(n1, c1), v1;
            }(c1(Map));
            /*!
 * Since maps are stored as objects under the hood, keys must be strings
 * and can't contain any invalid characters
 */ function O1(t1) {
                var e1 = n1(t1);
                if ("string" !== e1) throw new TypeError("Mongoose maps only support string keys, got ".concat(e1));
                if (t1.startsWith("$")) throw new Error('Mongoose maps do not support keys that start with "$", got "'.concat(t1, '"'));
                if (t1.includes(".")) throw new Error('Mongoose maps do not support keys that contain ".", got "'.concat(t1, '"'));
                if (g1.has(t1)) throw new Error('Mongoose maps do not support reserved key name "'.concat(t1, '"'));
            }
            v1.inspect.custom && Object.defineProperty(w1.prototype, v1.inspect.custom, {
                enumerable: !1,
                writable: !1,
                configurable: !1,
                value: w1.prototype.inspect
            }), Object.defineProperty(w1.prototype, "$__set", {
                enumerable: !1,
                writable: !0,
                configurable: !1
            }), Object.defineProperty(w1.prototype, "$__parent", {
                enumerable: !1,
                writable: !0,
                configurable: !1
            }), Object.defineProperty(w1.prototype, "$__path", {
                enumerable: !1,
                writable: !0,
                configurable: !1
            }), Object.defineProperty(w1.prototype, "$__schemaType", {
                enumerable: !1,
                writable: !0,
                configurable: !1
            }), Object.defineProperty(w1.prototype, "$isMongooseMap", {
                enumerable: !1,
                writable: !1,
                configurable: !1,
                value: !0
            }), Object.defineProperty(w1.prototype, "$__deferredCalls", {
                enumerable: !1,
                writable: !1,
                configurable: !1,
                value: !0
            }), t1.exports = w1;
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(2);
            t1.exports = function(t1) {
                return n1.isPOJO(t1) && null != t1.$__ && null != t1._doc ? t1._doc : t1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1, e1) {
                var r1;
                if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                    if (Array.isArray(t1) || (r1 = function(t1, e1) {
                        if (!t1) return;
                        if ("string" == typeof t1) return o1(t1, e1);
                        var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                        "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                        if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                        if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return o1(t1, e1);
                    }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                        r1 && (t1 = r1);
                        var n1 = 0, i1 = function() {};
                        return {
                            s: i1,
                            n: function() {
                                return n1 >= t1.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t1[n1++]
                                };
                            },
                            e: function(t1) {
                                throw t1;
                            },
                            f: i1
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var s1, a1 = !0, u1 = !1;
                return {
                    s: function() {
                        r1 = t1[Symbol.iterator]();
                    },
                    n: function() {
                        var t1 = r1.next();
                        return a1 = t1.done, t1;
                    },
                    e: function(t1) {
                        u1 = !0, s1 = t1;
                    },
                    f: function() {
                        try {
                            a1 || null == r1.return || r1.return();
                        } finally{
                            if (u1) throw s1;
                        }
                    }
                };
            }
            function o1(t1, e1) {
                (null == e1 || e1 > t1.length) && (e1 = t1.length);
                for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                return n1;
            }
            var i1 = r1(6), s1 = r1(50), a1 = r1(17).internalToObjectOptions, u1 = r1(24), c1 = r1(0).documentArrayParent;
            function l1(t1, e1, r1, o1, s1) {
                var a1 = this;
                this.$isSingleNested = !0;
                var u1 = null != s1 && s1.priorDoc, c1 = null;
                if (u1 && (this._doc = Object.assign({}, s1.priorDoc._doc), delete this._doc[this.schema.options.discriminatorKey], c1 = Object.keys(s1.priorDoc._doc || {}).filter(function(t1) {
                    return t1 !== a1.schema.options.discriminatorKey;
                })), null != r1 && (s1 = Object.assign({}, s1, {
                    isNew: r1.isNew,
                    defaults: r1.$__.$options.defaults
                })), i1.call(this, t1, e1, o1, s1), u1) {
                    var l1, f1 = n1(c1);
                    try {
                        for(f1.s(); !(l1 = f1.n()).done;){
                            var p1 = l1.value;
                            if (!this.$__.activePaths.states.modify[p1] && !this.$__.activePaths.states.default[p1] && !this.$__.$setCalled.has(p1)) {
                                var h1 = this.schema.path(p1), y1 = null == h1 ? void 0 : h1.getDefault(this);
                                void 0 === y1 ? delete this._doc[p1] : (this._doc[p1] = y1, this.$__.activePaths.default(p1));
                            }
                        }
                    } catch (t1) {
                        f1.e(t1);
                    } finally{
                        f1.f();
                    }
                    delete s1.priorDoc, delete this.$__.$options.priorDoc;
                }
            }
            t1.exports = l1, l1.prototype = Object.create(i1.prototype), l1.prototype.toBSON = function() {
                return this.toObject(a1);
            }, l1.prototype.save = function(t1, e1) {
                var r1 = this;
                return "function" == typeof t1 && (e1 = t1, t1 = {}), (t1 = t1 || {}).suppressWarning || console.warn("mongoose: calling `save()` on a subdoc does **not** save the document to MongoDB, it only runs save middleware. Use `subdoc.save({ suppressWarning: true })` to hide this warning if you're sure this behavior is right for your app."), u1(e1, function(t1) {
                    r1.$__save(t1);
                });
            }, l1.prototype.$__save = function(t1) {
                var e1 = this;
                return s1(function() {
                    return t1(null, e1);
                });
            }, l1.prototype.$isValid = function(t1) {
                return this.$parent && this.$basePath ? this.$parent.$isValid([
                    this.$basePath,
                    t1
                ].join(".")) : i1.prototype.$isValid.call(this, t1);
            }, l1.prototype.markModified = function(t1) {
                if (i1.prototype.markModified.call(this, t1), this.$parent && this.$basePath) {
                    if (this.$parent.isDirectModified(this.$basePath)) return;
                    this.$parent.markModified([
                        this.$basePath,
                        t1
                    ].join("."), this);
                }
            }, l1.prototype.isModified = function(t1, e1) {
                var r1 = this;
                return this.$parent && this.$basePath ? Array.isArray(t1) || "string" == typeof t1 ? (t1 = (t1 = Array.isArray(t1) ? t1 : t1.split(" ")).map(function(t1) {
                    return [
                        r1.$basePath,
                        t1
                    ].join(".");
                }), this.$parent.isModified(t1, e1)) : this.$parent.isModified(this.$basePath) : i1.prototype.isModified.call(this, t1, e1);
            }, l1.prototype.$markValid = function(t1) {
                i1.prototype.$markValid.call(this, t1), this.$parent && this.$basePath && this.$parent.$markValid([
                    this.$basePath,
                    t1
                ].join("."));
            }, /*!
 * ignore
 */ l1.prototype.invalidate = function(t1, e1, r1) {
                if (e1 !== this.ownerDocument().$__.validationError && i1.prototype.invalidate.call(this, t1, e1, r1), this.$parent && this.$basePath) this.$parent.invalidate([
                    this.$basePath,
                    t1
                ].join("."), e1, r1);
                else if ("cast" === e1.kind || "CastError" === e1.name) throw e1;
                return this.ownerDocument().$__.validationError;
            }, /*!
 * ignore
 */ l1.prototype.$ignore = function(t1) {
                i1.prototype.$ignore.call(this, t1), this.$parent && this.$basePath && this.$parent.$ignore([
                    this.$basePath,
                    t1
                ].join("."));
            }, l1.prototype.ownerDocument = function() {
                if (this.$__.ownerDocument) return this.$__.ownerDocument;
                var t1 = this.$parent;
                if (!t1) return this;
                for(; t1.$parent || t1[c1];)t1 = t1.$parent || t1[c1];
                return this.$__.ownerDocument = t1, this.$__.ownerDocument;
            }, l1.prototype.parent = function() {
                return this.$parent;
            }, /*!
 * no-op for hooks
 */ l1.prototype.$__remove = function(t1) {
                return t1(null, this);
            }, l1.prototype.remove = function(t1, e1) {
                "function" == typeof t1 && (e1 = t1, t1 = null), /*!
 * Registers remove event listeners for triggering
 * on subdocuments.
 *
 * @param {Subdocument} sub
 * @api private
 */ function(t1) {
                    var e1 = t1.ownerDocument();
                    function r1() {
                        e1.removeListener("save", r1), e1.removeListener("remove", r1), t1.emit("remove", t1), t1.constructor.emit("remove", t1), e1 = t1 = null;
                    }
                    e1.on("save", r1), e1.on("remove", r1);
                }(this), t1 && t1.noop || this.$parent.set(this.$basePath, null), "function" == typeof e1 && e1(null);
            }, /*!
 * ignore
 */ l1.prototype.populate = function() {
                throw new Error('Mongoose does not support calling populate() on nested docs. Instead of `doc.nested.populate("path")`, use `doc.populate("nested.path")`');
            };
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1, e1) {
                var r1;
                if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                    if (Array.isArray(t1) || (r1 = function(t1, e1) {
                        if (!t1) return;
                        if ("string" == typeof t1) return o1(t1, e1);
                        var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                        "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                        if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                        if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return o1(t1, e1);
                    }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                        r1 && (t1 = r1);
                        var n1 = 0, i1 = function() {};
                        return {
                            s: i1,
                            n: function() {
                                return n1 >= t1.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t1[n1++]
                                };
                            },
                            e: function(t1) {
                                throw t1;
                            },
                            f: i1
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var s1, a1 = !0, u1 = !1;
                return {
                    s: function() {
                        r1 = t1[Symbol.iterator]();
                    },
                    n: function() {
                        var t1 = r1.next();
                        return a1 = t1.done, t1;
                    },
                    e: function(t1) {
                        u1 = !0, s1 = t1;
                    },
                    f: function() {
                        try {
                            a1 || null == r1.return || r1.return();
                        } finally{
                            if (u1) throw s1;
                        }
                    }
                };
            }
            function o1(t1, e1) {
                (null == e1 || e1 > t1.length) && (e1 = t1.length);
                for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                return n1;
            }
            var i1 = r1(25), s1 = r1(57).defineKey, a1 = r1(3), u1 = r1(2), c1 = {
                toJSON: !0,
                toObject: !0,
                _id: !0,
                id: !0
            };
            /*!
 * ignore
 */ t1.exports = function(t1, e1, r1, o1, l1) {
                if (!r1 || !r1.instanceOfSchema) throw new Error("You must pass a valid discriminator Schema");
                if (t1.schema.discriminatorMapping && !t1.schema.discriminatorMapping.isRoot) throw new Error('Discriminator "' + e1 + '" can only be a discriminator of the root model');
                if (l1) {
                    var f1 = a1(t1.base, "options.applyPluginsToDiscriminators", !1);
                    t1.base._applyPlugins(r1, {
                        skipTopLevel: !f1
                    });
                }
                var p1 = t1.schema.options.discriminatorKey, h1 = t1.schema.path(p1);
                if (null != h1) u1.hasUserDefinedProperty(h1.options, "select") || (h1.options.select = !0), h1.options.$skipDiscriminatorCheck = !0;
                else {
                    var y1 = {};
                    y1[p1] = {
                        default: void 0,
                        select: !0,
                        $skipDiscriminatorCheck: !0
                    }, y1[p1][t1.schema.options.typeKey] = String, t1.schema.add(y1), s1(p1, null, t1.prototype, null, [
                        p1
                    ], t1.schema.options);
                }
                if (r1.path(p1) && !0 !== r1.path(p1).options.$skipDiscriminatorCheck) throw new Error('Discriminator "' + e1 + '" cannot have field with name "' + p1 + '"');
                var d1 = e1;
                if ("string" == typeof o1 && o1.length && (d1 = o1), function(e1, r1) {
                    e1._baseSchema = r1, r1.paths._id && r1.paths._id.options && !r1.paths._id.options.auto && e1.remove("_id");
                    for(var o1 = [], s1 = 0, a1 = Object.keys(r1.paths); s1 < a1.length; s1++){
                        var l1 = a1[s1];
                        if (e1.nested[l1]) o1.push(l1);
                        else if (-1 !== l1.indexOf(".")) {
                            var f1, y1 = "", m1 = n1(l1.split(".").slice(0, -1));
                            try {
                                for(m1.s(); !(f1 = m1.n()).done;){
                                    var _1 = f1.value;
                                    y1 += (y1.length ? "." : "") + _1, (e1.paths[y1] instanceof i1 || e1.singleNestedPaths[y1] instanceof i1) && o1.push(l1);
                                }
                            } catch (t1) {
                                m1.e(t1);
                            } finally{
                                m1.f();
                            }
                        }
                    }
                    u1.merge(e1, r1, {
                        isDiscriminatorSchemaMerge: !0,
                        omit: {
                            discriminators: !0,
                            base: !0
                        },
                        omitNested: o1.reduce(function(t1, e1) {
                            return t1["tree." + e1] = !0, t1;
                        }, {})
                    });
                    for(var v1 = 0, g1 = o1; v1 < g1.length; v1++){
                        var b1 = g1[v1];
                        delete e1.paths[b1];
                    }
                    e1.childSchemas.forEach(function(t1) {
                        t1.model.prototype.$__setSchema(t1.schema);
                    });
                    var w1 = {};
                    w1[p1] = {
                        default: d1,
                        select: !0,
                        set: function(t1) {
                            if (t1 === d1) return d1;
                            throw new Error("Can't set discriminator key \"" + p1 + '"');
                        },
                        $skipDiscriminatorCheck: !0
                    }, w1[p1][e1.options.typeKey] = h1 ? h1.instance : String, e1.add(w1), e1.discriminatorMapping = {
                        key: p1,
                        value: d1,
                        isRoot: !1
                    }, r1.options.collection && (e1.options.collection = r1.options.collection);
                    var O1 = e1.options.toJSON, S1 = e1.options.toObject, A1 = e1.options._id, j1 = e1.options.id, E1 = Object.keys(e1.options);
                    e1.options.discriminatorKey = r1.options.discriminatorKey;
                    for(var $1 = 0, P1 = E1; $1 < P1.length; $1++){
                        var x1 = P1[$1];
                        if (!c1[x1]) {
                            if ("pluralization" === x1 && 1 == e1.options[x1] && null == r1.options[x1]) continue;
                            if (!u1.deepEqual(e1.options[x1], r1.options[x1])) throw new Error("Can't customize discriminator option " + x1 + " (can only modify " + Object.keys(c1).join(", ") + ")");
                        }
                    }
                    e1.options = u1.clone(r1.options), O1 && (e1.options.toJSON = O1), S1 && (e1.options.toObject = S1), void 0 !== A1 && (e1.options._id = A1), e1.options.id = j1, e1.s.hooks = t1.schema.s.hooks.merge(e1.s.hooks), e1.plugins = Array.prototype.slice.call(r1.plugins), e1.callQueue = r1.callQueue.concat(e1.callQueue), delete e1._requiredpaths;
                }(r1, t1.schema), t1.discriminators || (t1.discriminators = {}), t1.schema.discriminatorMapping || (t1.schema.discriminatorMapping = {
                    key: p1,
                    value: null,
                    isRoot: !0
                }), t1.schema.discriminators || (t1.schema.discriminators = {}), t1.schema.discriminators[e1] = r1, t1.discriminators[e1]) throw new Error('Discriminator with name "' + e1 + '" already exists');
                return r1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(74);
            t1.exports = function(t1, e1) {
                return null == e1 || null == e1._id || (t1 = t1.clone(), e1._id ? t1.paths._id || (n1(t1), t1.options._id = !0) : (t1.remove("_id"), t1.options._id = !1)), t1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(34);
            /*!
 * Find the correct constructor, taking into account discriminators
 */ t1.exports = function(t1, e1) {
                var r1 = t1.schema.options.discriminatorKey;
                if (null != e1 && t1.discriminators && null != e1[r1]) {
                    if (t1.discriminators[e1[r1]]) t1 = t1.discriminators[e1[r1]];
                    else {
                        var o1 = n1(t1, e1[r1]);
                        o1 && (t1 = o1);
                    }
                }
                return t1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            t1.exports = r1(94);
        },
        function(t1, e1, r1) {
            "use strict";
            (function(n1) {
                function o1(t1) {
                    return (o1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                function i1(t1, e1) {
                    return (i1 = Object.setPrototypeOf || function(t1, e1) {
                        return t1.__proto__ = e1, t1;
                    })(t1, e1);
                }
                function s1(t1) {
                    var e1 = function() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                        } catch (t1) {
                            return !1;
                        }
                    }();
                    return function() {
                        var r1, n1 = u1(t1);
                        if (e1) {
                            var o1 = u1(this).constructor;
                            r1 = Reflect.construct(n1, arguments, o1);
                        } else r1 = n1.apply(this, arguments);
                        return a1(this, r1);
                    };
                }
                function a1(t1, e1) {
                    return !e1 || "object" !== o1(e1) && "function" != typeof e1 ? function(t1) {
                        if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t1;
                    }(t1) : e1;
                }
                function u1(t1) {
                    return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                        return t1.__proto__ || Object.getPrototypeOf(t1);
                    })(t1);
                }
                r1(15).set(r1(98));
                var c1 = r1(61), l1 = r1(67);
                c1.setBrowser(!0), Object.defineProperty(e1, "Promise", {
                    get: function() {
                        return l1.get();
                    },
                    set: function(t1) {
                        l1.set(t1);
                    }
                }), e1.PromiseProvider = l1, e1.Error = r1(5), e1.Schema = r1(52), e1.Types = r1(56), e1.VirtualType = r1(53), e1.SchemaType = r1(7), e1.utils = r1(2), e1.Document = c1(), e1.model = function(t1, r1) {
                    var n1 = function(t1) {
                        !function(t1, e1) {
                            if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                            t1.prototype = Object.create(e1 && e1.prototype, {
                                constructor: {
                                    value: t1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), e1 && i1(t1, e1);
                        }(n1, t1);
                        var e1 = s1(n1);
                        function n1(t1, o1) {
                            return function(t1, e1) {
                                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                            }(this, n1), e1.call(this, t1, r1, o1);
                        }
                        return n1;
                    }(e1.Document);
                    return n1.modelName = t1, n1;
                }, /*!
 * Module exports.
 */ "undefined" != typeof window && (window.mongoose = t1.exports, window.Buffer = n1);
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            e1.byteLength = function(t1) {
                var e1 = c1(t1), r1 = e1[0], n1 = e1[1];
                return 3 * (r1 + n1) / 4 - n1;
            }, e1.toByteArray = function(t1) {
                var e1, r1, n1 = c1(t1), s1 = n1[0], a1 = n1[1], u1 = new i1(function(t1, e1, r1) {
                    return 3 * (e1 + r1) / 4 - r1;
                }(0, s1, a1)), l1 = 0, f1 = a1 > 0 ? s1 - 4 : s1;
                for(r1 = 0; r1 < f1; r1 += 4)e1 = o1[t1.charCodeAt(r1)] << 18 | o1[t1.charCodeAt(r1 + 1)] << 12 | o1[t1.charCodeAt(r1 + 2)] << 6 | o1[t1.charCodeAt(r1 + 3)], u1[l1++] = e1 >> 16 & 255, u1[l1++] = e1 >> 8 & 255, u1[l1++] = 255 & e1;
                2 === a1 && (e1 = o1[t1.charCodeAt(r1)] << 2 | o1[t1.charCodeAt(r1 + 1)] >> 4, u1[l1++] = 255 & e1);
                1 === a1 && (e1 = o1[t1.charCodeAt(r1)] << 10 | o1[t1.charCodeAt(r1 + 1)] << 4 | o1[t1.charCodeAt(r1 + 2)] >> 2, u1[l1++] = e1 >> 8 & 255, u1[l1++] = 255 & e1);
                return u1;
            }, e1.fromByteArray = function(t1) {
                for(var e1, r1 = t1.length, o1 = r1 % 3, i1 = [], s1 = 0, a1 = r1 - o1; s1 < a1; s1 += 16383)i1.push(l1(t1, s1, s1 + 16383 > a1 ? a1 : s1 + 16383));
                1 === o1 ? (e1 = t1[r1 - 1], i1.push(n1[e1 >> 2] + n1[e1 << 4 & 63] + "==")) : 2 === o1 && (e1 = (t1[r1 - 2] << 8) + t1[r1 - 1], i1.push(n1[e1 >> 10] + n1[e1 >> 4 & 63] + n1[e1 << 2 & 63] + "="));
                return i1.join("");
            };
            for(var n1 = [], o1 = [], i1 = "undefined" != typeof Uint8Array ? Uint8Array : Array, s1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a1 = 0, u1 = s1.length; a1 < u1; ++a1)n1[a1] = s1[a1], o1[s1.charCodeAt(a1)] = a1;
            function c1(t1) {
                var e1 = t1.length;
                if (e1 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                var r1 = t1.indexOf("=");
                return -1 === r1 && (r1 = e1), [
                    r1,
                    r1 === e1 ? 0 : 4 - r1 % 4
                ];
            }
            function l1(t1, e1, r1) {
                for(var o1, i1, s1 = [], a1 = e1; a1 < r1; a1 += 3)o1 = (t1[a1] << 16 & 16711680) + (t1[a1 + 1] << 8 & 65280) + (255 & t1[a1 + 2]), s1.push(n1[(i1 = o1) >> 18 & 63] + n1[i1 >> 12 & 63] + n1[i1 >> 6 & 63] + n1[63 & i1]);
                return s1.join("");
            }
            o1["-".charCodeAt(0)] = 62, o1["_".charCodeAt(0)] = 63;
        },
        function(t1, e1) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ e1.read = function(t1, e1, r1, n1, o1) {
                var i1, s1, a1 = 8 * o1 - n1 - 1, u1 = (1 << a1) - 1, c1 = u1 >> 1, l1 = -7, f1 = r1 ? o1 - 1 : 0, p1 = r1 ? -1 : 1, h1 = t1[e1 + f1];
                for(f1 += p1, i1 = h1 & (1 << -l1) - 1, h1 >>= -l1, l1 += a1; l1 > 0; i1 = 256 * i1 + t1[e1 + f1], f1 += p1, l1 -= 8);
                for(s1 = i1 & (1 << -l1) - 1, i1 >>= -l1, l1 += n1; l1 > 0; s1 = 256 * s1 + t1[e1 + f1], f1 += p1, l1 -= 8);
                if (0 === i1) i1 = 1 - c1;
                else {
                    if (i1 === u1) return s1 ? NaN : 1 / 0 * (h1 ? -1 : 1);
                    s1 += Math.pow(2, n1), i1 -= c1;
                }
                return (h1 ? -1 : 1) * s1 * Math.pow(2, i1 - n1);
            }, e1.write = function(t1, e1, r1, n1, o1, i1) {
                var s1, a1, u1, c1 = 8 * i1 - o1 - 1, l1 = (1 << c1) - 1, f1 = l1 >> 1, p1 = 23 === o1 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h1 = n1 ? 0 : i1 - 1, y1 = n1 ? 1 : -1, d1 = e1 < 0 || 0 === e1 && 1 / e1 < 0 ? 1 : 0;
                for(e1 = Math.abs(e1), isNaN(e1) || e1 === 1 / 0 ? (a1 = isNaN(e1) ? 1 : 0, s1 = l1) : (s1 = Math.floor(Math.log(e1) / Math.LN2), e1 * (u1 = Math.pow(2, -s1)) < 1 && (s1--, u1 *= 2), (e1 += s1 + f1 >= 1 ? p1 / u1 : p1 * Math.pow(2, 1 - f1)) * u1 >= 2 && (s1++, u1 /= 2), s1 + f1 >= l1 ? (a1 = 0, s1 = l1) : s1 + f1 >= 1 ? (a1 = (e1 * u1 - 1) * Math.pow(2, o1), s1 += f1) : (a1 = e1 * Math.pow(2, f1 - 1) * Math.pow(2, o1), s1 = 0)); o1 >= 8; t1[r1 + h1] = 255 & a1, h1 += y1, a1 /= 256, o1 -= 8);
                for(s1 = s1 << o1 | a1, c1 += o1; c1 > 0; t1[r1 + h1] = 255 & s1, h1 += y1, s1 /= 256, c1 -= 8);
                t1[r1 + h1 - y1] |= 128 * d1;
            };
        },
        function(t1, e1) {
            var r1 = {}.toString;
            t1.exports = Array.isArray || function(t1) {
                return "[object Array]" == r1.call(t1);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module exports.
 */ e1.Binary = r1(99), e1.Collection = function() {
                throw new Error("Cannot create a collection from browser library");
            }, e1.Decimal128 = r1(106), e1.ObjectId = r1(107), e1.ReadPreference = r1(108);
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ var n1 = r1(35).Binary;
            /*!
 * Module exports.
 */ t1.exports = n1;
        },
        function(t1, e1) {
            function r1(t1) {
                return (r1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            t1.exports = function(t1) {
                return t1 && "object" === r1(t1) && "function" == typeof t1.copy && "function" == typeof t1.fill && "function" == typeof t1.readUInt8;
            };
        },
        function(t1, e1) {
            "function" == typeof Object.create ? t1.exports = function(t1, e1) {
                t1.super_ = e1, t1.prototype = Object.create(e1.prototype, {
                    constructor: {
                        value: t1,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                });
            } : t1.exports = function(t1, e1) {
                t1.super_ = e1;
                var r1 = function() {};
                r1.prototype = e1.prototype, t1.prototype = new r1, t1.prototype.constructor = t1;
            };
        },
        function(module, exports, __webpack_require__) {
            "use strict";
            var Long = __webpack_require__(23).Long, Double = __webpack_require__(36).Double, Timestamp = __webpack_require__(37).Timestamp, ObjectID = __webpack_require__(38).ObjectID, _Symbol = __webpack_require__(40).Symbol, Code = __webpack_require__(41).Code, MinKey = __webpack_require__(43).MinKey, MaxKey = __webpack_require__(44).MaxKey, Decimal128 = __webpack_require__(42), Int32 = __webpack_require__(60), DBRef = __webpack_require__(45).DBRef, BSONRegExp = __webpack_require__(39).BSONRegExp, Binary = __webpack_require__(27).Binary, utils = __webpack_require__(16), deserialize = function(t1, e1, r1) {
                var n1 = (e1 = null == e1 ? {} : e1) && e1.index ? e1.index : 0, o1 = t1[n1] | t1[n1 + 1] << 8 | t1[n1 + 2] << 16 | t1[n1 + 3] << 24;
                if (o1 < 5 || t1.length < o1 || o1 + n1 > t1.length) throw new Error("corrupt bson message");
                if (0 !== t1[n1 + o1 - 1]) throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
                return deserializeObject(t1, n1, e1, r1);
            }, deserializeObject = function t1(e1, r1, n1, o1) {
                var i1 = null != n1.evalFunctions && n1.evalFunctions, s1 = null != n1.cacheFunctions && n1.cacheFunctions, a1 = null != n1.cacheFunctionsCrc32 && n1.cacheFunctionsCrc32;
                if (!a1) var u1 = null;
                var c1 = null == n1.fieldsAsRaw ? null : n1.fieldsAsRaw, l1 = null != n1.raw && n1.raw, f1 = "boolean" == typeof n1.bsonRegExp && n1.bsonRegExp, p1 = null != n1.promoteBuffers && n1.promoteBuffers, h1 = null == n1.promoteLongs || n1.promoteLongs, y1 = null == n1.promoteValues || n1.promoteValues, d1 = r1;
                if (e1.length < 5) throw new Error("corrupt bson message < 5 bytes long");
                var m1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24;
                if (m1 < 5 || m1 > e1.length) throw new Error("corrupt bson message");
                for(var _1 = o1 ? [] : {}, v1 = 0;;){
                    var g1 = e1[r1++];
                    if (0 === g1) break;
                    for(var b1 = r1; 0 !== e1[b1] && b1 < e1.length;)b1++;
                    if (b1 >= e1.length) throw new Error("Bad BSON Document: illegal CString");
                    var w1 = o1 ? v1++ : e1.toString("utf8", r1, b1);
                    if (r1 = b1 + 1, g1 === BSON.BSON_DATA_STRING) {
                        var O1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24;
                        if (O1 <= 0 || O1 > e1.length - r1 || 0 !== e1[r1 + O1 - 1]) throw new Error("bad string length in bson");
                        _1[w1] = e1.toString("utf8", r1, r1 + O1 - 1), r1 += O1;
                    } else if (g1 === BSON.BSON_DATA_OID) {
                        var S1 = utils.allocBuffer(12);
                        e1.copy(S1, 0, r1, r1 + 12), _1[w1] = new ObjectID(S1), r1 += 12;
                    } else if (g1 === BSON.BSON_DATA_INT && !1 === y1) _1[w1] = new Int32(e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24);
                    else if (g1 === BSON.BSON_DATA_INT) _1[w1] = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24;
                    else if (g1 === BSON.BSON_DATA_NUMBER && !1 === y1) _1[w1] = new Double(e1.readDoubleLE(r1)), r1 += 8;
                    else if (g1 === BSON.BSON_DATA_NUMBER) _1[w1] = e1.readDoubleLE(r1), r1 += 8;
                    else if (g1 === BSON.BSON_DATA_DATE) {
                        var A1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24, j1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24;
                        _1[w1] = new Date(new Long(A1, j1).toNumber());
                    } else if (g1 === BSON.BSON_DATA_BOOLEAN) {
                        if (0 !== e1[r1] && 1 !== e1[r1]) throw new Error("illegal boolean type value");
                        _1[w1] = 1 === e1[r1++];
                    } else if (g1 === BSON.BSON_DATA_OBJECT) {
                        var E1 = r1, $1 = e1[r1] | e1[r1 + 1] << 8 | e1[r1 + 2] << 16 | e1[r1 + 3] << 24;
                        if ($1 <= 0 || $1 > e1.length - r1) throw new Error("bad embedded document length in bson");
                        _1[w1] = l1 ? e1.slice(r1, r1 + $1) : t1(e1, E1, n1, !1), r1 += $1;
                    } else if (g1 === BSON.BSON_DATA_ARRAY) {
                        E1 = r1;
                        var P1 = n1, x1 = r1 + ($1 = e1[r1] | e1[r1 + 1] << 8 | e1[r1 + 2] << 16 | e1[r1 + 3] << 24);
                        if (c1 && c1[w1]) {
                            for(var N1 in P1 = {}, n1)P1[N1] = n1[N1];
                            P1.raw = !0;
                        }
                        if (_1[w1] = t1(e1, E1, P1, !0), 0 !== e1[(r1 += $1) - 1]) throw new Error("invalid array terminator byte");
                        if (r1 !== x1) throw new Error("corrupted array bson");
                    } else if (g1 === BSON.BSON_DATA_UNDEFINED) _1[w1] = void 0;
                    else if (g1 === BSON.BSON_DATA_NULL) _1[w1] = null;
                    else if (g1 === BSON.BSON_DATA_LONG) {
                        A1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24, j1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24;
                        var T1 = new Long(A1, j1);
                        _1[w1] = h1 && !0 === y1 && T1.lessThanOrEqual(JS_INT_MAX_LONG) && T1.greaterThanOrEqual(JS_INT_MIN_LONG) ? T1.toNumber() : T1;
                    } else if (g1 === BSON.BSON_DATA_DECIMAL128) {
                        var k1 = utils.allocBuffer(16);
                        e1.copy(k1, 0, r1, r1 + 16), r1 += 16;
                        var C1 = new Decimal128(k1);
                        _1[w1] = C1.toObject ? C1.toObject() : C1;
                    } else if (g1 === BSON.BSON_DATA_BINARY) {
                        var D1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24, R1 = D1, B1 = e1[r1++];
                        if (D1 < 0) throw new Error("Negative binary type element size found");
                        if (D1 > e1.length) throw new Error("Binary type size larger than document size");
                        if (null != e1.slice) {
                            if (B1 === Binary.SUBTYPE_BYTE_ARRAY) {
                                if ((D1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24) < 0) throw new Error("Negative binary type element size found for subtype 0x02");
                                if (D1 > R1 - 4) throw new Error("Binary type with subtype 0x02 contains to long binary size");
                                if (D1 < R1 - 4) throw new Error("Binary type with subtype 0x02 contains to short binary size");
                            }
                            _1[w1] = p1 && y1 ? e1.slice(r1, r1 + D1) : new Binary(e1.slice(r1, r1 + D1), B1);
                        } else {
                            var M1 = "undefined" != typeof Uint8Array ? new Uint8Array(new ArrayBuffer(D1)) : new Array(D1);
                            if (B1 === Binary.SUBTYPE_BYTE_ARRAY) {
                                if ((D1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24) < 0) throw new Error("Negative binary type element size found for subtype 0x02");
                                if (D1 > R1 - 4) throw new Error("Binary type with subtype 0x02 contains to long binary size");
                                if (D1 < R1 - 4) throw new Error("Binary type with subtype 0x02 contains to short binary size");
                            }
                            for(b1 = 0; b1 < D1; b1++)M1[b1] = e1[r1 + b1];
                            _1[w1] = p1 && y1 ? M1 : new Binary(M1, B1);
                        }
                        r1 += D1;
                    } else if (g1 === BSON.BSON_DATA_REGEXP && !1 === f1) {
                        for(b1 = r1; 0 !== e1[b1] && b1 < e1.length;)b1++;
                        if (b1 >= e1.length) throw new Error("Bad BSON Document: illegal CString");
                        var I1 = e1.toString("utf8", r1, b1);
                        for(b1 = r1 = b1 + 1; 0 !== e1[b1] && b1 < e1.length;)b1++;
                        if (b1 >= e1.length) throw new Error("Bad BSON Document: illegal CString");
                        var F1 = e1.toString("utf8", r1, b1);
                        r1 = b1 + 1;
                        var L1 = new Array(F1.length);
                        for(b1 = 0; b1 < F1.length; b1++)switch(F1[b1]){
                            case "m":
                                L1[b1] = "m";
                                break;
                            case "s":
                                L1[b1] = "g";
                                break;
                            case "i":
                                L1[b1] = "i";
                        }
                        _1[w1] = new RegExp(I1, L1.join(""));
                    } else if (g1 === BSON.BSON_DATA_REGEXP && !0 === f1) {
                        for(b1 = r1; 0 !== e1[b1] && b1 < e1.length;)b1++;
                        if (b1 >= e1.length) throw new Error("Bad BSON Document: illegal CString");
                        for(I1 = e1.toString("utf8", r1, b1), b1 = r1 = b1 + 1; 0 !== e1[b1] && b1 < e1.length;)b1++;
                        if (b1 >= e1.length) throw new Error("Bad BSON Document: illegal CString");
                        F1 = e1.toString("utf8", r1, b1), r1 = b1 + 1, _1[w1] = new BSONRegExp(I1, F1);
                    } else if (g1 === BSON.BSON_DATA_SYMBOL) {
                        if ((O1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24) <= 0 || O1 > e1.length - r1 || 0 !== e1[r1 + O1 - 1]) throw new Error("bad string length in bson");
                        _1[w1] = new _Symbol(e1.toString("utf8", r1, r1 + O1 - 1)), r1 += O1;
                    } else if (g1 === BSON.BSON_DATA_TIMESTAMP) A1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24, j1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24, _1[w1] = new Timestamp(A1, j1);
                    else if (g1 === BSON.BSON_DATA_MIN_KEY) _1[w1] = new MinKey;
                    else if (g1 === BSON.BSON_DATA_MAX_KEY) _1[w1] = new MaxKey;
                    else if (g1 === BSON.BSON_DATA_CODE) {
                        if ((O1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24) <= 0 || O1 > e1.length - r1 || 0 !== e1[r1 + O1 - 1]) throw new Error("bad string length in bson");
                        var U1 = e1.toString("utf8", r1, r1 + O1 - 1);
                        if (i1) {
                            if (s1) {
                                var V1 = a1 ? u1(U1) : U1;
                                _1[w1] = isolateEvalWithHash(functionCache, V1, U1, _1);
                            } else _1[w1] = isolateEval(U1);
                        } else _1[w1] = new Code(U1);
                        r1 += O1;
                    } else if (g1 === BSON.BSON_DATA_CODE_W_SCOPE) {
                        var q1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24;
                        if (q1 < 13) throw new Error("code_w_scope total size shorter minimum expected length");
                        if ((O1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24) <= 0 || O1 > e1.length - r1 || 0 !== e1[r1 + O1 - 1]) throw new Error("bad string length in bson");
                        U1 = e1.toString("utf8", r1, r1 + O1 - 1), E1 = r1 += O1, $1 = e1[r1] | e1[r1 + 1] << 8 | e1[r1 + 2] << 16 | e1[r1 + 3] << 24;
                        var W1 = t1(e1, E1, n1, !1);
                        if (r1 += $1, q1 < 8 + $1 + O1) throw new Error("code_w_scope total size is to short, truncating scope");
                        if (q1 > 8 + $1 + O1) throw new Error("code_w_scope total size is to long, clips outer document");
                        i1 ? (s1 ? (V1 = a1 ? u1(U1) : U1, _1[w1] = isolateEvalWithHash(functionCache, V1, U1, _1)) : _1[w1] = isolateEval(U1), _1[w1].scope = W1) : _1[w1] = new Code(U1, W1);
                    } else {
                        if (g1 !== BSON.BSON_DATA_DBPOINTER) throw new Error("Detected unknown BSON type " + g1.toString(16) + ' for fieldname "' + w1 + '", are you using the latest BSON parser');
                        if ((O1 = e1[r1++] | e1[r1++] << 8 | e1[r1++] << 16 | e1[r1++] << 24) <= 0 || O1 > e1.length - r1 || 0 !== e1[r1 + O1 - 1]) throw new Error("bad string length in bson");
                        var H1 = e1.toString("utf8", r1, r1 + O1 - 1);
                        r1 += O1;
                        var Y1 = utils.allocBuffer(12);
                        e1.copy(Y1, 0, r1, r1 + 12), S1 = new ObjectID(Y1), r1 += 12;
                        var K1 = H1.split("."), z1 = K1.shift(), Q1 = K1.join(".");
                        _1[w1] = new DBRef(Q1, S1, z1);
                    }
                }
                if (m1 !== r1 - d1) {
                    if (o1) throw new Error("corrupt array bson");
                    throw new Error("corrupt object bson");
                }
                return null != _1.$id && (_1 = new DBRef(_1.$ref, _1.$id, _1.$db)), _1;
            }, isolateEvalWithHash = function isolateEvalWithHash(functionCache, hash, functionString, object) {
                var value = null;
                return null == functionCache[hash] && (eval("value = " + functionString), functionCache[hash] = value), functionCache[hash].bind(object);
            }, isolateEval = function isolateEval(functionString) {
                var value = null;
                return eval("value = " + functionString), value;
            }, BSON = {}, functionCache = BSON.functionCache = {};
            BSON.BSON_DATA_NUMBER = 1, BSON.BSON_DATA_STRING = 2, BSON.BSON_DATA_OBJECT = 3, BSON.BSON_DATA_ARRAY = 4, BSON.BSON_DATA_BINARY = 5, BSON.BSON_DATA_UNDEFINED = 6, BSON.BSON_DATA_OID = 7, BSON.BSON_DATA_BOOLEAN = 8, BSON.BSON_DATA_DATE = 9, BSON.BSON_DATA_NULL = 10, BSON.BSON_DATA_REGEXP = 11, BSON.BSON_DATA_DBPOINTER = 12, BSON.BSON_DATA_CODE = 13, BSON.BSON_DATA_SYMBOL = 14, BSON.BSON_DATA_CODE_W_SCOPE = 15, BSON.BSON_DATA_INT = 16, BSON.BSON_DATA_TIMESTAMP = 17, BSON.BSON_DATA_LONG = 18, BSON.BSON_DATA_DECIMAL128 = 19, BSON.BSON_DATA_MIN_KEY = 255, BSON.BSON_DATA_MAX_KEY = 127, BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0, BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1, BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2, BSON.BSON_BINARY_SUBTYPE_UUID = 3, BSON.BSON_BINARY_SUBTYPE_MD5 = 4, BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128, BSON.BSON_INT32_MAX = 2147483647, BSON.BSON_INT32_MIN = -2147483648, BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1, BSON.BSON_INT64_MIN = -Math.pow(2, 63), BSON.JS_INT_MAX = 9007199254740992, BSON.JS_INT_MIN = -9007199254740992;
            var JS_INT_MAX_LONG = Long.fromNumber(9007199254740992), JS_INT_MIN_LONG = Long.fromNumber(-9007199254740992);
            module.exports = deserialize;
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                function n1(t1) {
                    return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                var o1 = r1(104).writeIEEE754, i1 = r1(23).Long, s1 = r1(59), a1 = r1(27).Binary, u1 = r1(16).normalizedFunctionString, c1 = /\x00/, l1 = [
                    "$db",
                    "$ref",
                    "$id",
                    "$clusterTime"
                ], f1 = function(t1) {
                    return "object" === n1(t1) && "[object Date]" === Object.prototype.toString.call(t1);
                }, p1 = function(t1) {
                    return "[object RegExp]" === Object.prototype.toString.call(t1);
                }, h1 = function(t1, e1, r1, n1, o1) {
                    t1[n1++] = D1.BSON_DATA_STRING;
                    var i1 = o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8");
                    t1[(n1 = n1 + i1 + 1) - 1] = 0;
                    var s1 = t1.write(r1, n1 + 4, "utf8");
                    return t1[n1 + 3] = s1 + 1 >> 24 & 255, t1[n1 + 2] = s1 + 1 >> 16 & 255, t1[n1 + 1] = s1 + 1 >> 8 & 255, t1[n1] = s1 + 1 & 255, n1 = n1 + 4 + s1, t1[n1++] = 0, n1;
                }, y1 = function(t1, e1, r1, n1, s1) {
                    if (Math.floor(r1) === r1 && r1 >= D1.JS_INT_MIN && r1 <= D1.JS_INT_MAX) {
                        if (r1 >= D1.BSON_INT32_MIN && r1 <= D1.BSON_INT32_MAX) {
                            t1[n1++] = D1.BSON_DATA_INT;
                            var a1 = s1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8");
                            n1 += a1, t1[n1++] = 0, t1[n1++] = 255 & r1, t1[n1++] = r1 >> 8 & 255, t1[n1++] = r1 >> 16 & 255, t1[n1++] = r1 >> 24 & 255;
                        } else if (r1 >= D1.JS_INT_MIN && r1 <= D1.JS_INT_MAX) t1[n1++] = D1.BSON_DATA_NUMBER, n1 += a1 = s1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0, o1(t1, r1, n1, "little", 52, 8), n1 += 8;
                        else {
                            t1[n1++] = D1.BSON_DATA_LONG, n1 += a1 = s1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0;
                            var u1 = i1.fromNumber(r1), c1 = u1.getLowBits(), l1 = u1.getHighBits();
                            t1[n1++] = 255 & c1, t1[n1++] = c1 >> 8 & 255, t1[n1++] = c1 >> 16 & 255, t1[n1++] = c1 >> 24 & 255, t1[n1++] = 255 & l1, t1[n1++] = l1 >> 8 & 255, t1[n1++] = l1 >> 16 & 255, t1[n1++] = l1 >> 24 & 255;
                        }
                    } else t1[n1++] = D1.BSON_DATA_NUMBER, n1 += a1 = s1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0, o1(t1, r1, n1, "little", 52, 8), n1 += 8;
                    return n1;
                }, d1 = function(t1, e1, r1, n1, o1) {
                    return t1[n1++] = D1.BSON_DATA_NULL, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0, n1;
                }, m1 = function(t1, e1, r1, n1, o1) {
                    return t1[n1++] = D1.BSON_DATA_BOOLEAN, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0, t1[n1++] = r1 ? 1 : 0, n1;
                }, _1 = function(t1, e1, r1, n1, o1) {
                    t1[n1++] = D1.BSON_DATA_DATE, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0;
                    var s1 = i1.fromNumber(r1.getTime()), a1 = s1.getLowBits(), u1 = s1.getHighBits();
                    return t1[n1++] = 255 & a1, t1[n1++] = a1 >> 8 & 255, t1[n1++] = a1 >> 16 & 255, t1[n1++] = a1 >> 24 & 255, t1[n1++] = 255 & u1, t1[n1++] = u1 >> 8 & 255, t1[n1++] = u1 >> 16 & 255, t1[n1++] = u1 >> 24 & 255, n1;
                }, v1 = function(t1, e1, r1, n1, o1) {
                    if (t1[n1++] = D1.BSON_DATA_REGEXP, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0, r1.source && null != r1.source.match(c1)) throw Error("value " + r1.source + " must not contain null bytes");
                    return n1 += t1.write(r1.source, n1, "utf8"), t1[n1++] = 0, r1.global && (t1[n1++] = 115), r1.ignoreCase && (t1[n1++] = 105), r1.multiline && (t1[n1++] = 109), t1[n1++] = 0, n1;
                }, g1 = function(t1, e1, r1, n1, o1) {
                    if (t1[n1++] = D1.BSON_DATA_REGEXP, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0, null != r1.pattern.match(c1)) throw Error("pattern " + r1.pattern + " must not contain null bytes");
                    return n1 += t1.write(r1.pattern, n1, "utf8"), t1[n1++] = 0, n1 += t1.write(r1.options.split("").sort().join(""), n1, "utf8"), t1[n1++] = 0, n1;
                }, b1 = function(t1, e1, r1, n1, o1) {
                    return null === r1 ? t1[n1++] = D1.BSON_DATA_NULL : "MinKey" === r1._bsontype ? t1[n1++] = D1.BSON_DATA_MIN_KEY : t1[n1++] = D1.BSON_DATA_MAX_KEY, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0, n1;
                }, w1 = function(t1, e1, r1, n1, o1) {
                    if (t1[n1++] = D1.BSON_DATA_OID, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0, "string" == typeof r1.id) t1.write(r1.id, n1, "binary");
                    else {
                        if (!r1.id || !r1.id.copy) throw new Error("object [" + JSON.stringify(r1) + "] is not a valid ObjectId");
                        r1.id.copy(t1, n1, 0, 12);
                    }
                    return n1 + 12;
                }, O1 = function(t1, e1, r1, n1, o1) {
                    t1[n1++] = D1.BSON_DATA_BINARY, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0;
                    var i1 = r1.length;
                    return t1[n1++] = 255 & i1, t1[n1++] = i1 >> 8 & 255, t1[n1++] = i1 >> 16 & 255, t1[n1++] = i1 >> 24 & 255, t1[n1++] = D1.BSON_BINARY_SUBTYPE_DEFAULT, r1.copy(t1, n1, 0, i1), n1 += i1;
                }, S1 = function(t1, e1, r1, n1, o1, i1, s1, a1, u1, c1) {
                    for(var l1 = 0; l1 < c1.length; l1++)if (c1[l1] === r1) throw new Error("cyclic dependency detected");
                    c1.push(r1), t1[n1++] = Array.isArray(r1) ? D1.BSON_DATA_ARRAY : D1.BSON_DATA_OBJECT, n1 += u1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0;
                    var f1 = C1(t1, r1, o1, n1, i1 + 1, s1, a1, c1);
                    return c1.pop(), f1;
                }, A1 = function(t1, e1, r1, n1, o1) {
                    return t1[n1++] = D1.BSON_DATA_DECIMAL128, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0, r1.bytes.copy(t1, n1, 0, 16), n1 + 16;
                }, j1 = function(t1, e1, r1, n1, o1) {
                    t1[n1++] = "Long" === r1._bsontype ? D1.BSON_DATA_LONG : D1.BSON_DATA_TIMESTAMP, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0;
                    var i1 = r1.getLowBits(), s1 = r1.getHighBits();
                    return t1[n1++] = 255 & i1, t1[n1++] = i1 >> 8 & 255, t1[n1++] = i1 >> 16 & 255, t1[n1++] = i1 >> 24 & 255, t1[n1++] = 255 & s1, t1[n1++] = s1 >> 8 & 255, t1[n1++] = s1 >> 16 & 255, t1[n1++] = s1 >> 24 & 255, n1;
                }, E1 = function(t1, e1, r1, n1, o1) {
                    return t1[n1++] = D1.BSON_DATA_INT, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0, t1[n1++] = 255 & r1, t1[n1++] = r1 >> 8 & 255, t1[n1++] = r1 >> 16 & 255, t1[n1++] = r1 >> 24 & 255, n1;
                }, $1 = function(t1, e1, r1, n1, i1) {
                    return t1[n1++] = D1.BSON_DATA_NUMBER, n1 += i1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0, o1(t1, r1, n1, "little", 52, 8), n1 += 8;
                }, P1 = function(t1, e1, r1, n1, o1, i1, s1) {
                    t1[n1++] = D1.BSON_DATA_CODE, n1 += s1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0;
                    var a1 = u1(r1), c1 = t1.write(a1, n1 + 4, "utf8") + 1;
                    return t1[n1] = 255 & c1, t1[n1 + 1] = c1 >> 8 & 255, t1[n1 + 2] = c1 >> 16 & 255, t1[n1 + 3] = c1 >> 24 & 255, n1 = n1 + 4 + c1 - 1, t1[n1++] = 0, n1;
                }, x1 = function(t1, e1, r1, o1, i1, s1, a1, u1, c1) {
                    if (r1.scope && "object" === n1(r1.scope)) {
                        t1[o1++] = D1.BSON_DATA_CODE_W_SCOPE;
                        var l1 = c1 ? t1.write(e1, o1, "ascii") : t1.write(e1, o1, "utf8");
                        o1 += l1, t1[o1++] = 0;
                        var f1 = o1, p1 = "string" == typeof r1.code ? r1.code : r1.code.toString();
                        o1 += 4;
                        var h1 = t1.write(p1, o1 + 4, "utf8") + 1;
                        t1[o1] = 255 & h1, t1[o1 + 1] = h1 >> 8 & 255, t1[o1 + 2] = h1 >> 16 & 255, t1[o1 + 3] = h1 >> 24 & 255, t1[o1 + 4 + h1 - 1] = 0, o1 = o1 + h1 + 4;
                        var y1 = C1(t1, r1.scope, i1, o1, s1 + 1, a1, u1);
                        o1 = y1 - 1;
                        var d1 = y1 - f1;
                        t1[f1++] = 255 & d1, t1[f1++] = d1 >> 8 & 255, t1[f1++] = d1 >> 16 & 255, t1[f1++] = d1 >> 24 & 255, t1[o1++] = 0;
                    } else {
                        t1[o1++] = D1.BSON_DATA_CODE, o1 += l1 = c1 ? t1.write(e1, o1, "ascii") : t1.write(e1, o1, "utf8"), t1[o1++] = 0, p1 = r1.code.toString();
                        var m1 = t1.write(p1, o1 + 4, "utf8") + 1;
                        t1[o1] = 255 & m1, t1[o1 + 1] = m1 >> 8 & 255, t1[o1 + 2] = m1 >> 16 & 255, t1[o1 + 3] = m1 >> 24 & 255, o1 = o1 + 4 + m1 - 1, t1[o1++] = 0;
                    }
                    return o1;
                }, N1 = function(t1, e1, r1, n1, o1) {
                    t1[n1++] = D1.BSON_DATA_BINARY, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0;
                    var i1 = r1.value(!0), s1 = r1.position;
                    return r1.sub_type === a1.SUBTYPE_BYTE_ARRAY && (s1 += 4), t1[n1++] = 255 & s1, t1[n1++] = s1 >> 8 & 255, t1[n1++] = s1 >> 16 & 255, t1[n1++] = s1 >> 24 & 255, t1[n1++] = r1.sub_type, r1.sub_type === a1.SUBTYPE_BYTE_ARRAY && (s1 -= 4, t1[n1++] = 255 & s1, t1[n1++] = s1 >> 8 & 255, t1[n1++] = s1 >> 16 & 255, t1[n1++] = s1 >> 24 & 255), i1.copy(t1, n1, 0, r1.position), n1 += r1.position;
                }, T1 = function(t1, e1, r1, n1, o1) {
                    t1[n1++] = D1.BSON_DATA_SYMBOL, n1 += o1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0;
                    var i1 = t1.write(r1.value, n1 + 4, "utf8") + 1;
                    return t1[n1] = 255 & i1, t1[n1 + 1] = i1 >> 8 & 255, t1[n1 + 2] = i1 >> 16 & 255, t1[n1 + 3] = i1 >> 24 & 255, n1 = n1 + 4 + i1 - 1, t1[n1++] = 0, n1;
                }, k1 = function(t1, e1, r1, n1, o1, i1, s1) {
                    t1[n1++] = D1.BSON_DATA_OBJECT, n1 += s1 ? t1.write(e1, n1, "ascii") : t1.write(e1, n1, "utf8"), t1[n1++] = 0;
                    var a1, u1 = n1, c1 = (a1 = null != r1.db ? C1(t1, {
                        $ref: r1.namespace,
                        $id: r1.oid,
                        $db: r1.db
                    }, !1, n1, o1 + 1, i1) : C1(t1, {
                        $ref: r1.namespace,
                        $id: r1.oid
                    }, !1, n1, o1 + 1, i1)) - u1;
                    return t1[u1++] = 255 & c1, t1[u1++] = c1 >> 8 & 255, t1[u1++] = c1 >> 16 & 255, t1[u1++] = c1 >> 24 & 255, a1;
                }, C1 = function(t1, r1, o1, i1, a1, u1, C1, D1) {
                    i1 = i1 || 0, (D1 = D1 || []).push(r1);
                    var R1 = i1 + 4;
                    if (Array.isArray(r1)) for(var B1 = 0; B1 < r1.length; B1++){
                        var M1 = "" + B1, I1 = r1[B1];
                        if (I1 && I1.toBSON) {
                            if ("function" != typeof I1.toBSON) throw new Error("toBSON is not a function");
                            I1 = I1.toBSON();
                        }
                        var F1 = n1(I1);
                        if ("string" === F1) R1 = h1(t1, M1, I1, R1, !0);
                        else if ("number" === F1) R1 = y1(t1, M1, I1, R1, !0);
                        else if ("boolean" === F1) R1 = m1(t1, M1, I1, R1, !0);
                        else if (I1 instanceof Date || f1(I1)) R1 = _1(t1, M1, I1, R1, !0);
                        else if (void 0 === I1) R1 = d1(t1, M1, 0, R1, !0);
                        else if (null === I1) R1 = d1(t1, M1, 0, R1, !0);
                        else if ("ObjectID" === I1._bsontype || "ObjectId" === I1._bsontype) R1 = w1(t1, M1, I1, R1, !0);
                        else if (e1.isBuffer(I1)) R1 = O1(t1, M1, I1, R1, !0);
                        else if (I1 instanceof RegExp || p1(I1)) R1 = v1(t1, M1, I1, R1, !0);
                        else if ("object" === F1 && null == I1._bsontype) R1 = S1(t1, M1, I1, R1, o1, a1, u1, C1, !0, D1);
                        else if ("object" === F1 && "Decimal128" === I1._bsontype) R1 = A1(t1, M1, I1, R1, !0);
                        else if ("Long" === I1._bsontype || "Timestamp" === I1._bsontype) R1 = j1(t1, M1, I1, R1, !0);
                        else if ("Double" === I1._bsontype) R1 = $1(t1, M1, I1, R1, !0);
                        else if ("function" == typeof I1 && u1) R1 = P1(t1, M1, I1, R1, 0, 0, u1);
                        else if ("Code" === I1._bsontype) R1 = x1(t1, M1, I1, R1, o1, a1, u1, C1, !0);
                        else if ("Binary" === I1._bsontype) R1 = N1(t1, M1, I1, R1, !0);
                        else if ("Symbol" === I1._bsontype) R1 = T1(t1, M1, I1, R1, !0);
                        else if ("DBRef" === I1._bsontype) R1 = k1(t1, M1, I1, R1, a1, u1, !0);
                        else if ("BSONRegExp" === I1._bsontype) R1 = g1(t1, M1, I1, R1, !0);
                        else if ("Int32" === I1._bsontype) R1 = E1(t1, M1, I1, R1, !0);
                        else if ("MinKey" === I1._bsontype || "MaxKey" === I1._bsontype) R1 = b1(t1, M1, I1, R1, !0);
                        else if (void 0 !== I1._bsontype) throw new TypeError("Unrecognized or invalid _bsontype: " + I1._bsontype);
                    }
                    else if (r1 instanceof s1) for(var L1 = r1.entries(), U1 = !1; !U1;){
                        var V1 = L1.next();
                        if (!(U1 = V1.done)) {
                            if (M1 = V1.value[0], F1 = n1(I1 = V1.value[1]), "string" == typeof M1 && -1 === l1.indexOf(M1)) {
                                if (null != M1.match(c1)) throw Error("key " + M1 + " must not contain null bytes");
                                if (o1) {
                                    if ("$" === M1[0]) throw Error("key " + M1 + " must not start with '$'");
                                    if (~M1.indexOf(".")) throw Error("key " + M1 + " must not contain '.'");
                                }
                            }
                            if ("string" === F1) R1 = h1(t1, M1, I1, R1);
                            else if ("number" === F1) R1 = y1(t1, M1, I1, R1);
                            else if ("boolean" === F1) R1 = m1(t1, M1, I1, R1);
                            else if (I1 instanceof Date || f1(I1)) R1 = _1(t1, M1, I1, R1);
                            else if (null === I1 || void 0 === I1 && !1 === C1) R1 = d1(t1, M1, 0, R1);
                            else if ("ObjectID" === I1._bsontype || "ObjectId" === I1._bsontype) R1 = w1(t1, M1, I1, R1);
                            else if (e1.isBuffer(I1)) R1 = O1(t1, M1, I1, R1);
                            else if (I1 instanceof RegExp || p1(I1)) R1 = v1(t1, M1, I1, R1);
                            else if ("object" === F1 && null == I1._bsontype) R1 = S1(t1, M1, I1, R1, o1, a1, u1, C1, !1, D1);
                            else if ("object" === F1 && "Decimal128" === I1._bsontype) R1 = A1(t1, M1, I1, R1);
                            else if ("Long" === I1._bsontype || "Timestamp" === I1._bsontype) R1 = j1(t1, M1, I1, R1);
                            else if ("Double" === I1._bsontype) R1 = $1(t1, M1, I1, R1);
                            else if ("Code" === I1._bsontype) R1 = x1(t1, M1, I1, R1, o1, a1, u1, C1);
                            else if ("function" == typeof I1 && u1) R1 = P1(t1, M1, I1, R1, 0, 0, u1);
                            else if ("Binary" === I1._bsontype) R1 = N1(t1, M1, I1, R1);
                            else if ("Symbol" === I1._bsontype) R1 = T1(t1, M1, I1, R1);
                            else if ("DBRef" === I1._bsontype) R1 = k1(t1, M1, I1, R1, a1, u1);
                            else if ("BSONRegExp" === I1._bsontype) R1 = g1(t1, M1, I1, R1);
                            else if ("Int32" === I1._bsontype) R1 = E1(t1, M1, I1, R1);
                            else if ("MinKey" === I1._bsontype || "MaxKey" === I1._bsontype) R1 = b1(t1, M1, I1, R1);
                            else if (void 0 !== I1._bsontype) throw new TypeError("Unrecognized or invalid _bsontype: " + I1._bsontype);
                        }
                    }
                    else {
                        if (r1.toBSON) {
                            if ("function" != typeof r1.toBSON) throw new Error("toBSON is not a function");
                            if (null != (r1 = r1.toBSON()) && "object" !== n1(r1)) throw new Error("toBSON function did not return an object");
                        }
                        for(M1 in r1){
                            if ((I1 = r1[M1]) && I1.toBSON) {
                                if ("function" != typeof I1.toBSON) throw new Error("toBSON is not a function");
                                I1 = I1.toBSON();
                            }
                            if (F1 = n1(I1), "string" == typeof M1 && -1 === l1.indexOf(M1)) {
                                if (null != M1.match(c1)) throw Error("key " + M1 + " must not contain null bytes");
                                if (o1) {
                                    if ("$" === M1[0]) throw Error("key " + M1 + " must not start with '$'");
                                    if (~M1.indexOf(".")) throw Error("key " + M1 + " must not contain '.'");
                                }
                            }
                            if ("string" === F1) R1 = h1(t1, M1, I1, R1);
                            else if ("number" === F1) R1 = y1(t1, M1, I1, R1);
                            else if ("boolean" === F1) R1 = m1(t1, M1, I1, R1);
                            else if (I1 instanceof Date || f1(I1)) R1 = _1(t1, M1, I1, R1);
                            else if (void 0 === I1) !1 === C1 && (R1 = d1(t1, M1, 0, R1));
                            else if (null === I1) R1 = d1(t1, M1, 0, R1);
                            else if ("ObjectID" === I1._bsontype || "ObjectId" === I1._bsontype) R1 = w1(t1, M1, I1, R1);
                            else if (e1.isBuffer(I1)) R1 = O1(t1, M1, I1, R1);
                            else if (I1 instanceof RegExp || p1(I1)) R1 = v1(t1, M1, I1, R1);
                            else if ("object" === F1 && null == I1._bsontype) R1 = S1(t1, M1, I1, R1, o1, a1, u1, C1, !1, D1);
                            else if ("object" === F1 && "Decimal128" === I1._bsontype) R1 = A1(t1, M1, I1, R1);
                            else if ("Long" === I1._bsontype || "Timestamp" === I1._bsontype) R1 = j1(t1, M1, I1, R1);
                            else if ("Double" === I1._bsontype) R1 = $1(t1, M1, I1, R1);
                            else if ("Code" === I1._bsontype) R1 = x1(t1, M1, I1, R1, o1, a1, u1, C1);
                            else if ("function" == typeof I1 && u1) R1 = P1(t1, M1, I1, R1, 0, 0, u1);
                            else if ("Binary" === I1._bsontype) R1 = N1(t1, M1, I1, R1);
                            else if ("Symbol" === I1._bsontype) R1 = T1(t1, M1, I1, R1);
                            else if ("DBRef" === I1._bsontype) R1 = k1(t1, M1, I1, R1, a1, u1);
                            else if ("BSONRegExp" === I1._bsontype) R1 = g1(t1, M1, I1, R1);
                            else if ("Int32" === I1._bsontype) R1 = E1(t1, M1, I1, R1);
                            else if ("MinKey" === I1._bsontype || "MaxKey" === I1._bsontype) R1 = b1(t1, M1, I1, R1);
                            else if (void 0 !== I1._bsontype) throw new TypeError("Unrecognized or invalid _bsontype: " + I1._bsontype);
                        }
                    }
                    D1.pop(), t1[R1++] = 0;
                    var q1 = R1 - i1;
                    return t1[i1++] = 255 & q1, t1[i1++] = q1 >> 8 & 255, t1[i1++] = q1 >> 16 & 255, t1[i1++] = q1 >> 24 & 255, R1;
                }, D1 = {
                    BSON_DATA_NUMBER: 1,
                    BSON_DATA_STRING: 2,
                    BSON_DATA_OBJECT: 3,
                    BSON_DATA_ARRAY: 4,
                    BSON_DATA_BINARY: 5,
                    BSON_DATA_UNDEFINED: 6,
                    BSON_DATA_OID: 7,
                    BSON_DATA_BOOLEAN: 8,
                    BSON_DATA_DATE: 9,
                    BSON_DATA_NULL: 10,
                    BSON_DATA_REGEXP: 11,
                    BSON_DATA_CODE: 13,
                    BSON_DATA_SYMBOL: 14,
                    BSON_DATA_CODE_W_SCOPE: 15,
                    BSON_DATA_INT: 16,
                    BSON_DATA_TIMESTAMP: 17,
                    BSON_DATA_LONG: 18,
                    BSON_DATA_DECIMAL128: 19,
                    BSON_DATA_MIN_KEY: 255,
                    BSON_DATA_MAX_KEY: 127,
                    BSON_BINARY_SUBTYPE_DEFAULT: 0,
                    BSON_BINARY_SUBTYPE_FUNCTION: 1,
                    BSON_BINARY_SUBTYPE_BYTE_ARRAY: 2,
                    BSON_BINARY_SUBTYPE_UUID: 3,
                    BSON_BINARY_SUBTYPE_MD5: 4,
                    BSON_BINARY_SUBTYPE_USER_DEFINED: 128,
                    BSON_INT32_MAX: 2147483647,
                    BSON_INT32_MIN: -2147483648
                };
                D1.BSON_INT64_MAX = Math.pow(2, 63) - 1, D1.BSON_INT64_MIN = -Math.pow(2, 63), D1.JS_INT_MAX = 9007199254740992, D1.JS_INT_MIN = -9007199254740992, t1.exports = C1;
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1) {
            e1.readIEEE754 = function(t1, e1, r1, n1, o1) {
                var i1, s1, a1 = "big" === r1, u1 = 8 * o1 - n1 - 1, c1 = (1 << u1) - 1, l1 = c1 >> 1, f1 = -7, p1 = a1 ? 0 : o1 - 1, h1 = a1 ? 1 : -1, y1 = t1[e1 + p1];
                for(p1 += h1, i1 = y1 & (1 << -f1) - 1, y1 >>= -f1, f1 += u1; f1 > 0; i1 = 256 * i1 + t1[e1 + p1], p1 += h1, f1 -= 8);
                for(s1 = i1 & (1 << -f1) - 1, i1 >>= -f1, f1 += n1; f1 > 0; s1 = 256 * s1 + t1[e1 + p1], p1 += h1, f1 -= 8);
                if (0 === i1) i1 = 1 - l1;
                else {
                    if (i1 === c1) return s1 ? NaN : 1 / 0 * (y1 ? -1 : 1);
                    s1 += Math.pow(2, n1), i1 -= l1;
                }
                return (y1 ? -1 : 1) * s1 * Math.pow(2, i1 - n1);
            }, e1.writeIEEE754 = function(t1, e1, r1, n1, o1, i1) {
                var s1, a1, u1, c1 = "big" === n1, l1 = 8 * i1 - o1 - 1, f1 = (1 << l1) - 1, p1 = f1 >> 1, h1 = 23 === o1 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y1 = c1 ? i1 - 1 : 0, d1 = c1 ? -1 : 1, m1 = e1 < 0 || 0 === e1 && 1 / e1 < 0 ? 1 : 0;
                for(e1 = Math.abs(e1), isNaN(e1) || e1 === 1 / 0 ? (a1 = isNaN(e1) ? 1 : 0, s1 = f1) : (s1 = Math.floor(Math.log(e1) / Math.LN2), e1 * (u1 = Math.pow(2, -s1)) < 1 && (s1--, u1 *= 2), (e1 += s1 + p1 >= 1 ? h1 / u1 : h1 * Math.pow(2, 1 - p1)) * u1 >= 2 && (s1++, u1 /= 2), s1 + p1 >= f1 ? (a1 = 0, s1 = f1) : s1 + p1 >= 1 ? (a1 = (e1 * u1 - 1) * Math.pow(2, o1), s1 += p1) : (a1 = e1 * Math.pow(2, p1 - 1) * Math.pow(2, o1), s1 = 0)); o1 >= 8; t1[r1 + y1] = 255 & a1, y1 += d1, a1 /= 256, o1 -= 8);
                for(s1 = s1 << o1 | a1, l1 += o1; l1 > 0; t1[r1 + y1] = 255 & s1, y1 += d1, s1 /= 256, l1 -= 8);
                t1[r1 + y1 - d1] |= 128 * m1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                function n1(t1) {
                    return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                var o1 = r1(23).Long, i1 = r1(36).Double, s1 = r1(37).Timestamp, a1 = r1(38).ObjectID, u1 = r1(40).Symbol, c1 = r1(39).BSONRegExp, l1 = r1(41).Code, f1 = r1(42), p1 = r1(43).MinKey, h1 = r1(44).MaxKey, y1 = r1(45).DBRef, d1 = r1(27).Binary, m1 = r1(16).normalizedFunctionString, _1 = function(t1, e1, r1) {
                    var n1 = 5;
                    if (Array.isArray(t1)) for(var o1 = 0; o1 < t1.length; o1++)n1 += v1(o1.toString(), t1[o1], e1, !0, r1);
                    else for(var i1 in t1.toBSON && (t1 = t1.toBSON()), t1)n1 += v1(i1, t1[i1], e1, !1, r1);
                    return n1;
                };
                function v1(t1, r1, v1, b1, w1) {
                    switch(r1 && r1.toBSON && (r1 = r1.toBSON()), n1(r1)){
                        case "string":
                            return 1 + e1.byteLength(t1, "utf8") + 1 + 4 + e1.byteLength(r1, "utf8") + 1;
                        case "number":
                            return Math.floor(r1) === r1 && r1 >= g1.JS_INT_MIN && r1 <= g1.JS_INT_MAX && r1 >= g1.BSON_INT32_MIN && r1 <= g1.BSON_INT32_MAX ? (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 5 : (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 9;
                        case "undefined":
                            return b1 || !w1 ? (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 1 : 0;
                        case "boolean":
                            return (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 2;
                        case "object":
                            if (null == r1 || r1 instanceof p1 || r1 instanceof h1 || "MinKey" === r1._bsontype || "MaxKey" === r1._bsontype) return (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 1;
                            if (r1 instanceof a1 || "ObjectID" === r1._bsontype || "ObjectId" === r1._bsontype) return (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 13;
                            if (r1 instanceof Date || "object" === n1(S1 = r1) && "[object Date]" === Object.prototype.toString.call(S1)) return (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 9;
                            if (void 0 !== e1 && e1.isBuffer(r1)) return (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 6 + r1.length;
                            if (r1 instanceof o1 || r1 instanceof i1 || r1 instanceof s1 || "Long" === r1._bsontype || "Double" === r1._bsontype || "Timestamp" === r1._bsontype) return (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 9;
                            if (r1 instanceof f1 || "Decimal128" === r1._bsontype) return (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 17;
                            if (r1 instanceof l1 || "Code" === r1._bsontype) return null != r1.scope && Object.keys(r1.scope).length > 0 ? (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 1 + 4 + 4 + e1.byteLength(r1.code.toString(), "utf8") + 1 + _1(r1.scope, v1, w1) : (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 1 + 4 + e1.byteLength(r1.code.toString(), "utf8") + 1;
                            if (r1 instanceof d1 || "Binary" === r1._bsontype) return r1.sub_type === d1.SUBTYPE_BYTE_ARRAY ? (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + (r1.position + 1 + 4 + 1 + 4) : (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + (r1.position + 1 + 4 + 1);
                            if (r1 instanceof u1 || "Symbol" === r1._bsontype) return (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + e1.byteLength(r1.value, "utf8") + 4 + 1 + 1;
                            if (r1 instanceof y1 || "DBRef" === r1._bsontype) {
                                var O1 = {
                                    $ref: r1.namespace,
                                    $id: r1.oid
                                };
                                return null != r1.db && (O1.$db = r1.db), (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 1 + _1(O1, v1, w1);
                            }
                            return r1 instanceof RegExp || "[object RegExp]" === Object.prototype.toString.call(r1) ? (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 1 + e1.byteLength(r1.source, "utf8") + 1 + (r1.global ? 1 : 0) + (r1.ignoreCase ? 1 : 0) + (r1.multiline ? 1 : 0) + 1 : r1 instanceof c1 || "BSONRegExp" === r1._bsontype ? (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 1 + e1.byteLength(r1.pattern, "utf8") + 1 + e1.byteLength(r1.options, "utf8") + 1 : (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + _1(r1, v1, w1) + 1;
                        case "function":
                            if (r1 instanceof RegExp || "[object RegExp]" === Object.prototype.toString.call(r1) || "[object RegExp]" === String.call(r1)) return (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 1 + e1.byteLength(r1.source, "utf8") + 1 + (r1.global ? 1 : 0) + (r1.ignoreCase ? 1 : 0) + (r1.multiline ? 1 : 0) + 1;
                            if (v1 && null != r1.scope && Object.keys(r1.scope).length > 0) return (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 1 + 4 + 4 + e1.byteLength(m1(r1), "utf8") + 1 + _1(r1.scope, v1, w1);
                            if (v1) return (null != t1 ? e1.byteLength(t1, "utf8") + 1 : 0) + 1 + 4 + e1.byteLength(m1(r1), "utf8") + 1;
                    }
                    var S1;
                    return 0;
                }
                var g1 = {
                    BSON_INT32_MAX: 2147483647,
                    BSON_INT32_MIN: -2147483648,
                    JS_INT_MAX: 9007199254740992,
                    JS_INT_MIN: -9007199254740992
                };
                t1.exports = _1;
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * ignore
 */ t1.exports = r1(35).Decimal128;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId
 * @constructor NodeMongoDbObjectId
 * @see ObjectId
 */ var n1 = r1(35).ObjectID;
            /*!
 * Getter for convenience with populate, see gh-6115
 */ Object.defineProperty(n1.prototype, "_id", {
                enumerable: !1,
                configurable: !0,
                get: function() {
                    return this;
                }
            }), /*!
 * ignore
 */ t1.exports = n1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * ignore
 */ t1.exports = function() {};
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Dependencies
 */ var n1 = r1(110).ctor("require", "modify", "init", "default", "ignore");
            t1.exports = function() {
                this.strictMode = void 0, this.selected = void 0, this.shardval = void 0, this.saveError = void 0, this.validationError = void 0, this.adhocPaths = void 0, this.removing = void 0, this.inserting = void 0, this.saving = void 0, this.version = void 0, this.getters = {}, this._id = void 0, this.populate = void 0, this.populated = void 0, this.wasPopulated = !1, this.scope = void 0, this.activePaths = new n1, this.pathsToScopes = {}, this.cachedRequired = {}, this.session = null, this.$setCalled = new Set, this.ownerDocument = void 0, this.fullPath = void 0;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ var n1 = r1(2), o1 = t1.exports = function() {};
            /*!
 * StateMachine represents a minimal `interface` for the
 * constructors it builds via StateMachine.ctor(...).
 *
 * @api private
 */ /*!
 * StateMachine.ctor('state1', 'state2', ...)
 * A factory method for subclassing StateMachine.
 * The arguments are a list of states. For each state,
 * the constructor's prototype gets state transition
 * methods named after each state. These transition methods
 * place their path argument into the given state.
 *
 * @param {String} state
 * @param {String} [state]
 * @return {Function} subclass constructor
 * @private
 */ o1.ctor = function() {
                var t1 = n1.args(arguments), e1 = function() {
                    o1.apply(this, arguments), this.paths = {}, this.states = {}, this.stateNames = t1;
                    for(var e1, r1 = t1.length; r1--;)e1 = t1[r1], this.states[e1] = {};
                };
                return e1.prototype = new o1, t1.forEach(function(t1) {
                    e1.prototype[t1] = function(e1) {
                        this._changeState(e1, t1);
                    };
                }), e1;
            }, /*!
 * This function is wrapped by the state change functions:
 *
 * - `require(path)`
 * - `modify(path)`
 * - `init(path)`
 *
 * @api private
 */ o1.prototype._changeState = function(t1, e1) {
                var r1 = this.states[this.paths[t1]];
                r1 && delete r1[t1], this.paths[t1] = e1, this.states[e1][t1] = !0;
            }, /*!
 * ignore
 */ o1.prototype.clear = function(t1) {
                for(var e1, r1 = Object.keys(this.states[t1]), n1 = r1.length; n1--;)e1 = r1[n1], delete this.states[t1][e1], delete this.paths[e1];
            }, /*!
 * Checks to see if at least one path is in the states passed in via `arguments`
 * e.g., this.some('required', 'inited')
 *
 * @param {String} state that we want to check for.
 * @private
 */ o1.prototype.some = function() {
                var t1 = this, e1 = arguments.length ? arguments : this.stateNames;
                return Array.prototype.some.call(e1, function(e1) {
                    return Object.keys(t1.states[e1]).length;
                });
            }, /*!
 * This function builds the functions that get assigned to `forEach` and `map`,
 * since both of those methods share a lot of the same logic.
 *
 * @param {String} iterMethod is either 'forEach' or 'map'
 * @return {Function}
 * @api private
 */ o1.prototype._iter = function(t1) {
                return function() {
                    var e1 = arguments.length, r1 = n1.args(arguments, 0, e1 - 1), o1 = arguments[e1 - 1];
                    r1.length || (r1 = this.stateNames);
                    var i1 = this, s1 = r1.reduce(function(t1, e1) {
                        return t1.concat(Object.keys(i1.states[e1]));
                    }, []);
                    return s1[t1](function(t1, e1, r1) {
                        return o1(t1, e1, r1);
                    });
                };
            }, /*!
 * Iterates over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @private
 */ o1.prototype.forEach = function() {
                return this.forEach = this._iter("forEach"), this.forEach.apply(this, arguments);
            }, /*!
 * Maps over the paths that belong to one of the parameter states.
 *
 * The function profile can look like:
 * this.forEach(state1, fn);         // iterates over all paths in state1
 * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2
 * this.forEach(fn);                 // iterates over all paths in all states
 *
 * @param {String} [state]
 * @param {String} [state]
 * @param {Function} callback
 * @return {Array}
 * @private
 */ o1.prototype.map = function() {
                return this.map = this._iter("map"), this.map.apply(this, arguments);
            };
        },
        function(t1, e1) {
            function r1(t1) {
                return (r1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            var n1 = 1e3, o1 = 6e4, i1 = 60 * o1, s1 = 24 * i1;
            function a1(t1, e1, r1, n1) {
                var o1 = e1 >= 1.5 * r1;
                return Math.round(t1 / r1) + " " + n1 + (o1 ? "s" : "");
            }
            t1.exports = function(t1, e1) {
                e1 = e1 || {};
                var u1 = r1(t1);
                if ("string" === u1 && t1.length > 0) return function(t1) {
                    if ((t1 = String(t1)).length > 100) return;
                    var e1 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t1);
                    if (!e1) return;
                    var r1 = parseFloat(e1[1]);
                    switch((e1[2] || "ms").toLowerCase()){
                        case "years":
                        case "year":
                        case "yrs":
                        case "yr":
                        case "y":
                            return 315576e5 * r1;
                        case "weeks":
                        case "week":
                        case "w":
                            return 6048e5 * r1;
                        case "days":
                        case "day":
                        case "d":
                            return r1 * s1;
                        case "hours":
                        case "hour":
                        case "hrs":
                        case "hr":
                        case "h":
                            return r1 * i1;
                        case "minutes":
                        case "minute":
                        case "mins":
                        case "min":
                        case "m":
                            return r1 * o1;
                        case "seconds":
                        case "second":
                        case "secs":
                        case "sec":
                        case "s":
                            return r1 * n1;
                        case "milliseconds":
                        case "millisecond":
                        case "msecs":
                        case "msec":
                        case "ms":
                            return r1;
                        default:
                            return;
                    }
                }(t1);
                if ("number" === u1 && isFinite(t1)) return e1.long ? function(t1) {
                    var e1 = Math.abs(t1);
                    if (e1 >= s1) return a1(t1, e1, s1, "day");
                    if (e1 >= i1) return a1(t1, e1, i1, "hour");
                    if (e1 >= o1) return a1(t1, e1, o1, "minute");
                    if (e1 >= n1) return a1(t1, e1, n1, "second");
                    return t1 + " ms";
                }(t1) : function(t1) {
                    var e1 = Math.abs(t1);
                    if (e1 >= s1) return Math.round(t1 / s1) + "d";
                    if (e1 >= i1) return Math.round(t1 / i1) + "h";
                    if (e1 >= o1) return Math.round(t1 / o1) + "m";
                    if (e1 >= n1) return Math.round(t1 / n1) + "s";
                    return t1 + "ms";
                }(t1);
                throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t1));
            };
        },
        function(t1, e1) {
            function r1(t1) {
                return (r1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            var n1 = [
                "__proto__",
                "constructor",
                "prototype"
            ];
            /*!
 * Returns the value passed to it.
 */ function o1(t1) {
                return t1;
            }
            e1.get = function(t1, r1, n1, i1) {
                var s1;
                "function" == typeof n1 && (n1.length < 2 ? (i1 = n1, n1 = void 0) : (s1 = n1, n1 = void 0)), i1 || (i1 = o1);
                var a1 = "string" == typeof t1 ? t1.split(".") : t1;
                if (!Array.isArray(a1)) throw new TypeError("Invalid `path`. Must be either string or array");
                for(var u1, c1 = r1, l1 = 0; l1 < a1.length; ++l1){
                    if (u1 = a1[l1], Array.isArray(c1) && !/^\d+$/.test(u1)) {
                        var f1 = a1.slice(l1);
                        return [].concat(c1).map(function(t1) {
                            return t1 ? e1.get(f1, t1, n1 || s1, i1) : i1(void 0);
                        });
                    }
                    if (s1) c1 = s1(c1, u1);
                    else {
                        var p1 = n1 && c1[n1] ? c1[n1] : c1;
                        c1 = p1 instanceof Map ? p1.get(u1) : p1[u1];
                    }
                    if (!c1) return i1(c1);
                }
                return i1(c1);
            }, e1.has = function(t1, e1) {
                var n1 = "string" == typeof t1 ? t1.split(".") : t1;
                if (!Array.isArray(n1)) throw new TypeError("Invalid `path`. Must be either string or array");
                for(var o1 = n1.length, i1 = e1, s1 = 0; s1 < o1; ++s1){
                    if (null == i1 || "object" !== r1(i1) || !(n1[s1] in i1)) return !1;
                    i1 = i1[n1[s1]];
                }
                return !0;
            }, e1.unset = function(t1, e1) {
                var o1 = "string" == typeof t1 ? t1.split(".") : t1;
                if (!Array.isArray(o1)) throw new TypeError("Invalid `path`. Must be either string or array");
                for(var i1 = o1.length, s1 = e1, a1 = 0; a1 < i1; ++a1){
                    if (null == s1 || "object" !== r1(s1) || !(o1[a1] in s1)) return !1;
                    if (-1 !== n1.indexOf(o1[a1])) return !1;
                    if (a1 === i1 - 1) return delete s1[o1[a1]], !0;
                    s1 = s1 instanceof Map ? s1.get(o1[a1]) : s1[o1[a1]];
                }
                return !0;
            }, e1.set = function(t1, r1, i1, s1, a1, u1) {
                var c1;
                "function" == typeof s1 && (s1.length < 2 ? (a1 = s1, s1 = void 0) : (c1 = s1, s1 = void 0)), a1 || (a1 = o1);
                var l1 = "string" == typeof t1 ? t1.split(".") : t1;
                if (!Array.isArray(l1)) throw new TypeError("Invalid `path`. Must be either string or array");
                if (null != i1) {
                    for(var f1 = 0; f1 < l1.length; ++f1)if (-1 !== n1.indexOf(l1[f1])) return;
                    for(var p1, h1 = u1 || /\$/.test(t1) && !1 !== u1, y1 = i1, d1 = (f1 = 0, l1.length - 1); f1 < d1; ++f1)if ("$" != (p1 = l1[f1])) {
                        if (Array.isArray(y1) && !/^\d+$/.test(p1)) {
                            var m1 = l1.slice(f1);
                            if (!h1 && Array.isArray(r1)) for(var _1 = 0; _1 < y1.length && _1 < r1.length; ++_1)e1.set(m1, r1[_1], y1[_1], s1 || c1, a1, h1);
                            else for(_1 = 0; _1 < y1.length; ++_1)e1.set(m1, r1, y1[_1], s1 || c1, a1, h1);
                            return;
                        }
                        if (c1) y1 = c1(y1, p1);
                        else {
                            var v1 = s1 && y1[s1] ? y1[s1] : y1;
                            y1 = v1 instanceof Map ? v1.get(p1) : v1[p1];
                        }
                        if (!y1) return;
                    } else if (f1 == d1 - 1) break;
                    if (p1 = l1[d1], s1 && y1[s1] && (y1 = y1[s1]), Array.isArray(y1) && !/^\d+$/.test(p1)) {
                        if (!h1 && Array.isArray(r1)) !/*!
 * Recursively set nested arrays
 */ function t1(e1, r1, n1, o1, i1, s1) {
                            for(var a1, u1 = 0; u1 < e1.length && u1 < r1.length; ++u1)a1 = e1[u1], Array.isArray(a1) && Array.isArray(r1[u1]) ? t1(a1, r1[u1], n1, o1, i1, s1) : a1 && (o1 ? o1(a1, n1, s1(r1[u1])) : (a1[i1] && (a1 = a1[i1]), a1[n1] = s1(r1[u1])));
                        }(y1, r1, p1, c1, s1, a1);
                        else for(_1 = 0; _1 < y1.length; ++_1)item = y1[_1], item && (c1 ? c1(item, p1, a1(r1)) : (item[s1] && (item = item[s1]), item[p1] = a1(r1)));
                    } else c1 ? c1(y1, p1, a1(r1)) : y1 instanceof Map ? y1.set(p1, a1(r1)) : y1[p1] = a1(r1);
                }
            };
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            var o1 = r1(28);
            t1.exports = function t1(e1) {
                if (function(t1, e1) {
                    if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                }(this, t1), this._docs = {}, this._childDocs = [], null != e1 && (e1 = o1(e1), Object.assign(this, e1), "object" === n1(e1.subPopulate) && (this.populate = e1.subPopulate), null != e1.perDocumentLimit && null != e1.limit)) throw new Error("Can not use `limit` and `perDocumentLimit` at the same time. Path: `" + e1.path + "`.");
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*
object-assign
(c) Sindre Sorhus
@license MIT
*/ var n1 = Object.getOwnPropertySymbols, o1 = Object.prototype.hasOwnProperty, i1 = Object.prototype.propertyIsEnumerable;
            function s1(t1) {
                if (null == t1) throw new TypeError("Object.assign cannot be called with null or undefined");
                return Object(t1);
            }
            t1.exports = function() {
                try {
                    if (!Object.assign) return !1;
                    var t1 = new String("abc");
                    if (t1[5] = "de", "5" === Object.getOwnPropertyNames(t1)[0]) return !1;
                    for(var e1 = {}, r1 = 0; r1 < 10; r1++)e1["_" + String.fromCharCode(r1)] = r1;
                    if ("0123456789" !== Object.getOwnPropertyNames(e1).map(function(t1) {
                        return e1[t1];
                    }).join("")) return !1;
                    var n1 = {};
                    return "abcdefghijklmnopqrst".split("").forEach(function(t1) {
                        n1[t1] = t1;
                    }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n1)).join("");
                } catch (t1) {
                    return !1;
                }
            }() ? Object.assign : function(t1, e1) {
                for(var r1, a1, u1 = s1(t1), c1 = 1; c1 < arguments.length; c1++){
                    for(var l1 in r1 = Object(arguments[c1]))o1.call(r1, l1) && (u1[l1] = r1[l1]);
                    if (n1) {
                        a1 = n1(r1);
                        for(var f1 = 0; f1 < a1.length; f1++)i1.call(r1, a1[f1]) && (u1[a1[f1]] = r1[a1[f1]]);
                    }
                }
                return u1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            var o1 = r1(62), i1 = r1(22), s1 = r1(4), a1 = r1(68), u1 = r1(118)("mquery");
            function c1(t1, e1) {
                if (!(this instanceof c1)) return new c1(t1, e1);
                var r1 = this.constructor.prototype;
                this.op = r1.op || void 0, this.options = Object.assign({}, r1.options), this._conditions = r1._conditions ? a1.clone(r1._conditions) : {}, this._fields = r1._fields ? a1.clone(r1._fields) : void 0, this._update = r1._update ? a1.clone(r1._update) : void 0, this._path = r1._path || void 0, this._distinct = r1._distinct || void 0, this._collection = r1._collection || void 0, this._traceFunction = r1._traceFunction || void 0, e1 && this.setOptions(e1), t1 && (t1.find && t1.remove && t1.update ? this.collection(t1) : this.find(t1));
            }
            var l1 = "$geoWithin";
            Object.defineProperty(c1, "use$geoWithin", {
                get: function() {
                    return "$geoWithin" == l1;
                },
                set: function(t1) {
                    l1 = !0 === t1 ? "$geoWithin" : "$within";
                }
            }), c1.prototype.toConstructor = function() {
                function t1(e1, r1) {
                    if (!(this instanceof t1)) return new t1(e1, r1);
                    c1.call(this, e1, r1);
                }
                a1.inherits(t1, c1);
                var e1 = t1.prototype;
                return e1.options = {}, e1.setOptions(this.options), e1.op = this.op, e1._conditions = a1.clone(this._conditions), e1._fields = a1.clone(this._fields), e1._update = a1.clone(this._update), e1._path = this._path, e1._distinct = this._distinct, e1._collection = this._collection, e1._traceFunction = this._traceFunction, t1;
            }, c1.prototype.setOptions = function(t1) {
                if (!t1 || !a1.isObject(t1)) return this;
                for(var e1, r1 = a1.keys(t1), n1 = 0; n1 < r1.length; ++n1)if ("function" == typeof this[e1 = r1[n1]]) {
                    var o1 = a1.isArray(t1[e1]) ? t1[e1] : [
                        t1[e1]
                    ];
                    this[e1].apply(this, o1);
                } else this.options[e1] = t1[e1];
                return this;
            }, c1.prototype.collection = function(t1) {
                return this._collection = new c1.Collection(t1), this;
            }, c1.prototype.collation = function(t1) {
                return this.options.collation = t1, this;
            }, c1.prototype.$where = function(t1) {
                return this._conditions.$where = t1, this;
            }, c1.prototype.where = function() {
                if (!arguments.length) return this;
                this.op || (this.op = "find");
                var t1 = n1(arguments[0]);
                if ("string" == t1) return this._path = arguments[0], 2 === arguments.length && (this._conditions[this._path] = arguments[1]), this;
                if ("object" == t1 && !Array.isArray(arguments[0])) return this.merge(arguments[0]);
                throw new TypeError("path must be a string or object");
            }, c1.prototype.equals = function(t1) {
                this._ensurePath("equals");
                var e1 = this._path;
                return this._conditions[e1] = t1, this;
            }, c1.prototype.eq = function(t1) {
                this._ensurePath("eq");
                var e1 = this._path;
                return this._conditions[e1] = t1, this;
            }, c1.prototype.or = function(t1) {
                var e1 = this._conditions.$or || (this._conditions.$or = []);
                return a1.isArray(t1) || (t1 = [
                    t1
                ]), e1.push.apply(e1, t1), this;
            }, c1.prototype.nor = function(t1) {
                var e1 = this._conditions.$nor || (this._conditions.$nor = []);
                return a1.isArray(t1) || (t1 = [
                    t1
                ]), e1.push.apply(e1, t1), this;
            }, c1.prototype.and = function(t1) {
                var e1 = this._conditions.$and || (this._conditions.$and = []);
                return Array.isArray(t1) || (t1 = [
                    t1
                ]), e1.push.apply(e1, t1), this;
            }, /*!
 * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance
 *
 *     Thing.where('type').nin(array)
 */ "gt gte lt lte ne in nin all regex size maxDistance minDistance".split(" ").forEach(function(t1) {
                c1.prototype[t1] = function() {
                    var e1, r1;
                    1 === arguments.length ? (this._ensurePath(t1), r1 = arguments[0], e1 = this._path) : (r1 = arguments[1], e1 = arguments[0]);
                    var o1 = null === this._conditions[e1] || "object" === n1(this._conditions[e1]) ? this._conditions[e1] : this._conditions[e1] = {};
                    return o1["$" + t1] = r1, this;
                };
            }), c1.prototype.mod = function() {
                var t1, e1;
                1 === arguments.length ? (this._ensurePath("mod"), t1 = arguments[0], e1 = this._path) : 2 !== arguments.length || a1.isArray(arguments[1]) ? 3 === arguments.length ? (t1 = o1(arguments, 1), e1 = arguments[0]) : (t1 = arguments[1], e1 = arguments[0]) : (this._ensurePath("mod"), t1 = o1(arguments), e1 = this._path);
                var r1 = this._conditions[e1] || (this._conditions[e1] = {});
                return r1.$mod = t1, this;
            }, c1.prototype.exists = function() {
                var t1, e1;
                0 === arguments.length ? (this._ensurePath("exists"), t1 = this._path, e1 = !0) : 1 === arguments.length ? "boolean" == typeof arguments[0] ? (this._ensurePath("exists"), t1 = this._path, e1 = arguments[0]) : (t1 = arguments[0], e1 = !0) : 2 === arguments.length && (t1 = arguments[0], e1 = arguments[1]);
                var r1 = this._conditions[t1] || (this._conditions[t1] = {});
                return r1.$exists = e1, this;
            }, c1.prototype.elemMatch = function() {
                if (null == arguments[0]) throw new TypeError("Invalid argument");
                var t1, e1, r1;
                if ("function" == typeof arguments[0]) this._ensurePath("elemMatch"), e1 = this._path, t1 = arguments[0];
                else if (a1.isObject(arguments[0])) this._ensurePath("elemMatch"), e1 = this._path, r1 = arguments[0];
                else if ("function" == typeof arguments[1]) e1 = arguments[0], t1 = arguments[1];
                else {
                    if (!arguments[1] || !a1.isObject(arguments[1])) throw new TypeError("Invalid argument");
                    e1 = arguments[0], r1 = arguments[1];
                }
                t1 && (t1(r1 = new c1), r1 = r1._conditions);
                var n1 = this._conditions[e1] || (this._conditions[e1] = {});
                return n1.$elemMatch = r1, this;
            }, c1.prototype.within = function() {
                if (this._ensurePath("within"), this._geoComparison = l1, 0 === arguments.length) return this;
                if (2 === arguments.length) return this.box.apply(this, arguments);
                if (2 < arguments.length) return this.polygon.apply(this, arguments);
                var t1 = arguments[0];
                if (!t1) throw new TypeError("Invalid argument");
                if (t1.center) return this.circle(t1);
                if (t1.box) return this.box.apply(this, t1.box);
                if (t1.polygon) return this.polygon.apply(this, t1.polygon);
                if (t1.type && t1.coordinates) return this.geometry(t1);
                throw new TypeError("Invalid argument");
            }, c1.prototype.box = function() {
                var t1, e1;
                if (3 === arguments.length) t1 = arguments[0], e1 = [
                    arguments[1],
                    arguments[2]
                ];
                else {
                    if (2 !== arguments.length) throw new TypeError("Invalid argument");
                    this._ensurePath("box"), t1 = this._path, e1 = [
                        arguments[0],
                        arguments[1]
                    ];
                }
                var r1 = this._conditions[t1] || (this._conditions[t1] = {});
                return r1[this._geoComparison || l1] = {
                    $box: e1
                }, this;
            }, c1.prototype.polygon = function() {
                var t1, e1;
                "string" == typeof arguments[0] ? (e1 = arguments[0], t1 = o1(arguments, 1)) : (this._ensurePath("polygon"), e1 = this._path, t1 = o1(arguments));
                var r1 = this._conditions[e1] || (this._conditions[e1] = {});
                return r1[this._geoComparison || l1] = {
                    $polygon: t1
                }, this;
            }, c1.prototype.circle = function() {
                var t1, e1;
                if (1 === arguments.length) this._ensurePath("circle"), t1 = this._path, e1 = arguments[0];
                else {
                    if (2 !== arguments.length) throw new TypeError("Invalid argument");
                    t1 = arguments[0], e1 = arguments[1];
                }
                if (!("radius" in e1) || !e1.center) throw new Error("center and radius are required");
                var r1 = this._conditions[t1] || (this._conditions[t1] = {}), n1 = e1.spherical ? "$centerSphere" : "$center", o1 = this._geoComparison || l1;
                return r1[o1] = {}, r1[o1][n1] = [
                    e1.center,
                    e1.radius
                ], "unique" in e1 && (r1[o1].$uniqueDocs = !!e1.unique), this;
            }, c1.prototype.near = function() {
                var t1, e1;
                if (this._geoComparison = "$near", 0 === arguments.length) return this;
                if (1 === arguments.length) this._ensurePath("near"), t1 = this._path, e1 = arguments[0];
                else {
                    if (2 !== arguments.length) throw new TypeError("Invalid argument");
                    t1 = arguments[0], e1 = arguments[1];
                }
                if (!e1.center) throw new Error("center is required");
                var r1 = this._conditions[t1] || (this._conditions[t1] = {}), n1 = e1.spherical ? "$nearSphere" : "$near";
                if (Array.isArray(e1.center)) {
                    r1[n1] = e1.center;
                    var o1 = "maxDistance" in e1 ? e1.maxDistance : null;
                    null != o1 && (r1.$maxDistance = o1), null != e1.minDistance && (r1.$minDistance = e1.minDistance);
                } else {
                    if ("Point" != e1.center.type || !Array.isArray(e1.center.coordinates)) throw new Error(s1.format("Invalid GeoJSON specified for %s", n1));
                    r1[n1] = {
                        $geometry: e1.center
                    }, "maxDistance" in e1 && (r1[n1].$maxDistance = e1.maxDistance), "minDistance" in e1 && (r1[n1].$minDistance = e1.minDistance);
                }
                return this;
            }, c1.prototype.intersects = function() {
                if (this._ensurePath("intersects"), this._geoComparison = "$geoIntersects", 0 === arguments.length) return this;
                var t1 = arguments[0];
                if (null != t1 && t1.type && t1.coordinates) return this.geometry(t1);
                throw new TypeError("Invalid argument");
            }, c1.prototype.geometry = function() {
                if ("$within" != this._geoComparison && "$geoWithin" != this._geoComparison && "$near" != this._geoComparison && "$geoIntersects" != this._geoComparison) throw new Error("geometry() must come after `within()`, `intersects()`, or `near()");
                var t1, e1;
                if (1 !== arguments.length) throw new TypeError("Invalid argument");
                if (this._ensurePath("geometry"), e1 = this._path, !(t1 = arguments[0]).type || !Array.isArray(t1.coordinates)) throw new TypeError("Invalid argument");
                var r1 = this._conditions[e1] || (this._conditions[e1] = {});
                return r1[this._geoComparison] = {
                    $geometry: t1
                }, this;
            }, c1.prototype.select = function() {
                var t1 = arguments[0];
                if (!t1) return this;
                if (1 !== arguments.length) throw new Error("Invalid select: select only takes 1 argument");
                this._validate("select");
                var e1, r1, o1 = this._fields || (this._fields = {}), i1 = n1(t1);
                if (("string" == i1 || a1.isArgumentsObject(t1)) && "number" == typeof t1.length || Array.isArray(t1)) {
                    for("string" == i1 && (t1 = t1.split(/\s+/)), e1 = 0, r1 = t1.length; e1 < r1; ++e1){
                        var s1 = t1[e1];
                        if (s1) {
                            var u1 = "-" == s1[0] ? 0 : 1;
                            0 === u1 && (s1 = s1.substring(1)), o1[s1] = u1;
                        }
                    }
                    return this;
                }
                if (a1.isObject(t1)) {
                    var c1 = a1.keys(t1);
                    for(e1 = 0; e1 < c1.length; ++e1)o1[c1[e1]] = t1[c1[e1]];
                    return this;
                }
                throw new TypeError("Invalid select() argument. Must be string or object.");
            }, c1.prototype.slice = function() {
                if (0 === arguments.length) return this;
                var t1, e1;
                if (this._validate("slice"), 1 === arguments.length) {
                    var r1 = arguments[0];
                    if ("object" === n1(r1) && !Array.isArray(r1)) {
                        for(var i1 = Object.keys(r1), s1 = i1.length, a1 = 0; a1 < s1; ++a1)this.slice(i1[a1], r1[i1[a1]]);
                        return this;
                    }
                    this._ensurePath("slice"), t1 = this._path, e1 = arguments[0];
                } else 2 === arguments.length ? "number" == typeof arguments[0] ? (this._ensurePath("slice"), t1 = this._path, e1 = o1(arguments)) : (t1 = arguments[0], e1 = arguments[1]) : 3 === arguments.length && (t1 = arguments[0], e1 = o1(arguments, 1));
                var u1 = this._fields || (this._fields = {});
                return u1[t1] = {
                    $slice: e1
                }, this;
            }, c1.prototype.sort = function(t1) {
                if (!t1) return this;
                var e1, r1, o1;
                this._validate("sort");
                var i1 = n1(t1);
                if (Array.isArray(t1)) {
                    for(r1 = t1.length, e1 = 0; e1 < t1.length; ++e1){
                        if (!Array.isArray(t1[e1])) throw new Error("Invalid sort() argument, must be array of arrays");
                        h1(this.options, t1[e1][0], t1[e1][1]);
                    }
                    return this;
                }
                if (1 === arguments.length && "string" == i1) {
                    for(r1 = (t1 = t1.split(/\s+/)).length, e1 = 0; e1 < r1; ++e1)if (o1 = t1[e1]) {
                        var s1 = "-" == o1[0] ? -1 : 1;
                        -1 === s1 && (o1 = o1.substring(1)), p1(this.options, o1, s1);
                    }
                    return this;
                }
                if (a1.isObject(t1)) {
                    var u1 = a1.keys(t1);
                    for(e1 = 0; e1 < u1.length; ++e1)o1 = u1[e1], p1(this.options, o1, t1[o1]);
                    return this;
                }
                if ("undefined" != typeof Map && t1 instanceof Map) return y1(this.options, t1), this;
                throw new TypeError("Invalid sort() argument. Must be a string, object, or array.");
            };
            /*!
 * @ignore
 */ var f1 = {
                1: 1,
                "-1": -1,
                asc: 1,
                ascending: 1,
                desc: -1,
                descending: -1
            };
            function p1(t1, e1, r1) {
                if (Array.isArray(t1.sort)) throw new TypeError("Can't mix sort syntaxes. Use either array or object:\n- `.sort([['field', 1], ['test', -1]])`\n- `.sort({ field: 1, test: -1 })`");
                var n1;
                if (r1 && r1.$meta) (n1 = t1.sort || (t1.sort = {}))[e1] = {
                    $meta: r1.$meta
                };
                else {
                    n1 = t1.sort || (t1.sort = {});
                    var o1 = String(r1 || 1).toLowerCase();
                    if (!(o1 = f1[o1])) throw new TypeError("Invalid sort value: { " + e1 + ": " + r1 + " }");
                    n1[e1] = o1;
                }
            }
            function h1(t1, e1, r1) {
                if (t1.sort = t1.sort || [], !Array.isArray(t1.sort)) throw new TypeError("Can't mix sort syntaxes. Use either array or object:\n- `.sort([['field', 1], ['test', -1]])`\n- `.sort({ field: 1, test: -1 })`");
                var n1 = String(r1 || 1).toLowerCase();
                if (!(n1 = f1[n1])) throw new TypeError("Invalid sort value: [ " + e1 + ", " + r1 + " ]");
                t1.sort.push([
                    e1,
                    n1
                ]);
            }
            function y1(t1, e1) {
                if (t1.sort = t1.sort || new Map, !(t1.sort instanceof Map)) throw new TypeError("Can't mix sort syntaxes. Use either array or object or map consistently");
                e1.forEach(function(e1, r1) {
                    var n1 = String(e1 || 1).toLowerCase();
                    if (!(n1 = f1[n1])) throw new TypeError("Invalid sort value: < " + r1 + ": " + e1 + " >");
                    t1.sort.set(r1, n1);
                });
            }
            /*!
 * limit, skip, maxScan, batchSize, comment
 *
 * Sets these associated options.
 *
 *     query.comment('feed query');
 */ /*!
 * Internal helper for update, updateMany, updateOne
 */ function d1(t1, e1, r1, n1, o1, i1, s1) {
                return t1.op = e1, c1.canMerge(r1) && t1.merge(r1), n1 && t1._mergeUpdate(n1), a1.isObject(o1) && t1.setOptions(o1), i1 || s1 ? !t1._update || !t1.options.overwrite && 0 === a1.keys(t1._update).length ? (s1 && a1.soon(s1.bind(null, null, 0)), t1) : (o1 = t1._optionsForExec(), s1 || (o1.safe = !1), r1 = t1._conditions, n1 = t1._updateForExec(), u1("update", t1._collection.collectionName, r1, n1, o1), s1 = t1._wrapCallback(e1, s1, {
                    conditions: r1,
                    doc: n1,
                    options: o1
                }), t1._collection[e1](r1, n1, o1, a1.tick(s1)), t1) : t1;
            }
            [
                "limit",
                "skip",
                "maxScan",
                "batchSize",
                "comment"
            ].forEach(function(t1) {
                c1.prototype[t1] = function(e1) {
                    return this._validate(t1), this.options[t1] = e1, this;
                };
            }), c1.prototype.maxTime = c1.prototype.maxTimeMS = function(t1) {
                return this._validate("maxTime"), this.options.maxTimeMS = t1, this;
            }, c1.prototype.snapshot = function() {
                return this._validate("snapshot"), this.options.snapshot = !arguments.length || !!arguments[0], this;
            }, c1.prototype.hint = function() {
                if (0 === arguments.length) return this;
                this._validate("hint");
                var t1 = arguments[0];
                if (a1.isObject(t1)) {
                    var e1 = this.options.hint || (this.options.hint = {});
                    for(var r1 in t1)e1[r1] = t1[r1];
                    return this;
                }
                if ("string" == typeof t1) return this.options.hint = t1, this;
                throw new TypeError("Invalid hint. " + t1);
            }, c1.prototype.j = function(t1) {
                return this.options.j = t1, this;
            }, c1.prototype.slaveOk = function(t1) {
                return this.options.slaveOk = !arguments.length || !!t1, this;
            }, c1.prototype.read = c1.prototype.setReadPreference = function(t1) {
                return arguments.length > 1 && !c1.prototype.read.deprecationWarningIssued && (console.error("Deprecation warning: 'tags' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead."), c1.prototype.read.deprecationWarningIssued = !0), this.options.readPreference = a1.readPref(t1), this;
            }, c1.prototype.readConcern = c1.prototype.r = function(t1) {
                return this.options.readConcern = a1.readConcern(t1), this;
            }, c1.prototype.tailable = function() {
                return this._validate("tailable"), this.options.tailable = !arguments.length || !!arguments[0], this;
            }, c1.prototype.writeConcern = c1.prototype.w = function(t1) {
                return "object" === n1(t1) ? (void 0 !== t1.j && (this.options.j = t1.j), void 0 !== t1.w && (this.options.w = t1.w), void 0 !== t1.wtimeout && (this.options.wtimeout = t1.wtimeout)) : this.options.w = "m" === t1 ? "majority" : t1, this;
            }, c1.prototype.wtimeout = c1.prototype.wTimeout = function(t1) {
                return this.options.wtimeout = t1, this;
            }, c1.prototype.merge = function(t1) {
                if (!t1) return this;
                if (!c1.canMerge(t1)) throw new TypeError("Invalid argument. Expected instanceof mquery or plain object");
                return t1 instanceof c1 ? (t1._conditions && a1.merge(this._conditions, t1._conditions), t1._fields && (this._fields || (this._fields = {}), a1.merge(this._fields, t1._fields)), t1.options && (this.options || (this.options = {}), a1.merge(this.options, t1.options)), t1._update && (this._update || (this._update = {}), a1.mergeClone(this._update, t1._update)), t1._distinct && (this._distinct = t1._distinct), this) : (a1.merge(this._conditions, t1), this);
            }, c1.prototype.find = function(t1, e1) {
                if (this.op = "find", "function" == typeof t1 ? (e1 = t1, t1 = void 0) : c1.canMerge(t1) && this.merge(t1), !e1) return this;
                var r1 = this._conditions, n1 = this._optionsForExec();
                return this.$useProjection ? n1.projection = this._fieldsForExec() : n1.fields = this._fieldsForExec(), u1("find", this._collection.collectionName, r1, n1), e1 = this._wrapCallback("find", e1, {
                    conditions: r1,
                    options: n1
                }), this._collection.find(r1, n1, a1.tick(e1)), this;
            }, c1.prototype.cursor = function(t1) {
                if (this.op) {
                    if ("find" !== this.op) throw new TypeError(".cursor only support .find method");
                } else this.find(t1);
                var e1 = this._conditions, r1 = this._optionsForExec();
                return this.$useProjection ? r1.projection = this._fieldsForExec() : r1.fields = this._fieldsForExec(), u1("findCursor", this._collection.collectionName, e1, r1), this._collection.findCursor(e1, r1);
            }, c1.prototype.findOne = function(t1, e1) {
                if (this.op = "findOne", "function" == typeof t1 ? (e1 = t1, t1 = void 0) : c1.canMerge(t1) && this.merge(t1), !e1) return this;
                var r1 = this._conditions, n1 = this._optionsForExec();
                return this.$useProjection ? n1.projection = this._fieldsForExec() : n1.fields = this._fieldsForExec(), u1("findOne", this._collection.collectionName, r1, n1), e1 = this._wrapCallback("findOne", e1, {
                    conditions: r1,
                    options: n1
                }), this._collection.findOne(r1, n1, a1.tick(e1)), this;
            }, c1.prototype.count = function(t1, e1) {
                if (this.op = "count", this._validate(), "function" == typeof t1 ? (e1 = t1, t1 = void 0) : c1.canMerge(t1) && this.merge(t1), !e1) return this;
                var r1 = this._conditions, n1 = this._optionsForExec();
                return u1("count", this._collection.collectionName, r1, n1), e1 = this._wrapCallback("count", e1, {
                    conditions: r1,
                    options: n1
                }), this._collection.count(r1, n1, a1.tick(e1)), this;
            }, c1.prototype.distinct = function(t1, e1, r1) {
                if (this.op = "distinct", this._validate(), !r1) {
                    switch(n1(e1)){
                        case "function":
                            r1 = e1, "string" == typeof t1 && (e1 = t1, t1 = void 0);
                            break;
                        case "undefined":
                        case "string":
                            break;
                        default:
                            throw new TypeError("Invalid `field` argument. Must be string or function");
                    }
                    switch(n1(t1)){
                        case "function":
                            r1 = t1, t1 = e1 = void 0;
                            break;
                        case "string":
                            e1 = t1, t1 = void 0;
                    }
                }
                if ("string" == typeof e1 && (this._distinct = e1), c1.canMerge(t1) && this.merge(t1), !r1) return this;
                if (!this._distinct) throw new Error("No value for `distinct` has been declared");
                var o1 = this._conditions, i1 = this._optionsForExec();
                return u1("distinct", this._collection.collectionName, o1, i1), r1 = this._wrapCallback("distinct", r1, {
                    conditions: o1,
                    options: i1
                }), this._collection.distinct(this._distinct, o1, i1, a1.tick(r1)), this;
            }, c1.prototype.update = function(t1, e1, r1, o1) {
                var i1;
                switch(arguments.length){
                    case 3:
                        "function" == typeof r1 && (o1 = r1, r1 = void 0);
                        break;
                    case 2:
                        "function" == typeof e1 && (o1 = e1, e1 = t1, t1 = void 0);
                        break;
                    case 1:
                        switch(n1(t1)){
                            case "function":
                                o1 = t1, t1 = r1 = e1 = void 0;
                                break;
                            case "boolean":
                                i1 = t1, t1 = void 0;
                                break;
                            default:
                                e1 = t1, t1 = r1 = void 0;
                        }
                }
                return d1(this, "update", t1, e1, r1, i1, o1);
            }, c1.prototype.updateMany = function(t1, e1, r1, o1) {
                var i1;
                switch(arguments.length){
                    case 3:
                        "function" == typeof r1 && (o1 = r1, r1 = void 0);
                        break;
                    case 2:
                        "function" == typeof e1 && (o1 = e1, e1 = t1, t1 = void 0);
                        break;
                    case 1:
                        switch(n1(t1)){
                            case "function":
                                o1 = t1, t1 = r1 = e1 = void 0;
                                break;
                            case "boolean":
                                i1 = t1, t1 = void 0;
                                break;
                            default:
                                e1 = t1, t1 = r1 = void 0;
                        }
                }
                return d1(this, "updateMany", t1, e1, r1, i1, o1);
            }, c1.prototype.updateOne = function(t1, e1, r1, o1) {
                var i1;
                switch(arguments.length){
                    case 3:
                        "function" == typeof r1 && (o1 = r1, r1 = void 0);
                        break;
                    case 2:
                        "function" == typeof e1 && (o1 = e1, e1 = t1, t1 = void 0);
                        break;
                    case 1:
                        switch(n1(t1)){
                            case "function":
                                o1 = t1, t1 = r1 = e1 = void 0;
                                break;
                            case "boolean":
                                i1 = t1, t1 = void 0;
                                break;
                            default:
                                e1 = t1, t1 = r1 = void 0;
                        }
                }
                return d1(this, "updateOne", t1, e1, r1, i1, o1);
            }, c1.prototype.replaceOne = function(t1, e1, r1, o1) {
                var i1;
                switch(arguments.length){
                    case 3:
                        "function" == typeof r1 && (o1 = r1, r1 = void 0);
                        break;
                    case 2:
                        "function" == typeof e1 && (o1 = e1, e1 = t1, t1 = void 0);
                        break;
                    case 1:
                        switch(n1(t1)){
                            case "function":
                                o1 = t1, t1 = r1 = e1 = void 0;
                                break;
                            case "boolean":
                                i1 = t1, t1 = void 0;
                                break;
                            default:
                                e1 = t1, t1 = r1 = void 0;
                        }
                }
                return this.setOptions({
                    overwrite: !0
                }), d1(this, "replaceOne", t1, e1, r1, i1, o1);
            }, c1.prototype.remove = function(t1, e1) {
                var r1;
                if (this.op = "remove", "function" == typeof t1 ? (e1 = t1, t1 = void 0) : c1.canMerge(t1) ? this.merge(t1) : !0 === t1 && (r1 = t1, t1 = void 0), !r1 && !e1) return this;
                var n1 = this._optionsForExec();
                e1 || (n1.safe = !1);
                var o1 = this._conditions;
                return u1("remove", this._collection.collectionName, o1, n1), e1 = this._wrapCallback("remove", e1, {
                    conditions: o1,
                    options: n1
                }), this._collection.remove(o1, n1, a1.tick(e1)), this;
            }, c1.prototype.deleteOne = function(t1, e1) {
                var r1;
                if (this.op = "deleteOne", "function" == typeof t1 ? (e1 = t1, t1 = void 0) : c1.canMerge(t1) ? this.merge(t1) : !0 === t1 && (r1 = t1, t1 = void 0), !r1 && !e1) return this;
                var n1 = this._optionsForExec();
                e1 || (n1.safe = !1), delete n1.justOne;
                var o1 = this._conditions;
                return u1("deleteOne", this._collection.collectionName, o1, n1), e1 = this._wrapCallback("deleteOne", e1, {
                    conditions: o1,
                    options: n1
                }), this._collection.deleteOne(o1, n1, a1.tick(e1)), this;
            }, c1.prototype.deleteMany = function(t1, e1) {
                var r1;
                if (this.op = "deleteMany", "function" == typeof t1 ? (e1 = t1, t1 = void 0) : c1.canMerge(t1) ? this.merge(t1) : !0 === t1 && (r1 = t1, t1 = void 0), !r1 && !e1) return this;
                var n1 = this._optionsForExec();
                e1 || (n1.safe = !1), delete n1.justOne;
                var o1 = this._conditions;
                return u1("deleteOne", this._collection.collectionName, o1, n1), e1 = this._wrapCallback("deleteOne", e1, {
                    conditions: o1,
                    options: n1
                }), this._collection.deleteMany(o1, n1, a1.tick(e1)), this;
            }, c1.prototype.findOneAndUpdate = function(t1, e1, r1, n1) {
                switch(this.op = "findOneAndUpdate", this._validate(), arguments.length){
                    case 3:
                        "function" == typeof r1 && (n1 = r1, r1 = {});
                        break;
                    case 2:
                        "function" == typeof e1 && (n1 = e1, e1 = t1, t1 = void 0), r1 = void 0;
                        break;
                    case 1:
                        "function" == typeof t1 ? (n1 = t1, t1 = r1 = e1 = void 0) : (e1 = t1, t1 = r1 = void 0);
                }
                return c1.canMerge(t1) && this.merge(t1), e1 && this._mergeUpdate(e1), r1 && this.setOptions(r1), n1 ? this._findAndModify("update", n1) : this;
            }, c1.prototype.findOneAndRemove = c1.prototype.findOneAndDelete = function(t1, e1, r1) {
                return this.op = "findOneAndRemove", this._validate(), "function" == typeof e1 ? (r1 = e1, e1 = void 0) : "function" == typeof t1 && (r1 = t1, t1 = void 0), c1.canMerge(t1) && this.merge(t1), e1 && this.setOptions(e1), r1 ? this._findAndModify("remove", r1) : this;
            }, c1.prototype._findAndModify = function(t1, e1) {
                i1.equal("function", n1(e1));
                var r1, o1 = this._optionsForExec();
                if ("remove" == t1) o1.remove = !0;
                else if ("new" in o1 || (o1.new = !0), "upsert" in o1 || (o1.upsert = !1), !(r1 = this._updateForExec())) {
                    if (!o1.upsert) return this.findOne(e1);
                    r1 = {
                        $set: {}
                    };
                }
                null != this._fieldsForExec() && (this.$useProjection ? o1.projection = this._fieldsForExec() : o1.fields = this._fieldsForExec());
                var s1 = this._conditions;
                return u1("findAndModify", this._collection.collectionName, s1, r1, o1), e1 = this._wrapCallback("findAndModify", e1, {
                    conditions: s1,
                    doc: r1,
                    options: o1
                }), this._collection.findAndModify(s1, r1, o1, a1.tick(e1)), this;
            }, c1.prototype._wrapCallback = function(t1, e1, r1) {
                var n1 = this._traceFunction || c1.traceFunction;
                if (n1) {
                    r1.collectionName = this._collection.collectionName;
                    var o1 = n1 && n1.call(null, t1, r1, this), i1 = (new Date).getTime();
                    return function(t1, r1) {
                        if (o1) {
                            var n1 = (new Date).getTime() - i1;
                            o1.call(null, t1, r1, n1);
                        }
                        e1 && e1.apply(null, arguments);
                    };
                }
                return e1;
            }, c1.prototype.setTraceFunction = function(t1) {
                return this._traceFunction = t1, this;
            }, c1.prototype.exec = function(t1, e1) {
                switch(n1(t1)){
                    case "function":
                        e1 = t1, t1 = null;
                        break;
                    case "string":
                        this.op = t1;
                }
                i1.ok(this.op, "Missing query type: (find, update, etc)"), "update" != this.op && "remove" != this.op || e1 || (e1 = !0);
                var r1 = this;
                if ("function" != typeof e1) return new c1.Promise(function(t1, e1) {
                    r1[r1.op](function(r1, n1) {
                        r1 ? e1(r1) : t1(n1), t1 = e1 = null;
                    });
                });
                this[this.op](e1);
            }, c1.prototype.thunk = function() {
                var t1 = this;
                return function(e1) {
                    t1.exec(e1);
                };
            }, c1.prototype.then = function(t1, e1) {
                var r1 = this;
                return new c1.Promise(function(t1, e1) {
                    r1.exec(function(r1, n1) {
                        r1 ? e1(r1) : t1(n1), t1 = e1 = null;
                    });
                }).then(t1, e1);
            }, c1.prototype.stream = function(t1) {
                if ("find" != this.op) throw new Error("stream() is only available for find");
                var e1 = this._conditions, r1 = this._optionsForExec();
                return this.$useProjection ? r1.projection = this._fieldsForExec() : r1.fields = this._fieldsForExec(), u1("stream", this._collection.collectionName, e1, r1, t1), this._collection.findStream(e1, r1, t1);
            }, c1.prototype.selected = function() {
                return !!(this._fields && Object.keys(this._fields).length > 0);
            }, c1.prototype.selectedInclusively = function() {
                if (!this._fields) return !1;
                var t1 = Object.keys(this._fields);
                if (0 === t1.length) return !1;
                for(var e1 = 0; e1 < t1.length; ++e1){
                    var r1 = t1[e1];
                    if (0 === this._fields[r1]) return !1;
                    if (this._fields[r1] && "object" === n1(this._fields[r1]) && this._fields[r1].$meta) return !1;
                }
                return !0;
            }, c1.prototype.selectedExclusively = function() {
                if (!this._fields) return !1;
                var t1 = Object.keys(this._fields);
                if (0 === t1.length) return !1;
                for(var e1 = 0; e1 < t1.length; ++e1){
                    var r1 = t1[e1];
                    if (0 === this._fields[r1]) return !0;
                }
                return !1;
            }, c1.prototype._mergeUpdate = function(t1) {
                this._update || (this._update = {}), t1 instanceof c1 ? t1._update && a1.mergeClone(this._update, t1._update) : a1.mergeClone(this._update, t1);
            }, c1.prototype._optionsForExec = function() {
                return a1.clone(this.options);
            }, c1.prototype._fieldsForExec = function() {
                return a1.clone(this._fields);
            }, c1.prototype._updateForExec = function() {
                for(var t1 = a1.clone(this._update), e1 = a1.keys(t1), r1 = e1.length, n1 = {}; r1--;){
                    var o1 = e1[r1];
                    this.options.overwrite ? n1[o1] = t1[o1] : "$" !== o1[0] ? (n1.$set || (t1.$set ? n1.$set = t1.$set : n1.$set = {}), n1.$set[o1] = t1[o1], e1.splice(r1, 1), ~e1.indexOf("$set") || e1.push("$set")) : "$set" === o1 && n1.$set || (n1[o1] = t1[o1]);
                }
                return this._compiledUpdate = n1, n1;
            }, c1.prototype._ensurePath = function(t1) {
                if (!this._path) throw new Error(t1 + "() must be used after where() when called with these arguments");
            }, /*!
 * Permissions
 */ c1.permissions = r1(121), c1._isPermitted = function(t1, e1) {
                var r1 = c1.permissions[e1];
                return !r1 || !0 !== r1[t1];
            }, c1.prototype._validate = function(t1) {
                var e1, r1;
                if (void 0 === t1) {
                    if ("function" != typeof (r1 = c1.permissions[this.op])) return !0;
                    e1 = r1(this);
                } else c1._isPermitted(t1, this.op) || (e1 = t1);
                if (e1) throw new Error(e1 + " cannot be used with " + this.op);
            }, c1.canMerge = function(t1) {
                return t1 instanceof c1 || a1.isObject(t1);
            }, c1.setGlobalTraceFunction = function(t1) {
                c1.traceFunction = t1;
            }, /*!
 * Exports.
 */ c1.utils = a1, c1.env = r1(70), c1.Collection = r1(123), c1.BaseCollection = r1(30), c1.Promise = r1(125), t1.exports = c1;
        },
        function(t1, e1, r1) {
            (function(t1, e1) {
                !function(t1, r1) {
                    "use strict";
                    if (!t1.setImmediate) {
                        var n1, o1, i1, s1, a1, u1 = 1, c1 = {}, l1 = !1, f1 = t1.document, p1 = Object.getPrototypeOf && Object.getPrototypeOf(t1);
                        p1 = p1 && p1.setTimeout ? p1 : t1, "[object process]" === ({}).toString.call(t1.process) ? n1 = function(t1) {
                            e1.nextTick(function() {
                                y1(t1);
                            });
                        } : !function() {
                            if (t1.postMessage && !t1.importScripts) {
                                var e1 = !0, r1 = t1.onmessage;
                                return t1.onmessage = function() {
                                    e1 = !1;
                                }, t1.postMessage("", "*"), t1.onmessage = r1, e1;
                            }
                        }() ? t1.MessageChannel ? ((i1 = new MessageChannel).port1.onmessage = function(t1) {
                            y1(t1.data);
                        }, n1 = function(t1) {
                            i1.port2.postMessage(t1);
                        }) : f1 && "onreadystatechange" in f1.createElement("script") ? (o1 = f1.documentElement, n1 = function(t1) {
                            var e1 = f1.createElement("script");
                            e1.onreadystatechange = function() {
                                y1(t1), e1.onreadystatechange = null, o1.removeChild(e1), e1 = null;
                            }, o1.appendChild(e1);
                        }) : n1 = function(t1) {
                            setTimeout(y1, 0, t1);
                        } : (s1 = "setImmediate$" + Math.random() + "$", a1 = function(e1) {
                            e1.source === t1 && "string" == typeof e1.data && 0 === e1.data.indexOf(s1) && y1(+e1.data.slice(s1.length));
                        }, t1.addEventListener ? t1.addEventListener("message", a1, !1) : t1.attachEvent("onmessage", a1), n1 = function(e1) {
                            t1.postMessage(s1 + e1, "*");
                        }), p1.setImmediate = function(t1) {
                            "function" != typeof t1 && (t1 = new Function("" + t1));
                            for(var e1 = new Array(arguments.length - 1), r1 = 0; r1 < e1.length; r1++)e1[r1] = arguments[r1 + 1];
                            var o1 = {
                                callback: t1,
                                args: e1
                            };
                            return c1[u1] = o1, n1(u1), u1++;
                        }, p1.clearImmediate = h1;
                    }
                    function h1(t1) {
                        delete c1[t1];
                    }
                    function y1(t1) {
                        if (l1) setTimeout(y1, 0, t1);
                        else {
                            var e1 = c1[t1];
                            if (e1) {
                                l1 = !0;
                                try {
                                    !function(t1) {
                                        var e1 = t1.callback, r1 = t1.args;
                                        switch(r1.length){
                                            case 0:
                                                e1();
                                                break;
                                            case 1:
                                                e1(r1[0]);
                                                break;
                                            case 2:
                                                e1(r1[0], r1[1]);
                                                break;
                                            case 3:
                                                e1(r1[0], r1[1], r1[2]);
                                                break;
                                            default:
                                                e1.apply(void 0, r1);
                                        }
                                    }(e1);
                                } finally{
                                    h1(t1), l1 = !1;
                                }
                            }
                        }
                    }
                }("undefined" == typeof self ? void 0 === t1 ? this : t1 : self);
            }).call(this, r1(11), r1(8));
        },
        function(t1, e1, r1) {
            var n1 = r1(1), o1 = n1.Buffer;
            function i1(t1, e1) {
                for(var r1 in t1)e1[r1] = t1[r1];
            }
            function s1(t1, e1, r1) {
                return o1(t1, e1, r1);
            }
            o1.from && o1.alloc && o1.allocUnsafe && o1.allocUnsafeSlow ? t1.exports = n1 : (i1(n1, e1), e1.Buffer = s1), i1(o1, s1), s1.from = function(t1, e1, r1) {
                if ("number" == typeof t1) throw new TypeError("Argument must not be a number");
                return o1(t1, e1, r1);
            }, s1.alloc = function(t1, e1, r1) {
                if ("number" != typeof t1) throw new TypeError("Argument must be a number");
                var n1 = o1(t1);
                return void 0 !== e1 ? "string" == typeof r1 ? n1.fill(e1, r1) : n1.fill(e1) : n1.fill(0), n1;
            }, s1.allocUnsafe = function(t1) {
                if ("number" != typeof t1) throw new TypeError("Argument must be a number");
                return o1(t1);
            }, s1.allocUnsafeSlow = function(t1) {
                if ("number" != typeof t1) throw new TypeError("Argument must be a number");
                return n1.SlowBuffer(t1);
            };
        },
        function(t1, e1, r1) {
            (function(n1) {
                function o1(t1) {
                    return (o1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                function i1() {
                    var t1;
                    try {
                        t1 = e1.storage.debug;
                    } catch (t1) {}
                    return !t1 && void 0 !== n1 && "env" in n1 && (t1 = n1.env.DEBUG), t1;
                }
                (e1 = t1.exports = r1(119)).log = function() {
                    return "object" === ("undefined" == typeof console ? "undefined" : o1(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
                }, e1.formatArgs = function(t1) {
                    var r1 = this.useColors;
                    if (t1[0] = (r1 ? "%c" : "") + this.namespace + (r1 ? " %c" : " ") + t1[0] + (r1 ? "%c " : " ") + "+" + e1.humanize(this.diff), !r1) return;
                    var n1 = "color: " + this.color;
                    t1.splice(1, 0, n1, "color: inherit");
                    var o1 = 0, i1 = 0;
                    t1[0].replace(/%[a-zA-Z%]/g, function(t1) {
                        "%%" !== t1 && (o1++, "%c" === t1 && (i1 = o1));
                    }), t1.splice(i1, 0, n1);
                }, e1.save = function(t1) {
                    try {
                        null == t1 ? e1.storage.removeItem("debug") : e1.storage.debug = t1;
                    } catch (t1) {}
                }, e1.load = i1, e1.useColors = function() {
                    if ("undefined" != typeof window && window.process && "renderer" === window.process.type) return !0;
                    if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
                    return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
                }, e1.storage = "undefined" != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : function() {
                    try {
                        return window.localStorage;
                    } catch (t1) {}
                }(), e1.colors = [
                    "#0000CC",
                    "#0000FF",
                    "#0033CC",
                    "#0033FF",
                    "#0066CC",
                    "#0066FF",
                    "#0099CC",
                    "#0099FF",
                    "#00CC00",
                    "#00CC33",
                    "#00CC66",
                    "#00CC99",
                    "#00CCCC",
                    "#00CCFF",
                    "#3300CC",
                    "#3300FF",
                    "#3333CC",
                    "#3333FF",
                    "#3366CC",
                    "#3366FF",
                    "#3399CC",
                    "#3399FF",
                    "#33CC00",
                    "#33CC33",
                    "#33CC66",
                    "#33CC99",
                    "#33CCCC",
                    "#33CCFF",
                    "#6600CC",
                    "#6600FF",
                    "#6633CC",
                    "#6633FF",
                    "#66CC00",
                    "#66CC33",
                    "#9900CC",
                    "#9900FF",
                    "#9933CC",
                    "#9933FF",
                    "#99CC00",
                    "#99CC33",
                    "#CC0000",
                    "#CC0033",
                    "#CC0066",
                    "#CC0099",
                    "#CC00CC",
                    "#CC00FF",
                    "#CC3300",
                    "#CC3333",
                    "#CC3366",
                    "#CC3399",
                    "#CC33CC",
                    "#CC33FF",
                    "#CC6600",
                    "#CC6633",
                    "#CC9900",
                    "#CC9933",
                    "#CCCC00",
                    "#CCCC33",
                    "#FF0000",
                    "#FF0033",
                    "#FF0066",
                    "#FF0099",
                    "#FF00CC",
                    "#FF00FF",
                    "#FF3300",
                    "#FF3333",
                    "#FF3366",
                    "#FF3399",
                    "#FF33CC",
                    "#FF33FF",
                    "#FF6600",
                    "#FF6633",
                    "#FF9900",
                    "#FF9933",
                    "#FFCC00",
                    "#FFCC33"
                ], e1.formatters.j = function(t1) {
                    try {
                        return JSON.stringify(t1);
                    } catch (t1) {
                        return "[UnexpectedJSONParseError]: " + t1.message;
                    }
                }, e1.enable(i1());
            }).call(this, r1(8));
        },
        function(t1, e1, r1) {
            function n1(t1) {
                var r1;
                function n1() {
                    if (n1.enabled) {
                        var t1 = n1, o1 = +new Date, i1 = o1 - (r1 || o1);
                        t1.diff = i1, t1.prev = r1, t1.curr = o1, r1 = o1;
                        for(var s1 = new Array(arguments.length), a1 = 0; a1 < s1.length; a1++)s1[a1] = arguments[a1];
                        s1[0] = e1.coerce(s1[0]), "string" != typeof s1[0] && s1.unshift("%O");
                        var u1 = 0;
                        s1[0] = s1[0].replace(/%([a-zA-Z%])/g, function(r1, n1) {
                            if ("%%" === r1) return r1;
                            u1++;
                            var o1 = e1.formatters[n1];
                            if ("function" == typeof o1) {
                                var i1 = s1[u1];
                                r1 = o1.call(t1, i1), s1.splice(u1, 1), u1--;
                            }
                            return r1;
                        }), e1.formatArgs.call(t1, s1);
                        var c1 = n1.log || e1.log || console.log.bind(console);
                        c1.apply(t1, s1);
                    }
                }
                return n1.namespace = t1, n1.enabled = e1.enabled(t1), n1.useColors = e1.useColors(), n1.color = function(t1) {
                    var r1, n1 = 0;
                    for(r1 in t1)n1 = (n1 << 5) - n1 + t1.charCodeAt(r1), n1 |= 0;
                    return e1.colors[Math.abs(n1) % e1.colors.length];
                }(t1), n1.destroy = o1, "function" == typeof e1.init && e1.init(n1), e1.instances.push(n1), n1;
            }
            function o1() {
                var t1 = e1.instances.indexOf(this);
                return -1 !== t1 && (e1.instances.splice(t1, 1), !0);
            }
            (e1 = t1.exports = n1.debug = n1.default = n1).coerce = function(t1) {
                return t1 instanceof Error ? t1.stack || t1.message : t1;
            }, e1.disable = function() {
                e1.enable("");
            }, e1.enable = function(t1) {
                var r1;
                e1.save(t1), e1.names = [], e1.skips = [];
                var n1 = ("string" == typeof t1 ? t1 : "").split(/[\s,]+/), o1 = n1.length;
                for(r1 = 0; r1 < o1; r1++)n1[r1] && ("-" === (t1 = n1[r1].replace(/\*/g, ".*?"))[0] ? e1.skips.push(new RegExp("^" + t1.substr(1) + "$")) : e1.names.push(new RegExp("^" + t1 + "$")));
                for(r1 = 0; r1 < e1.instances.length; r1++){
                    var i1 = e1.instances[r1];
                    i1.enabled = e1.enabled(i1.namespace);
                }
            }, e1.enabled = function(t1) {
                if ("*" === t1[t1.length - 1]) return !0;
                var r1, n1;
                for(r1 = 0, n1 = e1.skips.length; r1 < n1; r1++)if (e1.skips[r1].test(t1)) return !1;
                for(r1 = 0, n1 = e1.names.length; r1 < n1; r1++)if (e1.names[r1].test(t1)) return !0;
                return !1;
            }, e1.humanize = r1(120), e1.instances = [], e1.names = [], e1.skips = [], e1.formatters = {};
        },
        function(t1, e1) {
            function r1(t1) {
                return (r1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            var n1 = 1e3, o1 = 6e4, i1 = 60 * o1, s1 = 24 * i1;
            function a1(t1, e1, r1) {
                if (!(t1 < e1)) return t1 < 1.5 * e1 ? Math.floor(t1 / e1) + " " + r1 : Math.ceil(t1 / e1) + " " + r1 + "s";
            }
            t1.exports = function(t1, e1) {
                e1 = e1 || {};
                var u1, c1 = r1(t1);
                if ("string" === c1 && t1.length > 0) return function(t1) {
                    if ((t1 = String(t1)).length > 100) return;
                    var e1 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t1);
                    if (!e1) return;
                    var r1 = parseFloat(e1[1]);
                    switch((e1[2] || "ms").toLowerCase()){
                        case "years":
                        case "year":
                        case "yrs":
                        case "yr":
                        case "y":
                            return 315576e5 * r1;
                        case "days":
                        case "day":
                        case "d":
                            return r1 * s1;
                        case "hours":
                        case "hour":
                        case "hrs":
                        case "hr":
                        case "h":
                            return r1 * i1;
                        case "minutes":
                        case "minute":
                        case "mins":
                        case "min":
                        case "m":
                            return r1 * o1;
                        case "seconds":
                        case "second":
                        case "secs":
                        case "sec":
                        case "s":
                            return r1 * n1;
                        case "milliseconds":
                        case "millisecond":
                        case "msecs":
                        case "msec":
                        case "ms":
                            return r1;
                        default:
                            return;
                    }
                }(t1);
                if ("number" === c1 && !1 === isNaN(t1)) return e1.long ? a1(u1 = t1, s1, "day") || a1(u1, i1, "hour") || a1(u1, o1, "minute") || a1(u1, n1, "second") || u1 + " ms" : function(t1) {
                    if (t1 >= s1) return Math.round(t1 / s1) + "d";
                    if (t1 >= i1) return Math.round(t1 / i1) + "h";
                    if (t1 >= o1) return Math.round(t1 / o1) + "m";
                    if (t1 >= n1) return Math.round(t1 / n1) + "s";
                    return t1 + "ms";
                }(t1);
                throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t1));
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = e1;
            n1.distinct = function(t1) {
                var e1;
                return t1._fields && Object.keys(t1._fields).length > 0 ? "field selection and slice" : (Object.keys(n1.distinct).every(function(r1) {
                    return !t1.options[r1] || (e1 = r1, !1);
                }), e1);
            }, n1.distinct.select = n1.distinct.slice = n1.distinct.sort = n1.distinct.limit = n1.distinct.skip = n1.distinct.batchSize = n1.distinct.comment = n1.distinct.maxScan = n1.distinct.snapshot = n1.distinct.hint = n1.distinct.tailable = !0, n1.findOneAndUpdate = n1.findOneAndRemove = function(t1) {
                var e1;
                return Object.keys(n1.findOneAndUpdate).every(function(r1) {
                    return !t1.options[r1] || (e1 = r1, !1);
                }), e1;
            }, n1.findOneAndUpdate.limit = n1.findOneAndUpdate.skip = n1.findOneAndUpdate.batchSize = n1.findOneAndUpdate.maxScan = n1.findOneAndUpdate.snapshot = n1.findOneAndUpdate.hint = n1.findOneAndUpdate.tailable = n1.findOneAndUpdate.comment = !0, n1.count = function(t1) {
                var e1;
                return t1._fields && Object.keys(t1._fields).length > 0 ? "field selection and slice" : (Object.keys(n1.count).every(function(r1) {
                    return !t1.options[r1] || (e1 = r1, !1);
                }), e1);
            }, n1.count.slice = n1.count.batchSize = n1.count.comment = n1.count.maxScan = n1.count.snapshot = n1.count.tailable = !0;
        },
        function(t1, e1) {
            t1.exports = function(t1) {
                return t1.webpackPolyfill || (t1.deprecate = function() {}, t1.paths = [], t1.children || (t1.children = []), Object.defineProperty(t1, "loaded", {
                    enumerable: !0,
                    get: function() {
                        return t1.l;
                    }
                }), Object.defineProperty(t1, "id", {
                    enumerable: !0,
                    get: function() {
                        return t1.i;
                    }
                }), t1.webpackPolyfill = 1), t1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(70);
            if ("unknown" == n1.type) throw new Error("Unknown environment");
            t1.exports = n1.isNode ? r1(124) : (n1.isMongo, r1(30));
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(30);
            function o1(t1) {
                this.collection = t1, this.collectionName = t1.collectionName;
            }
            r1(68).inherits(o1, n1), o1.prototype.find = function(t1, e1, r1) {
                this.collection.find(t1, e1, function(t1, e1) {
                    if (t1) return r1(t1);
                    try {
                        e1.toArray(r1);
                    } catch (t1) {
                        r1(t1);
                    }
                });
            }, o1.prototype.findOne = function(t1, e1, r1) {
                this.collection.findOne(t1, e1, r1);
            }, o1.prototype.count = function(t1, e1, r1) {
                this.collection.count(t1, e1, r1);
            }, o1.prototype.distinct = function(t1, e1, r1, n1) {
                this.collection.distinct(t1, e1, r1, n1);
            }, o1.prototype.update = function(t1, e1, r1, n1) {
                this.collection.update(t1, e1, r1, n1);
            }, o1.prototype.updateMany = function(t1, e1, r1, n1) {
                this.collection.updateMany(t1, e1, r1, n1);
            }, o1.prototype.updateOne = function(t1, e1, r1, n1) {
                this.collection.updateOne(t1, e1, r1, n1);
            }, o1.prototype.replaceOne = function(t1, e1, r1, n1) {
                this.collection.replaceOne(t1, e1, r1, n1);
            }, o1.prototype.deleteOne = function(t1, e1, r1) {
                this.collection.deleteOne(t1, e1, r1);
            }, o1.prototype.deleteMany = function(t1, e1, r1) {
                this.collection.deleteMany(t1, e1, r1);
            }, o1.prototype.remove = function(t1, e1, r1) {
                this.collection.remove(t1, e1, r1);
            }, o1.prototype.findAndModify = function(t1, e1, r1, n1) {
                var o1 = Array.isArray(r1.sort) ? r1.sort : [];
                this.collection.findAndModify(t1, o1, e1, r1, n1);
            }, o1.prototype.findStream = function(t1, e1, r1) {
                return this.collection.find(t1, e1).stream(r1);
            }, o1.prototype.findCursor = function(t1, e1) {
                return this.collection.find(t1, e1);
            }, t1.exports = o1;
        },
        function(t1, e1, r1) {
            (function(r1, n1, o1) {
                var i1, s1, a1, u1;
                function c1(t1) {
                    return (c1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                /* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2013-2017 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */ u1 = function() {
                    var t1, e1, i1;
                    return (function t1(e1, r1, n1) {
                        function o1(s1, a1) {
                            if (!r1[s1]) {
                                if (!e1[s1]) {
                                    var u1 = "function" == typeof _dereq_ && _dereq_;
                                    if (!a1 && u1) return u1(s1, !0);
                                    if (i1) return i1(s1, !0);
                                    var c1 = new Error("Cannot find module '" + s1 + "'");
                                    throw c1.code = "MODULE_NOT_FOUND", c1;
                                }
                                var l1 = r1[s1] = {
                                    exports: {}
                                };
                                e1[s1][0].call(l1.exports, function(t1) {
                                    var r1 = e1[s1][1][t1];
                                    return o1(r1 || t1);
                                }, l1, l1.exports, t1, e1, r1, n1);
                            }
                            return r1[s1].exports;
                        }
                        for(var i1 = "function" == typeof _dereq_ && _dereq_, s1 = 0; s1 < n1.length; s1++)o1(n1[s1]);
                        return o1;
                    })({
                        1: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(t1) {
                                    var e1 = t1._SomePromiseArray;
                                    function r1(t1) {
                                        var r1 = new e1(t1), n1 = r1.promise();
                                        return r1.setHowMany(1), r1.setUnwrap(), r1.init(), n1;
                                    }
                                    t1.any = function(t1) {
                                        return r1(t1);
                                    }, t1.prototype.any = function() {
                                        return r1(this);
                                    };
                                };
                            },
                            {}
                        ],
                        2: [
                            function(t1, e1, n1) {
                                "use strict";
                                var o1;
                                try {
                                    throw new Error;
                                } catch (t1) {
                                    o1 = t1;
                                }
                                var i1 = t1("./schedule"), s1 = t1("./queue"), a1 = t1("./util");
                                function u1() {
                                    this._customScheduler = !1, this._isTickUsed = !1, this._lateQueue = new s1(16), this._normalQueue = new s1(16), this._haveDrainedQueues = !1, this._trampolineEnabled = !0;
                                    var t1 = this;
                                    this.drainQueues = function() {
                                        t1._drainQueues();
                                    }, this._schedule = i1;
                                }
                                function c1(t1, e1, r1) {
                                    this._lateQueue.push(t1, e1, r1), this._queueTick();
                                }
                                function l1(t1, e1, r1) {
                                    this._normalQueue.push(t1, e1, r1), this._queueTick();
                                }
                                function f1(t1) {
                                    this._normalQueue._pushOne(t1), this._queueTick();
                                }
                                u1.prototype.setScheduler = function(t1) {
                                    var e1 = this._schedule;
                                    return this._schedule = t1, this._customScheduler = !0, e1;
                                }, u1.prototype.hasCustomScheduler = function() {
                                    return this._customScheduler;
                                }, u1.prototype.enableTrampoline = function() {
                                    this._trampolineEnabled = !0;
                                }, u1.prototype.disableTrampolineIfNecessary = function() {
                                    a1.hasDevTools && (this._trampolineEnabled = !1);
                                }, u1.prototype.haveItemsQueued = function() {
                                    return this._isTickUsed || this._haveDrainedQueues;
                                }, u1.prototype.fatalError = function(t1, e1) {
                                    e1 ? (r1.stderr.write("Fatal " + (t1 instanceof Error ? t1.stack : t1) + "\n"), r1.exit(2)) : this.throwLater(t1);
                                }, u1.prototype.throwLater = function(t1, e1) {
                                    if (1 === arguments.length && (e1 = t1, t1 = function() {
                                        throw e1;
                                    }), "undefined" != typeof setTimeout) setTimeout(function() {
                                        t1(e1);
                                    }, 0);
                                    else try {
                                        this._schedule(function() {
                                            t1(e1);
                                        });
                                    } catch (t1) {
                                        throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
                                    }
                                }, a1.hasDevTools ? (u1.prototype.invokeLater = function(t1, e1, r1) {
                                    this._trampolineEnabled ? c1.call(this, t1, e1, r1) : this._schedule(function() {
                                        setTimeout(function() {
                                            t1.call(e1, r1);
                                        }, 100);
                                    });
                                }, u1.prototype.invoke = function(t1, e1, r1) {
                                    this._trampolineEnabled ? l1.call(this, t1, e1, r1) : this._schedule(function() {
                                        t1.call(e1, r1);
                                    });
                                }, u1.prototype.settlePromises = function(t1) {
                                    this._trampolineEnabled ? f1.call(this, t1) : this._schedule(function() {
                                        t1._settlePromises();
                                    });
                                }) : (u1.prototype.invokeLater = c1, u1.prototype.invoke = l1, u1.prototype.settlePromises = f1), u1.prototype._drainQueue = function(t1) {
                                    for(; t1.length() > 0;){
                                        var e1 = t1.shift();
                                        if ("function" == typeof e1) {
                                            var r1 = t1.shift(), n1 = t1.shift();
                                            e1.call(r1, n1);
                                        } else e1._settlePromises();
                                    }
                                }, u1.prototype._drainQueues = function() {
                                    this._drainQueue(this._normalQueue), this._reset(), this._haveDrainedQueues = !0, this._drainQueue(this._lateQueue);
                                }, u1.prototype._queueTick = function() {
                                    this._isTickUsed || (this._isTickUsed = !0, this._schedule(this.drainQueues));
                                }, u1.prototype._reset = function() {
                                    this._isTickUsed = !1;
                                }, e1.exports = u1, e1.exports.firstLineError = o1;
                            },
                            {
                                "./queue": 26,
                                "./schedule": 29,
                                "./util": 36
                            }
                        ],
                        3: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(t1, e1, r1, n1) {
                                    var o1 = !1, i1 = function(t1, e1) {
                                        this._reject(e1);
                                    }, s1 = function(t1, e1) {
                                        e1.promiseRejectionQueued = !0, e1.bindingPromise._then(i1, i1, null, this, t1);
                                    }, a1 = function(t1, e1) {
                                        0 == (50397184 & this._bitField) && this._resolveCallback(e1.target);
                                    }, u1 = function(t1, e1) {
                                        e1.promiseRejectionQueued || this._reject(t1);
                                    };
                                    t1.prototype.bind = function(i1) {
                                        o1 || (o1 = !0, t1.prototype._propagateFrom = n1.propagateFromFunction(), t1.prototype._boundValue = n1.boundValueFunction());
                                        var c1 = r1(i1), l1 = new t1(e1);
                                        l1._propagateFrom(this, 1);
                                        var f1 = this._target();
                                        if (l1._setBoundTo(c1), c1 instanceof t1) {
                                            var p1 = {
                                                promiseRejectionQueued: !1,
                                                promise: l1,
                                                target: f1,
                                                bindingPromise: c1
                                            };
                                            f1._then(e1, s1, void 0, l1, p1), c1._then(a1, u1, void 0, l1, p1), l1._setOnCancel(c1);
                                        } else l1._resolveCallback(f1);
                                        return l1;
                                    }, t1.prototype._setBoundTo = function(t1) {
                                        void 0 !== t1 ? (this._bitField = 2097152 | this._bitField, this._boundTo = t1) : this._bitField = -2097153 & this._bitField;
                                    }, t1.prototype._isBound = function() {
                                        return 2097152 == (2097152 & this._bitField);
                                    }, t1.bind = function(e1, r1) {
                                        return t1.resolve(r1).bind(e1);
                                    };
                                };
                            },
                            {}
                        ],
                        4: [
                            function(t1, e1, r1) {
                                "use strict";
                                var n1;
                                "undefined" != typeof Promise && (n1 = Promise);
                                var o1 = t1("./promise")();
                                o1.noConflict = function() {
                                    try {
                                        Promise === o1 && (Promise = n1);
                                    } catch (t1) {}
                                    return o1;
                                }, e1.exports = o1;
                            },
                            {
                                "./promise": 22
                            }
                        ],
                        5: [
                            function(t1, e1, r1) {
                                "use strict";
                                var n1 = Object.create;
                                if (n1) {
                                    var o1 = n1(null), i1 = n1(null);
                                    o1[" size"] = i1[" size"] = 0;
                                }
                                e1.exports = function(e1) {
                                    var r1 = t1("./util"), n1 = r1.canEvaluate;
                                    function o1(t1) {
                                        return (function(t1, n1) {
                                            var o1;
                                            if (null != t1 && (o1 = t1[n1]), "function" != typeof o1) {
                                                var i1 = "Object " + r1.classString(t1) + " has no method '" + r1.toString(n1) + "'";
                                                throw new e1.TypeError(i1);
                                            }
                                            return o1;
                                        })(t1, this.pop()).apply(t1, this);
                                    }
                                    function i1(t1) {
                                        return t1[this];
                                    }
                                    function s1(t1) {
                                        var e1 = +this;
                                        return e1 < 0 && (e1 = Math.max(0, e1 + t1.length)), t1[e1];
                                    }
                                    r1.isIdentifier, e1.prototype.call = function(t1) {
                                        var e1 = [].slice.call(arguments, 1);
                                        return e1.push(t1), this._then(o1, void 0, void 0, e1, void 0);
                                    }, e1.prototype.get = function(t1) {
                                        var e1;
                                        if ("number" == typeof t1) e1 = s1;
                                        else if (n1) {
                                            var r1 = (void 0)(t1);
                                            e1 = null !== r1 ? r1 : i1;
                                        } else e1 = i1;
                                        return this._then(e1, void 0, void 0, t1, void 0);
                                    };
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        6: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1, o1) {
                                    var i1 = t1("./util"), s1 = i1.tryCatch, a1 = i1.errorObj, u1 = e1._async;
                                    e1.prototype.break = e1.prototype.cancel = function() {
                                        if (!o1.cancellation()) return this._warn("cancellation is disabled");
                                        for(var t1 = this, e1 = t1; t1._isCancellable();){
                                            if (!t1._cancelBy(e1)) {
                                                e1._isFollowing() ? e1._followee().cancel() : e1._cancelBranched();
                                                break;
                                            }
                                            var r1 = t1._cancellationParent;
                                            if (null == r1 || !r1._isCancellable()) {
                                                t1._isFollowing() ? t1._followee().cancel() : t1._cancelBranched();
                                                break;
                                            }
                                            t1._isFollowing() && t1._followee().cancel(), t1._setWillBeCancelled(), e1 = t1, t1 = r1;
                                        }
                                    }, e1.prototype._branchHasCancelled = function() {
                                        this._branchesRemainingToCancel--;
                                    }, e1.prototype._enoughBranchesHaveCancelled = function() {
                                        return void 0 === this._branchesRemainingToCancel || this._branchesRemainingToCancel <= 0;
                                    }, e1.prototype._cancelBy = function(t1) {
                                        return t1 === this ? (this._branchesRemainingToCancel = 0, this._invokeOnCancel(), !0) : (this._branchHasCancelled(), !!this._enoughBranchesHaveCancelled() && (this._invokeOnCancel(), !0));
                                    }, e1.prototype._cancelBranched = function() {
                                        this._enoughBranchesHaveCancelled() && this._cancel();
                                    }, e1.prototype._cancel = function() {
                                        this._isCancellable() && (this._setCancelled(), u1.invoke(this._cancelPromises, this, void 0));
                                    }, e1.prototype._cancelPromises = function() {
                                        this._length() > 0 && this._settlePromises();
                                    }, e1.prototype._unsetOnCancel = function() {
                                        this._onCancelField = void 0;
                                    }, e1.prototype._isCancellable = function() {
                                        return this.isPending() && !this._isCancelled();
                                    }, e1.prototype.isCancellable = function() {
                                        return this.isPending() && !this.isCancelled();
                                    }, e1.prototype._doInvokeOnCancel = function(t1, e1) {
                                        if (i1.isArray(t1)) for(var r1 = 0; r1 < t1.length; ++r1)this._doInvokeOnCancel(t1[r1], e1);
                                        else if (void 0 !== t1) {
                                            if ("function" == typeof t1) {
                                                if (!e1) {
                                                    var n1 = s1(t1).call(this._boundValue());
                                                    n1 === a1 && (this._attachExtraTrace(n1.e), u1.throwLater(n1.e));
                                                }
                                            } else t1._resultCancelled(this);
                                        }
                                    }, e1.prototype._invokeOnCancel = function() {
                                        var t1 = this._onCancel();
                                        this._unsetOnCancel(), u1.invoke(this._doInvokeOnCancel, this, t1);
                                    }, e1.prototype._invokeInternalOnCancel = function() {
                                        this._isCancellable() && (this._doInvokeOnCancel(this._onCancel(), !0), this._unsetOnCancel());
                                    }, e1.prototype._resultCancelled = function() {
                                        this.cancel();
                                    };
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        7: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1) {
                                    var r1 = t1("./util"), n1 = t1("./es5").keys, o1 = r1.tryCatch, i1 = r1.errorObj;
                                    return function(t1, s1, a1) {
                                        return function(u1) {
                                            var c1 = a1._boundValue();
                                            t: for(var l1 = 0; l1 < t1.length; ++l1){
                                                var f1 = t1[l1];
                                                if (f1 === Error || null != f1 && f1.prototype instanceof Error) {
                                                    if (u1 instanceof f1) return o1(s1).call(c1, u1);
                                                } else if ("function" == typeof f1) {
                                                    var p1 = o1(f1).call(c1, u1);
                                                    if (p1 === i1) return p1;
                                                    if (p1) return o1(s1).call(c1, u1);
                                                } else if (r1.isObject(u1)) {
                                                    for(var h1 = n1(f1), y1 = 0; y1 < h1.length; ++y1){
                                                        var d1 = h1[y1];
                                                        if (f1[d1] != u1[d1]) continue t;
                                                    }
                                                    return o1(s1).call(c1, u1);
                                                }
                                            }
                                            return e1;
                                        };
                                    };
                                };
                            },
                            {
                                "./es5": 13,
                                "./util": 36
                            }
                        ],
                        8: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(t1) {
                                    var e1 = !1, r1 = [];
                                    function n1() {
                                        this._trace = new n1.CapturedTrace(o1());
                                    }
                                    function o1() {
                                        var t1 = r1.length - 1;
                                        if (t1 >= 0) return r1[t1];
                                    }
                                    return t1.prototype._promiseCreated = function() {}, t1.prototype._pushContext = function() {}, t1.prototype._popContext = function() {
                                        return null;
                                    }, t1._peekContext = t1.prototype._peekContext = function() {}, n1.prototype._pushContext = function() {
                                        void 0 !== this._trace && (this._trace._promiseCreated = null, r1.push(this._trace));
                                    }, n1.prototype._popContext = function() {
                                        if (void 0 !== this._trace) {
                                            var t1 = r1.pop(), e1 = t1._promiseCreated;
                                            return t1._promiseCreated = null, e1;
                                        }
                                        return null;
                                    }, n1.CapturedTrace = null, n1.create = function() {
                                        if (e1) return new n1;
                                    }, n1.deactivateLongStackTraces = function() {}, n1.activateLongStackTraces = function() {
                                        var r1 = t1.prototype._pushContext, i1 = t1.prototype._popContext, s1 = t1._peekContext, a1 = t1.prototype._peekContext, u1 = t1.prototype._promiseCreated;
                                        n1.deactivateLongStackTraces = function() {
                                            t1.prototype._pushContext = r1, t1.prototype._popContext = i1, t1._peekContext = s1, t1.prototype._peekContext = a1, t1.prototype._promiseCreated = u1, e1 = !1;
                                        }, e1 = !0, t1.prototype._pushContext = n1.prototype._pushContext, t1.prototype._popContext = n1.prototype._popContext, t1._peekContext = t1.prototype._peekContext = o1, t1.prototype._promiseCreated = function() {
                                            var t1 = this._peekContext();
                                            t1 && null == t1._promiseCreated && (t1._promiseCreated = this);
                                        };
                                    }, n1;
                                };
                            },
                            {}
                        ],
                        9: [
                            function(t1, e1, n1) {
                                "use strict";
                                e1.exports = function(e1, n1) {
                                    var o1, i1, s1, a1 = e1._getDomain, u1 = e1._async, l1 = t1("./errors").Warning, f1 = t1("./util"), p1 = f1.canAttachTrace, h1 = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/, y1 = /\((?:timers\.js):\d+:\d+\)/, d1 = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/, m1 = null, _1 = null, v1 = !1, g1 = !(0 == f1.env("BLUEBIRD_DEBUG")), b1 = !(0 == f1.env("BLUEBIRD_WARNINGS") || !g1 && !f1.env("BLUEBIRD_WARNINGS")), w1 = !(0 == f1.env("BLUEBIRD_LONG_STACK_TRACES") || !g1 && !f1.env("BLUEBIRD_LONG_STACK_TRACES")), O1 = 0 != f1.env("BLUEBIRD_W_FORGOTTEN_RETURN") && (b1 || !!f1.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
                                    e1.prototype.suppressUnhandledRejections = function() {
                                        var t1 = this._target();
                                        t1._bitField = -1048577 & t1._bitField | 524288;
                                    }, e1.prototype._ensurePossibleRejectionHandled = function() {
                                        if (0 == (524288 & this._bitField)) {
                                            this._setRejectionIsUnhandled();
                                            var t1 = this;
                                            setTimeout(function() {
                                                t1._notifyUnhandledRejection();
                                            }, 1);
                                        }
                                    }, e1.prototype._notifyUnhandledRejectionIsHandled = function() {
                                        W1("rejectionHandled", o1, void 0, this);
                                    }, e1.prototype._setReturnedNonUndefined = function() {
                                        this._bitField = 268435456 | this._bitField;
                                    }, e1.prototype._returnedNonUndefined = function() {
                                        return 0 != (268435456 & this._bitField);
                                    }, e1.prototype._notifyUnhandledRejection = function() {
                                        if (this._isRejectionUnhandled()) {
                                            var t1 = this._settledValue();
                                            this._setUnhandledRejectionIsNotified(), W1("unhandledRejection", i1, t1, this);
                                        }
                                    }, e1.prototype._setUnhandledRejectionIsNotified = function() {
                                        this._bitField = 262144 | this._bitField;
                                    }, e1.prototype._unsetUnhandledRejectionIsNotified = function() {
                                        this._bitField = -262145 & this._bitField;
                                    }, e1.prototype._isUnhandledRejectionNotified = function() {
                                        return (262144 & this._bitField) > 0;
                                    }, e1.prototype._setRejectionIsUnhandled = function() {
                                        this._bitField = 1048576 | this._bitField;
                                    }, e1.prototype._unsetRejectionIsUnhandled = function() {
                                        this._bitField = -1048577 & this._bitField, this._isUnhandledRejectionNotified() && (this._unsetUnhandledRejectionIsNotified(), this._notifyUnhandledRejectionIsHandled());
                                    }, e1.prototype._isRejectionUnhandled = function() {
                                        return (1048576 & this._bitField) > 0;
                                    }, e1.prototype._warn = function(t1, e1, r1) {
                                        return L1(t1, e1, r1 || this);
                                    }, e1.onPossiblyUnhandledRejection = function(t1) {
                                        var e1 = a1();
                                        i1 = "function" == typeof t1 ? null === e1 ? t1 : f1.domainBind(e1, t1) : void 0;
                                    }, e1.onUnhandledRejectionHandled = function(t1) {
                                        var e1 = a1();
                                        o1 = "function" == typeof t1 ? null === e1 ? t1 : f1.domainBind(e1, t1) : void 0;
                                    };
                                    var S1 = function() {};
                                    e1.longStackTraces = function() {
                                        if (u1.haveItemsQueued() && !X1.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
                                        if (!X1.longStackTraces && Y1()) {
                                            var t1 = e1.prototype._captureStackTrace, r1 = e1.prototype._attachExtraTrace;
                                            X1.longStackTraces = !0, S1 = function() {
                                                if (u1.haveItemsQueued() && !X1.longStackTraces) throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
                                                e1.prototype._captureStackTrace = t1, e1.prototype._attachExtraTrace = r1, n1.deactivateLongStackTraces(), u1.enableTrampoline(), X1.longStackTraces = !1;
                                            }, e1.prototype._captureStackTrace = I1, e1.prototype._attachExtraTrace = F1, n1.activateLongStackTraces(), u1.disableTrampolineIfNecessary();
                                        }
                                    }, e1.hasLongStackTraces = function() {
                                        return X1.longStackTraces && Y1();
                                    };
                                    var A1 = function() {
                                        try {
                                            if ("function" == typeof CustomEvent) {
                                                var t1 = new CustomEvent("CustomEvent");
                                                return f1.global.dispatchEvent(t1), function(t1, e1) {
                                                    var r1 = new CustomEvent(t1.toLowerCase(), {
                                                        detail: e1,
                                                        cancelable: !0
                                                    });
                                                    return !f1.global.dispatchEvent(r1);
                                                };
                                            }
                                            return "function" == typeof Event ? (t1 = new Event("CustomEvent"), f1.global.dispatchEvent(t1), function(t1, e1) {
                                                var r1 = new Event(t1.toLowerCase(), {
                                                    cancelable: !0
                                                });
                                                return r1.detail = e1, !f1.global.dispatchEvent(r1);
                                            }) : ((t1 = document.createEvent("CustomEvent")).initCustomEvent("testingtheevent", !1, !0, {}), f1.global.dispatchEvent(t1), function(t1, e1) {
                                                var r1 = document.createEvent("CustomEvent");
                                                return r1.initCustomEvent(t1.toLowerCase(), !1, !0, e1), !f1.global.dispatchEvent(r1);
                                            });
                                        } catch (t1) {}
                                        return function() {
                                            return !1;
                                        };
                                    }(), j1 = f1.isNode ? function() {
                                        return r1.emit.apply(r1, arguments);
                                    } : f1.global ? function(t1) {
                                        var e1 = "on" + t1.toLowerCase(), r1 = f1.global[e1];
                                        return !!r1 && (r1.apply(f1.global, [].slice.call(arguments, 1)), !0);
                                    } : function() {
                                        return !1;
                                    };
                                    function E1(t1, e1) {
                                        return {
                                            promise: e1
                                        };
                                    }
                                    var $1 = {
                                        promiseCreated: E1,
                                        promiseFulfilled: E1,
                                        promiseRejected: E1,
                                        promiseResolved: E1,
                                        promiseCancelled: E1,
                                        promiseChained: function(t1, e1, r1) {
                                            return {
                                                promise: e1,
                                                child: r1
                                            };
                                        },
                                        warning: function(t1, e1) {
                                            return {
                                                warning: e1
                                            };
                                        },
                                        unhandledRejection: function(t1, e1, r1) {
                                            return {
                                                reason: e1,
                                                promise: r1
                                            };
                                        },
                                        rejectionHandled: E1
                                    }, P1 = function(t1) {
                                        var e1 = !1;
                                        try {
                                            e1 = j1.apply(null, arguments);
                                        } catch (t1) {
                                            u1.throwLater(t1), e1 = !0;
                                        }
                                        var r1 = !1;
                                        try {
                                            r1 = A1(t1, $1[t1].apply(null, arguments));
                                        } catch (t1) {
                                            u1.throwLater(t1), r1 = !0;
                                        }
                                        return r1 || e1;
                                    };
                                    function x1() {
                                        return !1;
                                    }
                                    function N1(t1, e1, r1) {
                                        var n1 = this;
                                        try {
                                            t1(e1, r1, function(t1) {
                                                if ("function" != typeof t1) throw new TypeError("onCancel must be a function, got: " + f1.toString(t1));
                                                n1._attachCancellationCallback(t1);
                                            });
                                        } catch (t1) {
                                            return t1;
                                        }
                                    }
                                    function T1(t1) {
                                        if (!this._isCancellable()) return this;
                                        var e1 = this._onCancel();
                                        void 0 !== e1 ? f1.isArray(e1) ? e1.push(t1) : this._setOnCancel([
                                            e1,
                                            t1
                                        ]) : this._setOnCancel(t1);
                                    }
                                    function k1() {
                                        return this._onCancelField;
                                    }
                                    function C1(t1) {
                                        this._onCancelField = t1;
                                    }
                                    function D1() {
                                        this._cancellationParent = void 0, this._onCancelField = void 0;
                                    }
                                    function R1(t1, e1) {
                                        if (0 != (1 & e1)) {
                                            this._cancellationParent = t1;
                                            var r1 = t1._branchesRemainingToCancel;
                                            void 0 === r1 && (r1 = 0), t1._branchesRemainingToCancel = r1 + 1;
                                        }
                                        0 != (2 & e1) && t1._isBound() && this._setBoundTo(t1._boundTo);
                                    }
                                    e1.config = function(t1) {
                                        if ("longStackTraces" in (t1 = Object(t1)) && (t1.longStackTraces ? e1.longStackTraces() : !t1.longStackTraces && e1.hasLongStackTraces() && S1()), "warnings" in t1) {
                                            var r1 = t1.warnings;
                                            X1.warnings = !!r1, O1 = X1.warnings, f1.isObject(r1) && "wForgottenReturn" in r1 && (O1 = !!r1.wForgottenReturn);
                                        }
                                        if ("cancellation" in t1 && t1.cancellation && !X1.cancellation) {
                                            if (u1.haveItemsQueued()) throw new Error("cannot enable cancellation after promises are in use");
                                            e1.prototype._clearCancellationData = D1, e1.prototype._propagateFrom = R1, e1.prototype._onCancel = k1, e1.prototype._setOnCancel = C1, e1.prototype._attachCancellationCallback = T1, e1.prototype._execute = N1, B1 = R1, X1.cancellation = !0;
                                        }
                                        return "monitoring" in t1 && (t1.monitoring && !X1.monitoring ? (X1.monitoring = !0, e1.prototype._fireEvent = P1) : !t1.monitoring && X1.monitoring && (X1.monitoring = !1, e1.prototype._fireEvent = x1)), e1;
                                    }, e1.prototype._fireEvent = x1, e1.prototype._execute = function(t1, e1, r1) {
                                        try {
                                            t1(e1, r1);
                                        } catch (t1) {
                                            return t1;
                                        }
                                    }, e1.prototype._onCancel = function() {}, e1.prototype._setOnCancel = function(t1) {}, e1.prototype._attachCancellationCallback = function(t1) {}, e1.prototype._captureStackTrace = function() {}, e1.prototype._attachExtraTrace = function() {}, e1.prototype._clearCancellationData = function() {}, e1.prototype._propagateFrom = function(t1, e1) {};
                                    var B1 = function(t1, e1) {
                                        0 != (2 & e1) && t1._isBound() && this._setBoundTo(t1._boundTo);
                                    };
                                    function M1() {
                                        var t1 = this._boundTo;
                                        return void 0 !== t1 && t1 instanceof e1 ? t1.isFulfilled() ? t1.value() : void 0 : t1;
                                    }
                                    function I1() {
                                        this._trace = new J1(this._peekContext());
                                    }
                                    function F1(t1, e1) {
                                        if (p1(t1)) {
                                            var r1 = this._trace;
                                            if (void 0 !== r1 && e1 && (r1 = r1._parent), void 0 !== r1) r1.attachExtraTrace(t1);
                                            else if (!t1.__stackCleaned__) {
                                                var n1 = V1(t1);
                                                f1.notEnumerableProp(t1, "stack", n1.message + "\n" + n1.stack.join("\n")), f1.notEnumerableProp(t1, "__stackCleaned__", !0);
                                            }
                                        }
                                    }
                                    function L1(t1, r1, n1) {
                                        if (X1.warnings) {
                                            var o1, i1 = new l1(t1);
                                            if (r1) n1._attachExtraTrace(i1);
                                            else if (X1.longStackTraces && (o1 = e1._peekContext())) o1.attachExtraTrace(i1);
                                            else {
                                                var s1 = V1(i1);
                                                i1.stack = s1.message + "\n" + s1.stack.join("\n");
                                            }
                                            P1("warning", i1) || q1(i1, "", !0);
                                        }
                                    }
                                    function U1(t1) {
                                        for(var e1 = [], r1 = 0; r1 < t1.length; ++r1){
                                            var n1 = t1[r1], o1 = "    (No stack trace)" === n1 || m1.test(n1), i1 = o1 && K1(n1);
                                            o1 && !i1 && (v1 && " " !== n1.charAt(0) && (n1 = "    " + n1), e1.push(n1));
                                        }
                                        return e1;
                                    }
                                    function V1(t1) {
                                        var e1 = t1.stack, r1 = t1.toString();
                                        return e1 = "string" == typeof e1 && e1.length > 0 ? function(t1) {
                                            for(var e1 = t1.stack.replace(/\s+$/g, "").split("\n"), r1 = 0; r1 < e1.length; ++r1){
                                                var n1 = e1[r1];
                                                if ("    (No stack trace)" === n1 || m1.test(n1)) break;
                                            }
                                            return r1 > 0 && "SyntaxError" != t1.name && (e1 = e1.slice(r1)), e1;
                                        }(t1) : [
                                            "    (No stack trace)"
                                        ], {
                                            message: r1,
                                            stack: "SyntaxError" == t1.name ? e1 : U1(e1)
                                        };
                                    }
                                    function q1(t1, e1, r1) {
                                        if ("undefined" != typeof console) {
                                            var n1;
                                            if (f1.isObject(t1)) {
                                                var o1 = t1.stack;
                                                n1 = e1 + _1(o1, t1);
                                            } else n1 = e1 + String(t1);
                                            "function" == typeof s1 ? s1(n1, r1) : "function" != typeof console.log && "object" !== c1(console.log) || console.log(n1);
                                        }
                                    }
                                    function W1(t1, e1, r1, n1) {
                                        var o1 = !1;
                                        try {
                                            "function" == typeof e1 && (o1 = !0, "rejectionHandled" === t1 ? e1(n1) : e1(r1, n1));
                                        } catch (t1) {
                                            u1.throwLater(t1);
                                        }
                                        "unhandledRejection" === t1 ? P1(t1, r1, n1) || o1 || q1(r1, "Unhandled rejection ") : P1(t1, n1);
                                    }
                                    function H1(t1) {
                                        var e1;
                                        if ("function" == typeof t1) e1 = "[function " + (t1.name || "anonymous") + "]";
                                        else {
                                            if (e1 = t1 && "function" == typeof t1.toString ? t1.toString() : f1.toString(t1), /\[object [a-zA-Z0-9$_]+\]/.test(e1)) try {
                                                e1 = JSON.stringify(t1);
                                            } catch (t1) {}
                                            0 === e1.length && (e1 = "(empty array)");
                                        }
                                        return "(<" + function(t1) {
                                            return t1.length < 41 ? t1 : t1.substr(0, 38) + "...";
                                        }(e1) + ">, no stack trace)";
                                    }
                                    function Y1() {
                                        return "function" == typeof G1;
                                    }
                                    var K1 = function() {
                                        return !1;
                                    }, z1 = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
                                    function Q1(t1) {
                                        var e1 = t1.match(z1);
                                        if (e1) return {
                                            fileName: e1[1],
                                            line: parseInt(e1[2], 10)
                                        };
                                    }
                                    function J1(t1) {
                                        this._parent = t1, this._promisesCreated = 0;
                                        var e1 = this._length = 1 + (void 0 === t1 ? 0 : t1._length);
                                        G1(this, J1), e1 > 32 && this.uncycle();
                                    }
                                    f1.inherits(J1, Error), n1.CapturedTrace = J1, J1.prototype.uncycle = function() {
                                        var t1 = this._length;
                                        if (!(t1 < 2)) {
                                            for(var e1 = [], r1 = {}, n1 = 0, o1 = this; void 0 !== o1; ++n1)e1.push(o1), o1 = o1._parent;
                                            for(n1 = (t1 = this._length = n1) - 1; n1 >= 0; --n1){
                                                var i1 = e1[n1].stack;
                                                void 0 === r1[i1] && (r1[i1] = n1);
                                            }
                                            for(n1 = 0; n1 < t1; ++n1){
                                                var s1 = r1[e1[n1].stack];
                                                if (void 0 !== s1 && s1 !== n1) {
                                                    s1 > 0 && (e1[s1 - 1]._parent = void 0, e1[s1 - 1]._length = 1), e1[n1]._parent = void 0, e1[n1]._length = 1;
                                                    var a1 = n1 > 0 ? e1[n1 - 1] : this;
                                                    s1 < t1 - 1 ? (a1._parent = e1[s1 + 1], a1._parent.uncycle(), a1._length = a1._parent._length + 1) : (a1._parent = void 0, a1._length = 1);
                                                    for(var u1 = a1._length + 1, c1 = n1 - 2; c1 >= 0; --c1)e1[c1]._length = u1, u1++;
                                                    return;
                                                }
                                            }
                                        }
                                    }, J1.prototype.attachExtraTrace = function(t1) {
                                        if (!t1.__stackCleaned__) {
                                            this.uncycle();
                                            for(var e1 = V1(t1), r1 = e1.message, n1 = [
                                                e1.stack
                                            ], o1 = this; void 0 !== o1;)n1.push(U1(o1.stack.split("\n"))), o1 = o1._parent;
                                            !function(t1) {
                                                for(var e1 = t1[0], r1 = 1; r1 < t1.length; ++r1){
                                                    for(var n1 = t1[r1], o1 = e1.length - 1, i1 = e1[o1], s1 = -1, a1 = n1.length - 1; a1 >= 0; --a1)if (n1[a1] === i1) {
                                                        s1 = a1;
                                                        break;
                                                    }
                                                    for(a1 = s1; a1 >= 0; --a1){
                                                        var u1 = n1[a1];
                                                        if (e1[o1] !== u1) break;
                                                        e1.pop(), o1--;
                                                    }
                                                    e1 = n1;
                                                }
                                            }(n1), function(t1) {
                                                for(var e1 = 0; e1 < t1.length; ++e1)(0 === t1[e1].length || e1 + 1 < t1.length && t1[e1][0] === t1[e1 + 1][0]) && (t1.splice(e1, 1), e1--);
                                            }(n1), f1.notEnumerableProp(t1, "stack", function(t1, e1) {
                                                for(var r1 = 0; r1 < e1.length - 1; ++r1)e1[r1].push("From previous event:"), e1[r1] = e1[r1].join("\n");
                                                return r1 < e1.length && (e1[r1] = e1[r1].join("\n")), t1 + "\n" + e1.join("\n");
                                            }(r1, n1)), f1.notEnumerableProp(t1, "__stackCleaned__", !0);
                                        }
                                    };
                                    var G1 = function() {
                                        var t1 = /^\s*at\s*/, e1 = function(t1, e1) {
                                            return "string" == typeof t1 ? t1 : void 0 !== e1.name && void 0 !== e1.message ? e1.toString() : H1(e1);
                                        };
                                        if ("number" == typeof Error.stackTraceLimit && "function" == typeof Error.captureStackTrace) {
                                            Error.stackTraceLimit += 6, m1 = t1, _1 = e1;
                                            var r1 = Error.captureStackTrace;
                                            return K1 = function(t1) {
                                                return h1.test(t1);
                                            }, function(t1, e1) {
                                                Error.stackTraceLimit += 6, r1(t1, e1), Error.stackTraceLimit -= 6;
                                            };
                                        }
                                        var n1, o1 = new Error;
                                        if ("string" == typeof o1.stack && o1.stack.split("\n")[0].indexOf("stackDetection@") >= 0) return m1 = /@/, _1 = e1, v1 = !0, function(t1) {
                                            t1.stack = (new Error).stack;
                                        };
                                        try {
                                            throw new Error;
                                        } catch (t1) {
                                            n1 = "stack" in t1;
                                        }
                                        return !("stack" in o1) && n1 && "number" == typeof Error.stackTraceLimit ? (m1 = t1, _1 = e1, function(t1) {
                                            Error.stackTraceLimit += 6;
                                            try {
                                                throw new Error;
                                            } catch (e1) {
                                                t1.stack = e1.stack;
                                            }
                                            Error.stackTraceLimit -= 6;
                                        }) : (_1 = function(t1, e1) {
                                            return "string" == typeof t1 ? t1 : "object" !== c1(e1) && "function" != typeof e1 || void 0 === e1.name || void 0 === e1.message ? H1(e1) : e1.toString();
                                        }, null);
                                    }();
                                    "undefined" != typeof console && void 0 !== console.warn && (s1 = function(t1) {
                                        console.warn(t1);
                                    }, f1.isNode && r1.stderr.isTTY ? s1 = function(t1, e1) {
                                        var r1 = e1 ? "\x1b[33m" : "\x1b[31m";
                                        console.warn(r1 + t1 + "\x1b[0m\n");
                                    } : f1.isNode || "string" != typeof (new Error).stack || (s1 = function(t1, e1) {
                                        console.warn("%c" + t1, e1 ? "color: darkorange" : "color: red");
                                    }));
                                    var X1 = {
                                        warnings: b1,
                                        longStackTraces: !1,
                                        cancellation: !1,
                                        monitoring: !1
                                    };
                                    return w1 && e1.longStackTraces(), {
                                        longStackTraces: function() {
                                            return X1.longStackTraces;
                                        },
                                        warnings: function() {
                                            return X1.warnings;
                                        },
                                        cancellation: function() {
                                            return X1.cancellation;
                                        },
                                        monitoring: function() {
                                            return X1.monitoring;
                                        },
                                        propagateFromFunction: function() {
                                            return B1;
                                        },
                                        boundValueFunction: function() {
                                            return M1;
                                        },
                                        checkForgottenReturns: function(t1, e1, r1, n1, o1) {
                                            if (void 0 === t1 && null !== e1 && O1) {
                                                if (void 0 !== o1 && o1._returnedNonUndefined()) return;
                                                if (0 == (65535 & n1._bitField)) return;
                                                r1 && (r1 += " ");
                                                var i1 = "", s1 = "";
                                                if (e1._trace) {
                                                    for(var a1 = e1._trace.stack.split("\n"), u1 = U1(a1), c1 = u1.length - 1; c1 >= 0; --c1){
                                                        var l1 = u1[c1];
                                                        if (!y1.test(l1)) {
                                                            var f1 = l1.match(d1);
                                                            f1 && (i1 = "at " + f1[1] + ":" + f1[2] + ":" + f1[3] + " ");
                                                            break;
                                                        }
                                                    }
                                                    if (u1.length > 0) {
                                                        var p1 = u1[0];
                                                        for(c1 = 0; c1 < a1.length; ++c1)if (a1[c1] === p1) {
                                                            c1 > 0 && (s1 = "\n" + a1[c1 - 1]);
                                                            break;
                                                        }
                                                    }
                                                }
                                                var h1 = "a promise was created in a " + r1 + "handler " + i1 + "but was not returned from it, see http://goo.gl/rRqMUw" + s1;
                                                n1._warn(h1, !0, e1);
                                            }
                                        },
                                        setBounds: function(t1, e1) {
                                            if (Y1()) {
                                                for(var r1, n1, o1 = t1.stack.split("\n"), i1 = e1.stack.split("\n"), s1 = -1, a1 = -1, u1 = 0; u1 < o1.length; ++u1)if (c1 = Q1(o1[u1])) {
                                                    r1 = c1.fileName, s1 = c1.line;
                                                    break;
                                                }
                                                for(u1 = 0; u1 < i1.length; ++u1){
                                                    var c1;
                                                    if (c1 = Q1(i1[u1])) {
                                                        n1 = c1.fileName, a1 = c1.line;
                                                        break;
                                                    }
                                                }
                                                s1 < 0 || a1 < 0 || !r1 || !n1 || r1 !== n1 || s1 >= a1 || (K1 = function(t1) {
                                                    if (h1.test(t1)) return !0;
                                                    var e1 = Q1(t1);
                                                    return !!(e1 && e1.fileName === r1 && s1 <= e1.line && e1.line <= a1);
                                                });
                                            }
                                        },
                                        warn: L1,
                                        deprecated: function(t1, e1) {
                                            var r1 = t1 + " is deprecated and will be removed in a future version.";
                                            return e1 && (r1 += " Use " + e1 + " instead."), L1(r1);
                                        },
                                        CapturedTrace: J1,
                                        fireDomEvent: A1,
                                        fireGlobalEvent: j1
                                    };
                                };
                            },
                            {
                                "./errors": 12,
                                "./util": 36
                            }
                        ],
                        10: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(t1) {
                                    function e1() {
                                        return this.value;
                                    }
                                    function r1() {
                                        throw this.reason;
                                    }
                                    t1.prototype.return = t1.prototype.thenReturn = function(r1) {
                                        return r1 instanceof t1 && r1.suppressUnhandledRejections(), this._then(e1, void 0, void 0, {
                                            value: r1
                                        }, void 0);
                                    }, t1.prototype.throw = t1.prototype.thenThrow = function(t1) {
                                        return this._then(r1, void 0, void 0, {
                                            reason: t1
                                        }, void 0);
                                    }, t1.prototype.catchThrow = function(t1) {
                                        if (arguments.length <= 1) return this._then(void 0, r1, void 0, {
                                            reason: t1
                                        }, void 0);
                                        var e1 = arguments[1], n1 = function() {
                                            throw e1;
                                        };
                                        return this.caught(t1, n1);
                                    }, t1.prototype.catchReturn = function(r1) {
                                        if (arguments.length <= 1) return r1 instanceof t1 && r1.suppressUnhandledRejections(), this._then(void 0, e1, void 0, {
                                            value: r1
                                        }, void 0);
                                        var n1 = arguments[1];
                                        n1 instanceof t1 && n1.suppressUnhandledRejections();
                                        var o1 = function() {
                                            return n1;
                                        };
                                        return this.caught(r1, o1);
                                    };
                                };
                            },
                            {}
                        ],
                        11: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(t1, e1) {
                                    var r1 = t1.reduce, n1 = t1.all;
                                    function o1() {
                                        return n1(this);
                                    }
                                    t1.prototype.each = function(t1) {
                                        return r1(this, t1, e1, 0)._then(o1, void 0, void 0, this, void 0);
                                    }, t1.prototype.mapSeries = function(t1) {
                                        return r1(this, t1, e1, e1);
                                    }, t1.each = function(t1, n1) {
                                        return r1(t1, n1, e1, 0)._then(o1, void 0, void 0, t1, void 0);
                                    }, t1.mapSeries = function(t1, n1) {
                                        return r1(t1, n1, e1, e1);
                                    };
                                };
                            },
                            {}
                        ],
                        12: [
                            function(t1, e1, r1) {
                                "use strict";
                                var n1, o1, i1 = t1("./es5"), s1 = i1.freeze, a1 = t1("./util"), u1 = a1.inherits, c1 = a1.notEnumerableProp;
                                function l1(t1, e1) {
                                    function r1(n1) {
                                        if (!(this instanceof r1)) return new r1(n1);
                                        c1(this, "message", "string" == typeof n1 ? n1 : e1), c1(this, "name", t1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : Error.call(this);
                                    }
                                    return u1(r1, Error), r1;
                                }
                                var f1 = l1("Warning", "warning"), p1 = l1("CancellationError", "cancellation error"), h1 = l1("TimeoutError", "timeout error"), y1 = l1("AggregateError", "aggregate error");
                                try {
                                    n1 = TypeError, o1 = RangeError;
                                } catch (t1) {
                                    n1 = l1("TypeError", "type error"), o1 = l1("RangeError", "range error");
                                }
                                for(var d1 = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" "), m1 = 0; m1 < d1.length; ++m1)"function" == typeof Array.prototype[d1[m1]] && (y1.prototype[d1[m1]] = Array.prototype[d1[m1]]);
                                i1.defineProperty(y1.prototype, "length", {
                                    value: 0,
                                    configurable: !1,
                                    writable: !0,
                                    enumerable: !0
                                }), y1.prototype.isOperational = !0;
                                var _1 = 0;
                                function v1(t1) {
                                    if (!(this instanceof v1)) return new v1(t1);
                                    c1(this, "name", "OperationalError"), c1(this, "message", t1), this.cause = t1, this.isOperational = !0, t1 instanceof Error ? (c1(this, "message", t1.message), c1(this, "stack", t1.stack)) : Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
                                }
                                y1.prototype.toString = function() {
                                    var t1 = Array(4 * _1 + 1).join(" "), e1 = "\n" + t1 + "AggregateError of:\n";
                                    _1++, t1 = Array(4 * _1 + 1).join(" ");
                                    for(var r1 = 0; r1 < this.length; ++r1){
                                        for(var n1 = this[r1] === this ? "[Circular AggregateError]" : this[r1] + "", o1 = n1.split("\n"), i1 = 0; i1 < o1.length; ++i1)o1[i1] = t1 + o1[i1];
                                        e1 += (n1 = o1.join("\n")) + "\n";
                                    }
                                    return _1--, e1;
                                }, u1(v1, Error);
                                var g1 = Error.__BluebirdErrorTypes__;
                                g1 || (g1 = s1({
                                    CancellationError: p1,
                                    TimeoutError: h1,
                                    OperationalError: v1,
                                    RejectionError: v1,
                                    AggregateError: y1
                                }), i1.defineProperty(Error, "__BluebirdErrorTypes__", {
                                    value: g1,
                                    writable: !1,
                                    enumerable: !1,
                                    configurable: !1
                                })), e1.exports = {
                                    Error: Error,
                                    TypeError: n1,
                                    RangeError: o1,
                                    CancellationError: g1.CancellationError,
                                    OperationalError: g1.OperationalError,
                                    TimeoutError: g1.TimeoutError,
                                    AggregateError: g1.AggregateError,
                                    Warning: f1
                                };
                            },
                            {
                                "./es5": 13,
                                "./util": 36
                            }
                        ],
                        13: [
                            function(t1, e1, r1) {
                                var n1 = function() {
                                    "use strict";
                                    return void 0 === this;
                                }();
                                if (n1) e1.exports = {
                                    freeze: Object.freeze,
                                    defineProperty: Object.defineProperty,
                                    getDescriptor: Object.getOwnPropertyDescriptor,
                                    keys: Object.keys,
                                    names: Object.getOwnPropertyNames,
                                    getPrototypeOf: Object.getPrototypeOf,
                                    isArray: Array.isArray,
                                    isES5: n1,
                                    propertyIsWritable: function(t1, e1) {
                                        var r1 = Object.getOwnPropertyDescriptor(t1, e1);
                                        return !(r1 && !r1.writable && !r1.set);
                                    }
                                };
                                else {
                                    var o1 = {}.hasOwnProperty, i1 = {}.toString, s1 = {}.constructor.prototype, a1 = function(t1) {
                                        var e1 = [];
                                        for(var r1 in t1)o1.call(t1, r1) && e1.push(r1);
                                        return e1;
                                    };
                                    e1.exports = {
                                        isArray: function(t1) {
                                            try {
                                                return "[object Array]" === i1.call(t1);
                                            } catch (t1) {
                                                return !1;
                                            }
                                        },
                                        keys: a1,
                                        names: a1,
                                        defineProperty: function(t1, e1, r1) {
                                            return t1[e1] = r1.value, t1;
                                        },
                                        getDescriptor: function(t1, e1) {
                                            return {
                                                value: t1[e1]
                                            };
                                        },
                                        freeze: function(t1) {
                                            return t1;
                                        },
                                        getPrototypeOf: function(t1) {
                                            try {
                                                return Object(t1).constructor.prototype;
                                            } catch (t1) {
                                                return s1;
                                            }
                                        },
                                        isES5: n1,
                                        propertyIsWritable: function() {
                                            return !0;
                                        }
                                    };
                                }
                            },
                            {}
                        ],
                        14: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(t1, e1) {
                                    var r1 = t1.map;
                                    t1.prototype.filter = function(t1, n1) {
                                        return r1(this, t1, n1, e1);
                                    }, t1.filter = function(t1, n1, o1) {
                                        return r1(t1, n1, o1, e1);
                                    };
                                };
                            },
                            {}
                        ],
                        15: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1) {
                                    var o1 = t1("./util"), i1 = e1.CancellationError, s1 = o1.errorObj, a1 = t1("./catch_filter")(n1);
                                    function u1(t1, e1, r1) {
                                        this.promise = t1, this.type = e1, this.handler = r1, this.called = !1, this.cancelPromise = null;
                                    }
                                    function c1(t1) {
                                        this.finallyHandler = t1;
                                    }
                                    function l1(t1, e1) {
                                        return null != t1.cancelPromise && (arguments.length > 1 ? t1.cancelPromise._reject(e1) : t1.cancelPromise._cancel(), t1.cancelPromise = null, !0);
                                    }
                                    function f1() {
                                        return h1.call(this, this.promise._target()._settledValue());
                                    }
                                    function p1(t1) {
                                        if (!l1(this, t1)) return s1.e = t1, s1;
                                    }
                                    function h1(t1) {
                                        var o1 = this.promise, a1 = this.handler;
                                        if (!this.called) {
                                            this.called = !0;
                                            var u1 = this.isFinallyHandler() ? a1.call(o1._boundValue()) : a1.call(o1._boundValue(), t1);
                                            if (u1 === n1) return u1;
                                            if (void 0 !== u1) {
                                                o1._setReturnedNonUndefined();
                                                var h1 = r1(u1, o1);
                                                if (h1 instanceof e1) {
                                                    if (null != this.cancelPromise) {
                                                        if (h1._isCancelled()) {
                                                            var y1 = new i1("late cancellation observer");
                                                            return o1._attachExtraTrace(y1), s1.e = y1, s1;
                                                        }
                                                        h1.isPending() && h1._attachCancellationCallback(new c1(this));
                                                    }
                                                    return h1._then(f1, p1, void 0, this, void 0);
                                                }
                                            }
                                        }
                                        return o1.isRejected() ? (l1(this), s1.e = t1, s1) : (l1(this), t1);
                                    }
                                    return u1.prototype.isFinallyHandler = function() {
                                        return 0 === this.type;
                                    }, c1.prototype._resultCancelled = function() {
                                        l1(this.finallyHandler);
                                    }, e1.prototype._passThrough = function(t1, e1, r1, n1) {
                                        return "function" != typeof t1 ? this.then() : this._then(r1, n1, void 0, new u1(this, e1, t1), void 0);
                                    }, e1.prototype.lastly = e1.prototype.finally = function(t1) {
                                        return this._passThrough(t1, 0, h1, h1);
                                    }, e1.prototype.tap = function(t1) {
                                        return this._passThrough(t1, 1, h1);
                                    }, e1.prototype.tapCatch = function(t1) {
                                        var r1 = arguments.length;
                                        if (1 === r1) return this._passThrough(t1, 1, void 0, h1);
                                        var n1, i1 = new Array(r1 - 1), s1 = 0;
                                        for(n1 = 0; n1 < r1 - 1; ++n1){
                                            var u1 = arguments[n1];
                                            if (!o1.isObject(u1)) return e1.reject(new TypeError("tapCatch statement predicate: expecting an object but got " + o1.classString(u1)));
                                            i1[s1++] = u1;
                                        }
                                        i1.length = s1;
                                        var c1 = arguments[n1];
                                        return this._passThrough(a1(i1, c1, this), 1, void 0, h1);
                                    }, u1;
                                };
                            },
                            {
                                "./catch_filter": 7,
                                "./util": 36
                            }
                        ],
                        16: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1, o1, i1, s1) {
                                    var a1 = t1("./errors").TypeError, u1 = t1("./util"), c1 = u1.errorObj, l1 = u1.tryCatch, f1 = [];
                                    function p1(t1, r1, o1, i1) {
                                        if (s1.cancellation()) {
                                            var a1 = new e1(n1), u1 = this._finallyPromise = new e1(n1);
                                            this._promise = a1.lastly(function() {
                                                return u1;
                                            }), a1._captureStackTrace(), a1._setOnCancel(this);
                                        } else (this._promise = new e1(n1))._captureStackTrace();
                                        this._stack = i1, this._generatorFunction = t1, this._receiver = r1, this._generator = void 0, this._yieldHandlers = "function" == typeof o1 ? [
                                            o1
                                        ].concat(f1) : f1, this._yieldedPromise = null, this._cancellationPhase = !1;
                                    }
                                    u1.inherits(p1, i1), p1.prototype._isResolved = function() {
                                        return null === this._promise;
                                    }, p1.prototype._cleanup = function() {
                                        this._promise = this._generator = null, s1.cancellation() && null !== this._finallyPromise && (this._finallyPromise._fulfill(), this._finallyPromise = null);
                                    }, p1.prototype._promiseCancelled = function() {
                                        if (!this._isResolved()) {
                                            var t1;
                                            if (void 0 !== this._generator.return) this._promise._pushContext(), t1 = l1(this._generator.return).call(this._generator, void 0), this._promise._popContext();
                                            else {
                                                var r1 = new e1.CancellationError("generator .return() sentinel");
                                                e1.coroutine.returnSentinel = r1, this._promise._attachExtraTrace(r1), this._promise._pushContext(), t1 = l1(this._generator.throw).call(this._generator, r1), this._promise._popContext();
                                            }
                                            this._cancellationPhase = !0, this._yieldedPromise = null, this._continue(t1);
                                        }
                                    }, p1.prototype._promiseFulfilled = function(t1) {
                                        this._yieldedPromise = null, this._promise._pushContext();
                                        var e1 = l1(this._generator.next).call(this._generator, t1);
                                        this._promise._popContext(), this._continue(e1);
                                    }, p1.prototype._promiseRejected = function(t1) {
                                        this._yieldedPromise = null, this._promise._attachExtraTrace(t1), this._promise._pushContext();
                                        var e1 = l1(this._generator.throw).call(this._generator, t1);
                                        this._promise._popContext(), this._continue(e1);
                                    }, p1.prototype._resultCancelled = function() {
                                        if (this._yieldedPromise instanceof e1) {
                                            var t1 = this._yieldedPromise;
                                            this._yieldedPromise = null, t1.cancel();
                                        }
                                    }, p1.prototype.promise = function() {
                                        return this._promise;
                                    }, p1.prototype._run = function() {
                                        this._generator = this._generatorFunction.call(this._receiver), this._receiver = this._generatorFunction = void 0, this._promiseFulfilled(void 0);
                                    }, p1.prototype._continue = function(t1) {
                                        var r1 = this._promise;
                                        if (t1 === c1) return this._cleanup(), this._cancellationPhase ? r1.cancel() : r1._rejectCallback(t1.e, !1);
                                        var n1 = t1.value;
                                        if (!0 === t1.done) return this._cleanup(), this._cancellationPhase ? r1.cancel() : r1._resolveCallback(n1);
                                        var i1 = o1(n1, this._promise);
                                        if (i1 instanceof e1 || null !== (i1 = function(t1, r1, n1) {
                                            for(var i1 = 0; i1 < r1.length; ++i1){
                                                n1._pushContext();
                                                var s1 = l1(r1[i1])(t1);
                                                if (n1._popContext(), s1 === c1) {
                                                    n1._pushContext();
                                                    var a1 = e1.reject(c1.e);
                                                    return n1._popContext(), a1;
                                                }
                                                var u1 = o1(s1, n1);
                                                if (u1 instanceof e1) return u1;
                                            }
                                            return null;
                                        }(i1, this._yieldHandlers, this._promise))) {
                                            var s1 = (i1 = i1._target())._bitField;
                                            0 == (50397184 & s1) ? (this._yieldedPromise = i1, i1._proxy(this, null)) : 0 != (33554432 & s1) ? e1._async.invoke(this._promiseFulfilled, this, i1._value()) : 0 != (16777216 & s1) ? e1._async.invoke(this._promiseRejected, this, i1._reason()) : this._promiseCancelled();
                                        } else this._promiseRejected(new a1("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", String(n1)) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")));
                                    }, e1.coroutine = function(t1, e1) {
                                        if ("function" != typeof t1) throw new a1("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
                                        var r1 = Object(e1).yieldHandler, n1 = p1, o1 = (new Error).stack;
                                        return function() {
                                            var e1 = t1.apply(this, arguments), i1 = new n1(void 0, void 0, r1, o1), s1 = i1.promise();
                                            return i1._generator = e1, i1._promiseFulfilled(void 0), s1;
                                        };
                                    }, e1.coroutine.addYieldHandler = function(t1) {
                                        if ("function" != typeof t1) throw new a1("expecting a function but got " + u1.classString(t1));
                                        f1.push(t1);
                                    }, e1.spawn = function(t1) {
                                        if (s1.deprecated("Promise.spawn()", "Promise.coroutine()"), "function" != typeof t1) return r1("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
                                        var n1 = new p1(t1, this), o1 = n1.promise();
                                        return n1._run(e1.spawn), o1;
                                    };
                                };
                            },
                            {
                                "./errors": 12,
                                "./util": 36
                            }
                        ],
                        17: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1, o1, i1, s1) {
                                    var a1 = t1("./util");
                                    a1.canEvaluate, a1.tryCatch, a1.errorObj, e1.join = function() {
                                        var t1, e1 = arguments.length - 1;
                                        e1 > 0 && "function" == typeof arguments[e1] && (t1 = arguments[e1]);
                                        var n1 = [].slice.call(arguments);
                                        t1 && n1.pop();
                                        var o1 = new r1(n1).promise();
                                        return void 0 !== t1 ? o1.spread(t1) : o1;
                                    };
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        18: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1, o1, i1, s1) {
                                    var a1 = e1._getDomain, u1 = t1("./util"), l1 = u1.tryCatch, f1 = u1.errorObj, p1 = e1._async;
                                    function h1(t1, e1, r1, n1) {
                                        this.constructor$(t1), this._promise._captureStackTrace();
                                        var o1 = a1();
                                        this._callback = null === o1 ? e1 : u1.domainBind(o1, e1), this._preservedValues = n1 === i1 ? new Array(this.length()) : null, this._limit = r1, this._inFlight = 0, this._queue = [], p1.invoke(this._asyncInit, this, void 0);
                                    }
                                    function y1(t1, r1, o1, i1) {
                                        if ("function" != typeof r1) return n1("expecting a function but got " + u1.classString(r1));
                                        var s1 = 0;
                                        if (void 0 !== o1) {
                                            if ("object" !== c1(o1) || null === o1) return e1.reject(new TypeError("options argument must be an object but it is " + u1.classString(o1)));
                                            if ("number" != typeof o1.concurrency) return e1.reject(new TypeError("'concurrency' must be a number but it is " + u1.classString(o1.concurrency)));
                                            s1 = o1.concurrency;
                                        }
                                        return new h1(t1, r1, s1 = "number" == typeof s1 && isFinite(s1) && s1 >= 1 ? s1 : 0, i1).promise();
                                    }
                                    u1.inherits(h1, r1), h1.prototype._asyncInit = function() {
                                        this._init$(void 0, -2);
                                    }, h1.prototype._init = function() {}, h1.prototype._promiseFulfilled = function(t1, r1) {
                                        var n1 = this._values, i1 = this.length(), a1 = this._preservedValues, u1 = this._limit;
                                        if (r1 < 0) {
                                            if (n1[r1 = -1 * r1 - 1] = t1, u1 >= 1 && (this._inFlight--, this._drainQueue(), this._isResolved())) return !0;
                                        } else {
                                            if (u1 >= 1 && this._inFlight >= u1) return n1[r1] = t1, this._queue.push(r1), !1;
                                            null !== a1 && (a1[r1] = t1);
                                            var c1 = this._promise, p1 = this._callback, h1 = c1._boundValue();
                                            c1._pushContext();
                                            var y1 = l1(p1).call(h1, t1, r1, i1), d1 = c1._popContext();
                                            if (s1.checkForgottenReturns(y1, d1, null !== a1 ? "Promise.filter" : "Promise.map", c1), y1 === f1) return this._reject(y1.e), !0;
                                            var m1 = o1(y1, this._promise);
                                            if (m1 instanceof e1) {
                                                var _1 = (m1 = m1._target())._bitField;
                                                if (0 == (50397184 & _1)) return u1 >= 1 && this._inFlight++, n1[r1] = m1, m1._proxy(this, -1 * (r1 + 1)), !1;
                                                if (0 == (33554432 & _1)) return 0 != (16777216 & _1) ? (this._reject(m1._reason()), !0) : (this._cancel(), !0);
                                                y1 = m1._value();
                                            }
                                            n1[r1] = y1;
                                        }
                                        return ++this._totalResolved >= i1 && (null !== a1 ? this._filter(n1, a1) : this._resolve(n1), !0);
                                    }, h1.prototype._drainQueue = function() {
                                        for(var t1 = this._queue, e1 = this._limit, r1 = this._values; t1.length > 0 && this._inFlight < e1;){
                                            if (this._isResolved()) return;
                                            var n1 = t1.pop();
                                            this._promiseFulfilled(r1[n1], n1);
                                        }
                                    }, h1.prototype._filter = function(t1, e1) {
                                        for(var r1 = e1.length, n1 = new Array(r1), o1 = 0, i1 = 0; i1 < r1; ++i1)t1[i1] && (n1[o1++] = e1[i1]);
                                        n1.length = o1, this._resolve(n1);
                                    }, h1.prototype.preservedValues = function() {
                                        return this._preservedValues;
                                    }, e1.prototype.map = function(t1, e1) {
                                        return y1(this, t1, e1, null);
                                    }, e1.map = function(t1, e1, r1, n1) {
                                        return y1(t1, e1, r1, n1);
                                    };
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        19: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1, o1, i1) {
                                    var s1 = t1("./util"), a1 = s1.tryCatch;
                                    e1.method = function(t1) {
                                        if ("function" != typeof t1) throw new e1.TypeError("expecting a function but got " + s1.classString(t1));
                                        return function() {
                                            var n1 = new e1(r1);
                                            n1._captureStackTrace(), n1._pushContext();
                                            var o1 = a1(t1).apply(this, arguments), s1 = n1._popContext();
                                            return i1.checkForgottenReturns(o1, s1, "Promise.method", n1), n1._resolveFromSyncValue(o1), n1;
                                        };
                                    }, e1.attempt = e1.try = function(t1) {
                                        if ("function" != typeof t1) return o1("expecting a function but got " + s1.classString(t1));
                                        var n1, u1 = new e1(r1);
                                        if (u1._captureStackTrace(), u1._pushContext(), arguments.length > 1) {
                                            i1.deprecated("calling Promise.try with more than 1 argument");
                                            var c1 = arguments[1], l1 = arguments[2];
                                            n1 = s1.isArray(c1) ? a1(t1).apply(l1, c1) : a1(t1).call(l1, c1);
                                        } else n1 = a1(t1)();
                                        var f1 = u1._popContext();
                                        return i1.checkForgottenReturns(n1, f1, "Promise.try", u1), u1._resolveFromSyncValue(n1), u1;
                                    }, e1.prototype._resolveFromSyncValue = function(t1) {
                                        t1 === s1.errorObj ? this._rejectCallback(t1.e, !1) : this._resolveCallback(t1, !0);
                                    };
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        20: [
                            function(t1, e1, r1) {
                                "use strict";
                                var n1 = t1("./util"), o1 = n1.maybeWrapAsError, i1 = t1("./errors").OperationalError, s1 = t1("./es5"), a1 = /^(?:name|message|stack|cause)$/;
                                function u1(t1) {
                                    var e1;
                                    if (function(t1) {
                                        return t1 instanceof Error && s1.getPrototypeOf(t1) === Error.prototype;
                                    }(t1)) {
                                        (e1 = new i1(t1)).name = t1.name, e1.message = t1.message, e1.stack = t1.stack;
                                        for(var r1 = s1.keys(t1), o1 = 0; o1 < r1.length; ++o1){
                                            var u1 = r1[o1];
                                            a1.test(u1) || (e1[u1] = t1[u1]);
                                        }
                                        return e1;
                                    }
                                    return n1.markAsOriginatingFromRejection(t1), t1;
                                }
                                e1.exports = function(t1, e1) {
                                    return function(r1, n1) {
                                        if (null !== t1) {
                                            if (r1) {
                                                var i1 = u1(o1(r1));
                                                t1._attachExtraTrace(i1), t1._reject(i1);
                                            } else if (e1) {
                                                var s1 = [].slice.call(arguments, 1);
                                                t1._fulfill(s1);
                                            } else t1._fulfill(n1);
                                            t1 = null;
                                        }
                                    };
                                };
                            },
                            {
                                "./errors": 12,
                                "./es5": 13,
                                "./util": 36
                            }
                        ],
                        21: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1) {
                                    var r1 = t1("./util"), n1 = e1._async, o1 = r1.tryCatch, i1 = r1.errorObj;
                                    function s1(t1, e1) {
                                        if (!r1.isArray(t1)) return a1.call(this, t1, e1);
                                        var s1 = o1(e1).apply(this._boundValue(), [
                                            null
                                        ].concat(t1));
                                        s1 === i1 && n1.throwLater(s1.e);
                                    }
                                    function a1(t1, e1) {
                                        var r1 = this._boundValue(), s1 = void 0 === t1 ? o1(e1).call(r1, null) : o1(e1).call(r1, null, t1);
                                        s1 === i1 && n1.throwLater(s1.e);
                                    }
                                    function u1(t1, e1) {
                                        if (!t1) {
                                            var r1 = new Error(t1 + "");
                                            r1.cause = t1, t1 = r1;
                                        }
                                        var s1 = o1(e1).call(this._boundValue(), t1);
                                        s1 === i1 && n1.throwLater(s1.e);
                                    }
                                    e1.prototype.asCallback = e1.prototype.nodeify = function(t1, e1) {
                                        if ("function" == typeof t1) {
                                            var r1 = a1;
                                            void 0 !== e1 && Object(e1).spread && (r1 = s1), this._then(r1, u1, void 0, this, t1);
                                        }
                                        return this;
                                    };
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        22: [
                            function(t1, e1, n1) {
                                "use strict";
                                e1.exports = function() {
                                    var n1 = function() {
                                        return new y1("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
                                    }, o1 = function() {
                                        return new x1.PromiseInspection(this._target());
                                    }, i1 = function(t1) {
                                        return x1.reject(new y1(t1));
                                    };
                                    function s1() {}
                                    var a1, u1 = {}, c1 = t1("./util");
                                    a1 = c1.isNode ? function() {
                                        var t1 = r1.domain;
                                        return void 0 === t1 && (t1 = null), t1;
                                    } : function() {
                                        return null;
                                    }, c1.notEnumerableProp(x1, "_getDomain", a1);
                                    var l1 = t1("./es5"), f1 = t1("./async"), p1 = new f1;
                                    l1.defineProperty(x1, "_async", {
                                        value: p1
                                    });
                                    var h1 = t1("./errors"), y1 = x1.TypeError = h1.TypeError;
                                    x1.RangeError = h1.RangeError;
                                    var d1 = x1.CancellationError = h1.CancellationError;
                                    x1.TimeoutError = h1.TimeoutError, x1.OperationalError = h1.OperationalError, x1.RejectionError = h1.OperationalError, x1.AggregateError = h1.AggregateError;
                                    var m1 = function() {}, _1 = {}, v1 = {}, g1 = t1("./thenables")(x1, m1), b1 = t1("./promise_array")(x1, m1, g1, i1, s1), w1 = t1("./context")(x1), O1 = w1.create, S1 = t1("./debuggability")(x1, w1), A1 = (S1.CapturedTrace, t1("./finally")(x1, g1, v1)), j1 = t1("./catch_filter")(v1), E1 = t1("./nodeback"), $1 = c1.errorObj, P1 = c1.tryCatch;
                                    function x1(t1) {
                                        t1 !== m1 && function(t1, e1) {
                                            if (null == t1 || t1.constructor !== x1) throw new y1("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
                                            if ("function" != typeof e1) throw new y1("expecting a function but got " + c1.classString(e1));
                                        }(this, t1), this._bitField = 0, this._fulfillmentHandler0 = void 0, this._rejectionHandler0 = void 0, this._promise0 = void 0, this._receiver0 = void 0, this._resolveFromExecutor(t1), this._promiseCreated(), this._fireEvent("promiseCreated", this);
                                    }
                                    function N1(t1) {
                                        this.promise._resolveCallback(t1);
                                    }
                                    function T1(t1) {
                                        this.promise._rejectCallback(t1, !1);
                                    }
                                    function k1(t1) {
                                        var e1 = new x1(m1);
                                        e1._fulfillmentHandler0 = t1, e1._rejectionHandler0 = t1, e1._promise0 = t1, e1._receiver0 = t1;
                                    }
                                    return x1.prototype.toString = function() {
                                        return "[object Promise]";
                                    }, x1.prototype.caught = x1.prototype.catch = function(t1) {
                                        var e1 = arguments.length;
                                        if (e1 > 1) {
                                            var r1, n1 = new Array(e1 - 1), o1 = 0;
                                            for(r1 = 0; r1 < e1 - 1; ++r1){
                                                var s1 = arguments[r1];
                                                if (!c1.isObject(s1)) return i1("Catch statement predicate: expecting an object but got " + c1.classString(s1));
                                                n1[o1++] = s1;
                                            }
                                            return n1.length = o1, t1 = arguments[r1], this.then(void 0, j1(n1, t1, this));
                                        }
                                        return this.then(void 0, t1);
                                    }, x1.prototype.reflect = function() {
                                        return this._then(o1, o1, void 0, this, void 0);
                                    }, x1.prototype.then = function(t1, e1) {
                                        if (S1.warnings() && arguments.length > 0 && "function" != typeof t1 && "function" != typeof e1) {
                                            var r1 = ".then() only accepts functions but was passed: " + c1.classString(t1);
                                            arguments.length > 1 && (r1 += ", " + c1.classString(e1)), this._warn(r1);
                                        }
                                        return this._then(t1, e1, void 0, void 0, void 0);
                                    }, x1.prototype.done = function(t1, e1) {
                                        this._then(t1, e1, void 0, void 0, void 0)._setIsFinal();
                                    }, x1.prototype.spread = function(t1) {
                                        return "function" != typeof t1 ? i1("expecting a function but got " + c1.classString(t1)) : this.all()._then(t1, void 0, void 0, _1, void 0);
                                    }, x1.prototype.toJSON = function() {
                                        var t1 = {
                                            isFulfilled: !1,
                                            isRejected: !1,
                                            fulfillmentValue: void 0,
                                            rejectionReason: void 0
                                        };
                                        return this.isFulfilled() ? (t1.fulfillmentValue = this.value(), t1.isFulfilled = !0) : this.isRejected() && (t1.rejectionReason = this.reason(), t1.isRejected = !0), t1;
                                    }, x1.prototype.all = function() {
                                        return arguments.length > 0 && this._warn(".all() was passed arguments but it does not take any"), new b1(this).promise();
                                    }, x1.prototype.error = function(t1) {
                                        return this.caught(c1.originatesFromRejection, t1);
                                    }, x1.getNewLibraryCopy = e1.exports, x1.is = function(t1) {
                                        return t1 instanceof x1;
                                    }, x1.fromNode = x1.fromCallback = function(t1) {
                                        var e1 = new x1(m1);
                                        e1._captureStackTrace();
                                        var r1 = arguments.length > 1 && !!Object(arguments[1]).multiArgs, n1 = P1(t1)(E1(e1, r1));
                                        return n1 === $1 && e1._rejectCallback(n1.e, !0), e1._isFateSealed() || e1._setAsyncGuaranteed(), e1;
                                    }, x1.all = function(t1) {
                                        return new b1(t1).promise();
                                    }, x1.cast = function(t1) {
                                        var e1 = g1(t1);
                                        return e1 instanceof x1 || ((e1 = new x1(m1))._captureStackTrace(), e1._setFulfilled(), e1._rejectionHandler0 = t1), e1;
                                    }, x1.resolve = x1.fulfilled = x1.cast, x1.reject = x1.rejected = function(t1) {
                                        var e1 = new x1(m1);
                                        return e1._captureStackTrace(), e1._rejectCallback(t1, !0), e1;
                                    }, x1.setScheduler = function(t1) {
                                        if ("function" != typeof t1) throw new y1("expecting a function but got " + c1.classString(t1));
                                        return p1.setScheduler(t1);
                                    }, x1.prototype._then = function(t1, e1, r1, n1, o1) {
                                        var i1 = void 0 !== o1, s1 = i1 ? o1 : new x1(m1), u1 = this._target(), l1 = u1._bitField;
                                        i1 || (s1._propagateFrom(this, 3), s1._captureStackTrace(), void 0 === n1 && 0 != (2097152 & this._bitField) && (n1 = 0 != (50397184 & l1) ? this._boundValue() : u1 === this ? void 0 : this._boundTo), this._fireEvent("promiseChained", this, s1));
                                        var f1 = a1();
                                        if (0 != (50397184 & l1)) {
                                            var h1, y1, _1 = u1._settlePromiseCtx;
                                            0 != (33554432 & l1) ? (y1 = u1._rejectionHandler0, h1 = t1) : 0 != (16777216 & l1) ? (y1 = u1._fulfillmentHandler0, h1 = e1, u1._unsetRejectionIsUnhandled()) : (_1 = u1._settlePromiseLateCancellationObserver, y1 = new d1("late cancellation observer"), u1._attachExtraTrace(y1), h1 = e1), p1.invoke(_1, u1, {
                                                handler: null === f1 ? h1 : "function" == typeof h1 && c1.domainBind(f1, h1),
                                                promise: s1,
                                                receiver: n1,
                                                value: y1
                                            });
                                        } else u1._addCallbacks(t1, e1, s1, n1, f1);
                                        return s1;
                                    }, x1.prototype._length = function() {
                                        return 65535 & this._bitField;
                                    }, x1.prototype._isFateSealed = function() {
                                        return 0 != (117506048 & this._bitField);
                                    }, x1.prototype._isFollowing = function() {
                                        return 67108864 == (67108864 & this._bitField);
                                    }, x1.prototype._setLength = function(t1) {
                                        this._bitField = -65536 & this._bitField | 65535 & t1;
                                    }, x1.prototype._setFulfilled = function() {
                                        this._bitField = 33554432 | this._bitField, this._fireEvent("promiseFulfilled", this);
                                    }, x1.prototype._setRejected = function() {
                                        this._bitField = 16777216 | this._bitField, this._fireEvent("promiseRejected", this);
                                    }, x1.prototype._setFollowing = function() {
                                        this._bitField = 67108864 | this._bitField, this._fireEvent("promiseResolved", this);
                                    }, x1.prototype._setIsFinal = function() {
                                        this._bitField = 4194304 | this._bitField;
                                    }, x1.prototype._isFinal = function() {
                                        return (4194304 & this._bitField) > 0;
                                    }, x1.prototype._unsetCancelled = function() {
                                        this._bitField = -65537 & this._bitField;
                                    }, x1.prototype._setCancelled = function() {
                                        this._bitField = 65536 | this._bitField, this._fireEvent("promiseCancelled", this);
                                    }, x1.prototype._setWillBeCancelled = function() {
                                        this._bitField = 8388608 | this._bitField;
                                    }, x1.prototype._setAsyncGuaranteed = function() {
                                        p1.hasCustomScheduler() || (this._bitField = 134217728 | this._bitField);
                                    }, x1.prototype._receiverAt = function(t1) {
                                        var e1 = 0 === t1 ? this._receiver0 : this[4 * t1 - 4 + 3];
                                        if (e1 !== u1) return void 0 === e1 && this._isBound() ? this._boundValue() : e1;
                                    }, x1.prototype._promiseAt = function(t1) {
                                        return this[4 * t1 - 4 + 2];
                                    }, x1.prototype._fulfillmentHandlerAt = function(t1) {
                                        return this[4 * t1 - 4 + 0];
                                    }, x1.prototype._rejectionHandlerAt = function(t1) {
                                        return this[4 * t1 - 4 + 1];
                                    }, x1.prototype._boundValue = function() {}, x1.prototype._migrateCallback0 = function(t1) {
                                        t1._bitField;
                                        var e1 = t1._fulfillmentHandler0, r1 = t1._rejectionHandler0, n1 = t1._promise0, o1 = t1._receiverAt(0);
                                        void 0 === o1 && (o1 = u1), this._addCallbacks(e1, r1, n1, o1, null);
                                    }, x1.prototype._migrateCallbackAt = function(t1, e1) {
                                        var r1 = t1._fulfillmentHandlerAt(e1), n1 = t1._rejectionHandlerAt(e1), o1 = t1._promiseAt(e1), i1 = t1._receiverAt(e1);
                                        void 0 === i1 && (i1 = u1), this._addCallbacks(r1, n1, o1, i1, null);
                                    }, x1.prototype._addCallbacks = function(t1, e1, r1, n1, o1) {
                                        var i1 = this._length();
                                        if (i1 >= 65531 && (i1 = 0, this._setLength(0)), 0 === i1) this._promise0 = r1, this._receiver0 = n1, "function" == typeof t1 && (this._fulfillmentHandler0 = null === o1 ? t1 : c1.domainBind(o1, t1)), "function" == typeof e1 && (this._rejectionHandler0 = null === o1 ? e1 : c1.domainBind(o1, e1));
                                        else {
                                            var s1 = 4 * i1 - 4;
                                            this[s1 + 2] = r1, this[s1 + 3] = n1, "function" == typeof t1 && (this[s1 + 0] = null === o1 ? t1 : c1.domainBind(o1, t1)), "function" == typeof e1 && (this[s1 + 1] = null === o1 ? e1 : c1.domainBind(o1, e1));
                                        }
                                        return this._setLength(i1 + 1), i1;
                                    }, x1.prototype._proxy = function(t1, e1) {
                                        this._addCallbacks(void 0, void 0, e1, t1, null);
                                    }, x1.prototype._resolveCallback = function(t1, e1) {
                                        if (0 == (117506048 & this._bitField)) {
                                            if (t1 === this) return this._rejectCallback(n1(), !1);
                                            var r1 = g1(t1, this);
                                            if (!(r1 instanceof x1)) return this._fulfill(t1);
                                            e1 && this._propagateFrom(r1, 2);
                                            var o1 = r1._target();
                                            if (o1 !== this) {
                                                var i1 = o1._bitField;
                                                if (0 == (50397184 & i1)) {
                                                    var s1 = this._length();
                                                    s1 > 0 && o1._migrateCallback0(this);
                                                    for(var a1 = 1; a1 < s1; ++a1)o1._migrateCallbackAt(this, a1);
                                                    this._setFollowing(), this._setLength(0), this._setFollowee(o1);
                                                } else if (0 != (33554432 & i1)) this._fulfill(o1._value());
                                                else if (0 != (16777216 & i1)) this._reject(o1._reason());
                                                else {
                                                    var u1 = new d1("late cancellation observer");
                                                    o1._attachExtraTrace(u1), this._reject(u1);
                                                }
                                            } else this._reject(n1());
                                        }
                                    }, x1.prototype._rejectCallback = function(t1, e1, r1) {
                                        var n1 = c1.ensureErrorObject(t1), o1 = n1 === t1;
                                        if (!o1 && !r1 && S1.warnings()) {
                                            var i1 = "a promise was rejected with a non-error: " + c1.classString(t1);
                                            this._warn(i1, !0);
                                        }
                                        this._attachExtraTrace(n1, !!e1 && o1), this._reject(t1);
                                    }, x1.prototype._resolveFromExecutor = function(t1) {
                                        if (t1 !== m1) {
                                            var e1 = this;
                                            this._captureStackTrace(), this._pushContext();
                                            var r1 = !0, n1 = this._execute(t1, function(t1) {
                                                e1._resolveCallback(t1);
                                            }, function(t1) {
                                                e1._rejectCallback(t1, r1);
                                            });
                                            r1 = !1, this._popContext(), void 0 !== n1 && e1._rejectCallback(n1, !0);
                                        }
                                    }, x1.prototype._settlePromiseFromHandler = function(t1, e1, r1, n1) {
                                        var o1 = n1._bitField;
                                        if (0 == (65536 & o1)) {
                                            var i1;
                                            n1._pushContext(), e1 === _1 ? r1 && "number" == typeof r1.length ? i1 = P1(t1).apply(this._boundValue(), r1) : (i1 = $1).e = new y1("cannot .spread() a non-array: " + c1.classString(r1)) : i1 = P1(t1).call(e1, r1);
                                            var s1 = n1._popContext();
                                            0 == (65536 & (o1 = n1._bitField)) && (i1 === v1 ? n1._reject(r1) : i1 === $1 ? n1._rejectCallback(i1.e, !1) : (S1.checkForgottenReturns(i1, s1, "", n1, this), n1._resolveCallback(i1)));
                                        }
                                    }, x1.prototype._target = function() {
                                        for(var t1 = this; t1._isFollowing();)t1 = t1._followee();
                                        return t1;
                                    }, x1.prototype._followee = function() {
                                        return this._rejectionHandler0;
                                    }, x1.prototype._setFollowee = function(t1) {
                                        this._rejectionHandler0 = t1;
                                    }, x1.prototype._settlePromise = function(t1, e1, r1, n1) {
                                        var i1 = t1 instanceof x1, a1 = this._bitField, u1 = 0 != (134217728 & a1);
                                        0 != (65536 & a1) ? (i1 && t1._invokeInternalOnCancel(), r1 instanceof A1 && r1.isFinallyHandler() ? (r1.cancelPromise = t1, P1(e1).call(r1, n1) === $1 && t1._reject($1.e)) : e1 === o1 ? t1._fulfill(o1.call(r1)) : r1 instanceof s1 ? r1._promiseCancelled(t1) : i1 || t1 instanceof b1 ? t1._cancel() : r1.cancel()) : "function" == typeof e1 ? i1 ? (u1 && t1._setAsyncGuaranteed(), this._settlePromiseFromHandler(e1, r1, n1, t1)) : e1.call(r1, n1, t1) : r1 instanceof s1 ? r1._isResolved() || (0 != (33554432 & a1) ? r1._promiseFulfilled(n1, t1) : r1._promiseRejected(n1, t1)) : i1 && (u1 && t1._setAsyncGuaranteed(), 0 != (33554432 & a1) ? t1._fulfill(n1) : t1._reject(n1));
                                    }, x1.prototype._settlePromiseLateCancellationObserver = function(t1) {
                                        var e1 = t1.handler, r1 = t1.promise, n1 = t1.receiver, o1 = t1.value;
                                        "function" == typeof e1 ? r1 instanceof x1 ? this._settlePromiseFromHandler(e1, n1, o1, r1) : e1.call(n1, o1, r1) : r1 instanceof x1 && r1._reject(o1);
                                    }, x1.prototype._settlePromiseCtx = function(t1) {
                                        this._settlePromise(t1.promise, t1.handler, t1.receiver, t1.value);
                                    }, x1.prototype._settlePromise0 = function(t1, e1, r1) {
                                        var n1 = this._promise0, o1 = this._receiverAt(0);
                                        this._promise0 = void 0, this._receiver0 = void 0, this._settlePromise(n1, t1, o1, e1);
                                    }, x1.prototype._clearCallbackDataAtIndex = function(t1) {
                                        var e1 = 4 * t1 - 4;
                                        this[e1 + 2] = this[e1 + 3] = this[e1 + 0] = this[e1 + 1] = void 0;
                                    }, x1.prototype._fulfill = function(t1) {
                                        var e1 = this._bitField;
                                        if (!((117506048 & e1) >>> 16)) {
                                            if (t1 === this) {
                                                var r1 = n1();
                                                return this._attachExtraTrace(r1), this._reject(r1);
                                            }
                                            this._setFulfilled(), this._rejectionHandler0 = t1, (65535 & e1) > 0 && (0 != (134217728 & e1) ? this._settlePromises() : p1.settlePromises(this));
                                        }
                                    }, x1.prototype._reject = function(t1) {
                                        var e1 = this._bitField;
                                        if (!((117506048 & e1) >>> 16)) {
                                            if (this._setRejected(), this._fulfillmentHandler0 = t1, this._isFinal()) return p1.fatalError(t1, c1.isNode);
                                            (65535 & e1) > 0 ? p1.settlePromises(this) : this._ensurePossibleRejectionHandled();
                                        }
                                    }, x1.prototype._fulfillPromises = function(t1, e1) {
                                        for(var r1 = 1; r1 < t1; r1++){
                                            var n1 = this._fulfillmentHandlerAt(r1), o1 = this._promiseAt(r1), i1 = this._receiverAt(r1);
                                            this._clearCallbackDataAtIndex(r1), this._settlePromise(o1, n1, i1, e1);
                                        }
                                    }, x1.prototype._rejectPromises = function(t1, e1) {
                                        for(var r1 = 1; r1 < t1; r1++){
                                            var n1 = this._rejectionHandlerAt(r1), o1 = this._promiseAt(r1), i1 = this._receiverAt(r1);
                                            this._clearCallbackDataAtIndex(r1), this._settlePromise(o1, n1, i1, e1);
                                        }
                                    }, x1.prototype._settlePromises = function() {
                                        var t1 = this._bitField, e1 = 65535 & t1;
                                        if (e1 > 0) {
                                            if (0 != (16842752 & t1)) {
                                                var r1 = this._fulfillmentHandler0;
                                                this._settlePromise0(this._rejectionHandler0, r1, t1), this._rejectPromises(e1, r1);
                                            } else {
                                                var n1 = this._rejectionHandler0;
                                                this._settlePromise0(this._fulfillmentHandler0, n1, t1), this._fulfillPromises(e1, n1);
                                            }
                                            this._setLength(0);
                                        }
                                        this._clearCancellationData();
                                    }, x1.prototype._settledValue = function() {
                                        var t1 = this._bitField;
                                        return 0 != (33554432 & t1) ? this._rejectionHandler0 : 0 != (16777216 & t1) ? this._fulfillmentHandler0 : void 0;
                                    }, x1.defer = x1.pending = function() {
                                        return S1.deprecated("Promise.defer", "new Promise"), {
                                            promise: new x1(m1),
                                            resolve: N1,
                                            reject: T1
                                        };
                                    }, c1.notEnumerableProp(x1, "_makeSelfResolutionError", n1), t1("./method")(x1, m1, g1, i1, S1), t1("./bind")(x1, m1, g1, S1), t1("./cancel")(x1, b1, i1, S1), t1("./direct_resolve")(x1), t1("./synchronous_inspection")(x1), t1("./join")(x1, b1, g1, m1, p1, a1), x1.Promise = x1, x1.version = "3.5.1", t1("./map.js")(x1, b1, i1, g1, m1, S1), t1("./call_get.js")(x1), t1("./using.js")(x1, i1, g1, O1, m1, S1), t1("./timers.js")(x1, m1, S1), t1("./generators.js")(x1, i1, m1, g1, s1, S1), t1("./nodeify.js")(x1), t1("./promisify.js")(x1, m1), t1("./props.js")(x1, b1, g1, i1), t1("./race.js")(x1, m1, g1, i1), t1("./reduce.js")(x1, b1, i1, g1, m1, S1), t1("./settle.js")(x1, b1, S1), t1("./some.js")(x1, b1, i1), t1("./filter.js")(x1, m1), t1("./each.js")(x1, m1), t1("./any.js")(x1), c1.toFastProperties(x1), c1.toFastProperties(x1.prototype), k1({
                                        a: 1
                                    }), k1({
                                        b: 2
                                    }), k1({
                                        c: 3
                                    }), k1(1), k1(function() {}), k1(void 0), k1(!1), k1(new x1(m1)), S1.setBounds(f1.firstLineError, c1.lastLineError), x1;
                                };
                            },
                            {
                                "./any.js": 1,
                                "./async": 2,
                                "./bind": 3,
                                "./call_get.js": 5,
                                "./cancel": 6,
                                "./catch_filter": 7,
                                "./context": 8,
                                "./debuggability": 9,
                                "./direct_resolve": 10,
                                "./each.js": 11,
                                "./errors": 12,
                                "./es5": 13,
                                "./filter.js": 14,
                                "./finally": 15,
                                "./generators.js": 16,
                                "./join": 17,
                                "./map.js": 18,
                                "./method": 19,
                                "./nodeback": 20,
                                "./nodeify.js": 21,
                                "./promise_array": 23,
                                "./promisify.js": 24,
                                "./props.js": 25,
                                "./race.js": 27,
                                "./reduce.js": 28,
                                "./settle.js": 30,
                                "./some.js": 31,
                                "./synchronous_inspection": 32,
                                "./thenables": 33,
                                "./timers.js": 34,
                                "./using.js": 35,
                                "./util": 36
                            }
                        ],
                        23: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1, o1, i1) {
                                    var s1 = t1("./util");
                                    function a1(t1) {
                                        var n1 = this._promise = new e1(r1);
                                        t1 instanceof e1 && n1._propagateFrom(t1, 3), n1._setOnCancel(this), this._values = t1, this._length = 0, this._totalResolved = 0, this._init(void 0, -2);
                                    }
                                    return s1.isArray, s1.inherits(a1, i1), a1.prototype.length = function() {
                                        return this._length;
                                    }, a1.prototype.promise = function() {
                                        return this._promise;
                                    }, a1.prototype._init = function t1(r1, i1) {
                                        var a1 = n1(this._values, this._promise);
                                        if (a1 instanceof e1) {
                                            var u1 = (a1 = a1._target())._bitField;
                                            if (this._values = a1, 0 == (50397184 & u1)) return this._promise._setAsyncGuaranteed(), a1._then(t1, this._reject, void 0, this, i1);
                                            if (0 == (33554432 & u1)) return 0 != (16777216 & u1) ? this._reject(a1._reason()) : this._cancel();
                                            a1 = a1._value();
                                        }
                                        if (null !== (a1 = s1.asArray(a1))) 0 !== a1.length ? this._iterate(a1) : -5 === i1 ? this._resolveEmptyArray() : this._resolve(function(t1) {
                                            switch(t1){
                                                case -2:
                                                    return [];
                                                case -3:
                                                    return {};
                                                case -6:
                                                    return new Map;
                                            }
                                        }(i1));
                                        else {
                                            var c1 = o1("expecting an array or an iterable object but got " + s1.classString(a1)).reason();
                                            this._promise._rejectCallback(c1, !1);
                                        }
                                    }, a1.prototype._iterate = function(t1) {
                                        var r1 = this.getActualLength(t1.length);
                                        this._length = r1, this._values = this.shouldCopyValues() ? new Array(r1) : this._values;
                                        for(var o1 = this._promise, i1 = !1, s1 = null, a1 = 0; a1 < r1; ++a1){
                                            var u1 = n1(t1[a1], o1);
                                            s1 = u1 instanceof e1 ? (u1 = u1._target())._bitField : null, i1 ? null !== s1 && u1.suppressUnhandledRejections() : null !== s1 ? 0 == (50397184 & s1) ? (u1._proxy(this, a1), this._values[a1] = u1) : i1 = 0 != (33554432 & s1) ? this._promiseFulfilled(u1._value(), a1) : 0 != (16777216 & s1) ? this._promiseRejected(u1._reason(), a1) : this._promiseCancelled(a1) : i1 = this._promiseFulfilled(u1, a1);
                                        }
                                        i1 || o1._setAsyncGuaranteed();
                                    }, a1.prototype._isResolved = function() {
                                        return null === this._values;
                                    }, a1.prototype._resolve = function(t1) {
                                        this._values = null, this._promise._fulfill(t1);
                                    }, a1.prototype._cancel = function() {
                                        !this._isResolved() && this._promise._isCancellable() && (this._values = null, this._promise._cancel());
                                    }, a1.prototype._reject = function(t1) {
                                        this._values = null, this._promise._rejectCallback(t1, !1);
                                    }, a1.prototype._promiseFulfilled = function(t1, e1) {
                                        return this._values[e1] = t1, ++this._totalResolved >= this._length && (this._resolve(this._values), !0);
                                    }, a1.prototype._promiseCancelled = function() {
                                        return this._cancel(), !0;
                                    }, a1.prototype._promiseRejected = function(t1) {
                                        return this._totalResolved++, this._reject(t1), !0;
                                    }, a1.prototype._resultCancelled = function() {
                                        if (!this._isResolved()) {
                                            var t1 = this._values;
                                            if (this._cancel(), t1 instanceof e1) t1.cancel();
                                            else for(var r1 = 0; r1 < t1.length; ++r1)t1[r1] instanceof e1 && t1[r1].cancel();
                                        }
                                    }, a1.prototype.shouldCopyValues = function() {
                                        return !0;
                                    }, a1.prototype.getActualLength = function(t1) {
                                        return t1;
                                    }, a1;
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        24: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1) {
                                    var n1 = {}, o1 = t1("./util"), i1 = t1("./nodeback"), s1 = o1.withAppended, a1 = o1.maybeWrapAsError, u1 = o1.canEvaluate, l1 = t1("./errors").TypeError, f1 = {
                                        __isPromisified__: !0
                                    }, p1 = new RegExp("^(?:" + [
                                        "arity",
                                        "length",
                                        "name",
                                        "arguments",
                                        "caller",
                                        "callee",
                                        "prototype",
                                        "__isPromisified__"
                                    ].join("|") + ")$"), h1 = function(t1) {
                                        return o1.isIdentifier(t1) && "_" !== t1.charAt(0) && "constructor" !== t1;
                                    };
                                    function y1(t1) {
                                        return !p1.test(t1);
                                    }
                                    function d1(t1) {
                                        try {
                                            return !0 === t1.__isPromisified__;
                                        } catch (t1) {
                                            return !1;
                                        }
                                    }
                                    function m1(t1, e1, r1) {
                                        var n1 = o1.getDataPropertyOrDefault(t1, e1 + r1, f1);
                                        return !!n1 && d1(n1);
                                    }
                                    function _1(t1, e1, r1, n1) {
                                        for(var i1 = o1.inheritedDataKeys(t1), s1 = [], a1 = 0; a1 < i1.length; ++a1){
                                            var u1 = i1[a1], c1 = t1[u1], f1 = n1 === h1 || h1(u1);
                                            "function" != typeof c1 || d1(c1) || m1(t1, u1, e1) || !n1(u1, c1, t1, f1) || s1.push(u1, c1);
                                        }
                                        return function(t1, e1, r1) {
                                            for(var n1 = 0; n1 < t1.length; n1 += 2){
                                                var o1 = t1[n1];
                                                if (r1.test(o1)) {
                                                    for(var i1 = o1.replace(r1, ""), s1 = 0; s1 < t1.length; s1 += 2)if (t1[s1] === i1) throw new l1("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", e1));
                                                }
                                            }
                                        }(s1, e1, r1), s1;
                                    }
                                    var v1 = u1 ? void 0 : function(t1, u1, c1, l1, f1, p1) {
                                        var h1 = function() {
                                            return this;
                                        }(), y1 = t1;
                                        function d1() {
                                            var o1 = u1;
                                            u1 === n1 && (o1 = this);
                                            var c1 = new e1(r1);
                                            c1._captureStackTrace();
                                            var l1 = "string" == typeof y1 && this !== h1 ? this[y1] : t1, f1 = i1(c1, p1);
                                            try {
                                                l1.apply(o1, s1(arguments, f1));
                                            } catch (t1) {
                                                c1._rejectCallback(a1(t1), !0, !0);
                                            }
                                            return c1._isFateSealed() || c1._setAsyncGuaranteed(), c1;
                                        }
                                        return "string" == typeof y1 && (t1 = l1), o1.notEnumerableProp(d1, "__isPromisified__", !0), d1;
                                    };
                                    function g1(t1, e1, r1, i1, s1) {
                                        for(var a1 = new RegExp(e1.replace(/([$])/, "\\$") + "$"), u1 = _1(t1, e1, a1, r1), c1 = 0, l1 = u1.length; c1 < l1; c1 += 2){
                                            var f1 = u1[c1], p1 = u1[c1 + 1], h1 = f1 + e1;
                                            if (i1 === v1) t1[h1] = v1(f1, n1, f1, p1, e1, s1);
                                            else {
                                                var y1 = i1(p1, function() {
                                                    return v1(f1, n1, f1, p1, e1, s1);
                                                });
                                                o1.notEnumerableProp(y1, "__isPromisified__", !0), t1[h1] = y1;
                                            }
                                        }
                                        return o1.toFastProperties(t1), t1;
                                    }
                                    e1.promisify = function(t1, e1) {
                                        if ("function" != typeof t1) throw new l1("expecting a function but got " + o1.classString(t1));
                                        if (d1(t1)) return t1;
                                        var r1 = function(t1, e1, r1) {
                                            return v1(t1, e1, void 0, t1, null, r1);
                                        }(t1, void 0 === (e1 = Object(e1)).context ? n1 : e1.context, !!e1.multiArgs);
                                        return o1.copyDescriptors(t1, r1, y1), r1;
                                    }, e1.promisifyAll = function(t1, e1) {
                                        if ("function" != typeof t1 && "object" !== c1(t1)) throw new l1("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
                                        var r1 = !!(e1 = Object(e1)).multiArgs, n1 = e1.suffix;
                                        "string" != typeof n1 && (n1 = "Async");
                                        var i1 = e1.filter;
                                        "function" != typeof i1 && (i1 = h1);
                                        var s1 = e1.promisifier;
                                        if ("function" != typeof s1 && (s1 = v1), !o1.isIdentifier(n1)) throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
                                        for(var a1 = o1.inheritedDataKeys(t1), u1 = 0; u1 < a1.length; ++u1){
                                            var f1 = t1[a1[u1]];
                                            "constructor" !== a1[u1] && o1.isClass(f1) && (g1(f1.prototype, n1, i1, s1, r1), g1(f1, n1, i1, s1, r1));
                                        }
                                        return g1(t1, n1, i1, s1, r1);
                                    };
                                };
                            },
                            {
                                "./errors": 12,
                                "./nodeback": 20,
                                "./util": 36
                            }
                        ],
                        25: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1, o1) {
                                    var i1, s1 = t1("./util"), a1 = s1.isObject, u1 = t1("./es5");
                                    "function" == typeof Map && (i1 = Map);
                                    var c1 = function() {
                                        var t1 = 0, e1 = 0;
                                        function r1(r1, n1) {
                                            this[t1] = r1, this[t1 + e1] = n1, t1++;
                                        }
                                        return function(n1) {
                                            e1 = n1.size, t1 = 0;
                                            var o1 = new Array(2 * n1.size);
                                            return n1.forEach(r1, o1), o1;
                                        };
                                    }();
                                    function l1(t1) {
                                        var e1, r1 = !1;
                                        if (void 0 !== i1 && t1 instanceof i1) e1 = c1(t1), r1 = !0;
                                        else {
                                            var n1 = u1.keys(t1), o1 = n1.length;
                                            e1 = new Array(2 * o1);
                                            for(var s1 = 0; s1 < o1; ++s1){
                                                var a1 = n1[s1];
                                                e1[s1] = t1[a1], e1[s1 + o1] = a1;
                                            }
                                        }
                                        this.constructor$(e1), this._isMap = r1, this._init$(void 0, r1 ? -6 : -3);
                                    }
                                    function f1(t1) {
                                        var r1, i1 = n1(t1);
                                        return a1(i1) ? (r1 = i1 instanceof e1 ? i1._then(e1.props, void 0, void 0, void 0, void 0) : new l1(i1).promise(), i1 instanceof e1 && r1._propagateFrom(i1, 2), r1) : o1("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
                                    }
                                    s1.inherits(l1, r1), l1.prototype._init = function() {}, l1.prototype._promiseFulfilled = function(t1, e1) {
                                        if (this._values[e1] = t1, ++this._totalResolved >= this._length) {
                                            var r1;
                                            if (this._isMap) r1 = function(t1) {
                                                for(var e1 = new i1, r1 = t1.length / 2 | 0, n1 = 0; n1 < r1; ++n1){
                                                    var o1 = t1[r1 + n1], s1 = t1[n1];
                                                    e1.set(o1, s1);
                                                }
                                                return e1;
                                            }(this._values);
                                            else {
                                                r1 = {};
                                                for(var n1 = this.length(), o1 = 0, s1 = this.length(); o1 < s1; ++o1)r1[this._values[o1 + n1]] = this._values[o1];
                                            }
                                            return this._resolve(r1), !0;
                                        }
                                        return !1;
                                    }, l1.prototype.shouldCopyValues = function() {
                                        return !1;
                                    }, l1.prototype.getActualLength = function(t1) {
                                        return t1 >> 1;
                                    }, e1.prototype.props = function() {
                                        return f1(this);
                                    }, e1.props = function(t1) {
                                        return f1(t1);
                                    };
                                };
                            },
                            {
                                "./es5": 13,
                                "./util": 36
                            }
                        ],
                        26: [
                            function(t1, e1, r1) {
                                "use strict";
                                function n1(t1) {
                                    this._capacity = t1, this._length = 0, this._front = 0;
                                }
                                n1.prototype._willBeOverCapacity = function(t1) {
                                    return this._capacity < t1;
                                }, n1.prototype._pushOne = function(t1) {
                                    var e1 = this.length();
                                    this._checkCapacity(e1 + 1), this[this._front + e1 & this._capacity - 1] = t1, this._length = e1 + 1;
                                }, n1.prototype.push = function(t1, e1, r1) {
                                    var n1 = this.length() + 3;
                                    if (this._willBeOverCapacity(n1)) return this._pushOne(t1), this._pushOne(e1), void this._pushOne(r1);
                                    var o1 = this._front + n1 - 3;
                                    this._checkCapacity(n1);
                                    var i1 = this._capacity - 1;
                                    this[o1 + 0 & i1] = t1, this[o1 + 1 & i1] = e1, this[o1 + 2 & i1] = r1, this._length = n1;
                                }, n1.prototype.shift = function() {
                                    var t1 = this._front, e1 = this[t1];
                                    return this[t1] = void 0, this._front = t1 + 1 & this._capacity - 1, this._length--, e1;
                                }, n1.prototype.length = function() {
                                    return this._length;
                                }, n1.prototype._checkCapacity = function(t1) {
                                    this._capacity < t1 && this._resizeTo(this._capacity << 1);
                                }, n1.prototype._resizeTo = function(t1) {
                                    var e1 = this._capacity;
                                    this._capacity = t1, function(t1, e1, r1, n1, o1) {
                                        for(var i1 = 0; i1 < o1; ++i1)r1[i1 + n1] = t1[i1 + e1], t1[i1 + e1] = void 0;
                                    }(this, 0, this, e1, this._front + this._length & e1 - 1);
                                }, e1.exports = n1;
                            },
                            {}
                        ],
                        27: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1, o1) {
                                    var i1 = t1("./util");
                                    function s1(t1, a1) {
                                        var u1, c1 = n1(t1);
                                        if (c1 instanceof e1) return (u1 = c1).then(function(t1) {
                                            return s1(t1, u1);
                                        });
                                        if (null === (t1 = i1.asArray(t1))) return o1("expecting an array or an iterable object but got " + i1.classString(t1));
                                        var l1 = new e1(r1);
                                        void 0 !== a1 && l1._propagateFrom(a1, 3);
                                        for(var f1 = l1._fulfill, p1 = l1._reject, h1 = 0, y1 = t1.length; h1 < y1; ++h1){
                                            var d1 = t1[h1];
                                            (void 0 !== d1 || h1 in t1) && e1.cast(d1)._then(f1, p1, void 0, l1, null);
                                        }
                                        return l1;
                                    }
                                    e1.race = function(t1) {
                                        return s1(t1, void 0);
                                    }, e1.prototype.race = function() {
                                        return s1(this, void 0);
                                    };
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        28: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1, o1, i1, s1) {
                                    var a1 = e1._getDomain, u1 = t1("./util"), c1 = u1.tryCatch;
                                    function l1(t1, r1, n1, o1) {
                                        this.constructor$(t1);
                                        var s1 = a1();
                                        this._fn = null === s1 ? r1 : u1.domainBind(s1, r1), void 0 !== n1 && (n1 = e1.resolve(n1))._attachCancellationCallback(this), this._initialValue = n1, this._currentCancellable = null, this._eachValues = o1 === i1 ? Array(this._length) : 0 === o1 ? null : void 0, this._promise._captureStackTrace(), this._init$(void 0, -5);
                                    }
                                    function f1(t1, e1) {
                                        this.isFulfilled() ? e1._resolve(t1) : e1._reject(t1);
                                    }
                                    function p1(t1, e1, r1, o1) {
                                        return "function" != typeof e1 ? n1("expecting a function but got " + u1.classString(e1)) : new l1(t1, e1, r1, o1).promise();
                                    }
                                    function h1(t1) {
                                        this.accum = t1, this.array._gotAccum(t1);
                                        var r1 = o1(this.value, this.array._promise);
                                        return r1 instanceof e1 ? (this.array._currentCancellable = r1, r1._then(y1, void 0, void 0, this, void 0)) : y1.call(this, r1);
                                    }
                                    function y1(t1) {
                                        var r1, n1 = this.array, o1 = n1._promise, i1 = c1(n1._fn);
                                        o1._pushContext(), (r1 = void 0 !== n1._eachValues ? i1.call(o1._boundValue(), t1, this.index, this.length) : i1.call(o1._boundValue(), this.accum, t1, this.index, this.length)) instanceof e1 && (n1._currentCancellable = r1);
                                        var a1 = o1._popContext();
                                        return s1.checkForgottenReturns(r1, a1, void 0 !== n1._eachValues ? "Promise.each" : "Promise.reduce", o1), r1;
                                    }
                                    u1.inherits(l1, r1), l1.prototype._gotAccum = function(t1) {
                                        void 0 !== this._eachValues && null !== this._eachValues && t1 !== i1 && this._eachValues.push(t1);
                                    }, l1.prototype._eachComplete = function(t1) {
                                        return null !== this._eachValues && this._eachValues.push(t1), this._eachValues;
                                    }, l1.prototype._init = function() {}, l1.prototype._resolveEmptyArray = function() {
                                        this._resolve(void 0 !== this._eachValues ? this._eachValues : this._initialValue);
                                    }, l1.prototype.shouldCopyValues = function() {
                                        return !1;
                                    }, l1.prototype._resolve = function(t1) {
                                        this._promise._resolveCallback(t1), this._values = null;
                                    }, l1.prototype._resultCancelled = function(t1) {
                                        if (t1 === this._initialValue) return this._cancel();
                                        this._isResolved() || (this._resultCancelled$(), this._currentCancellable instanceof e1 && this._currentCancellable.cancel(), this._initialValue instanceof e1 && this._initialValue.cancel());
                                    }, l1.prototype._iterate = function(t1) {
                                        var r1, n1;
                                        this._values = t1;
                                        var o1 = t1.length;
                                        if (void 0 !== this._initialValue ? (r1 = this._initialValue, n1 = 0) : (r1 = e1.resolve(t1[0]), n1 = 1), this._currentCancellable = r1, !r1.isRejected()) for(; n1 < o1; ++n1){
                                            var i1 = {
                                                accum: null,
                                                value: t1[n1],
                                                index: n1,
                                                length: o1,
                                                array: this
                                            };
                                            r1 = r1._then(h1, void 0, void 0, i1, void 0);
                                        }
                                        void 0 !== this._eachValues && (r1 = r1._then(this._eachComplete, void 0, void 0, this, void 0)), r1._then(f1, f1, void 0, r1, this);
                                    }, e1.prototype.reduce = function(t1, e1) {
                                        return p1(this, t1, e1, null);
                                    }, e1.reduce = function(t1, e1, r1, n1) {
                                        return p1(t1, e1, r1, n1);
                                    };
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        29: [
                            function(t1, e1, i1) {
                                "use strict";
                                var s1, a1, u1, c1, l1, f1 = t1("./util"), p1 = f1.getNativePromise();
                                if (f1.isNode && "undefined" == typeof MutationObserver) {
                                    var h1 = n1.setImmediate, y1 = r1.nextTick;
                                    s1 = f1.isRecentNode ? function(t1) {
                                        h1.call(n1, t1);
                                    } : function(t1) {
                                        y1.call(r1, t1);
                                    };
                                } else if ("function" == typeof p1 && "function" == typeof p1.resolve) {
                                    var d1 = p1.resolve();
                                    s1 = function(t1) {
                                        d1.then(t1);
                                    };
                                } else s1 = "undefined" == typeof MutationObserver || "undefined" != typeof window && window.navigator && (window.navigator.standalone || window.cordova) ? void 0 !== o1 ? function(t1) {
                                    o1(t1);
                                } : "undefined" != typeof setTimeout ? function(t1) {
                                    setTimeout(t1, 0);
                                } : function() {
                                    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
                                } : (a1 = document.createElement("div"), u1 = {
                                    attributes: !0
                                }, c1 = !1, l1 = document.createElement("div"), new MutationObserver(function() {
                                    a1.classList.toggle("foo"), c1 = !1;
                                }).observe(l1, u1), function(t1) {
                                    var e1 = new MutationObserver(function() {
                                        e1.disconnect(), t1();
                                    });
                                    e1.observe(a1, u1), c1 || (c1 = !0, l1.classList.toggle("foo"));
                                });
                                e1.exports = s1;
                            },
                            {
                                "./util": 36
                            }
                        ],
                        30: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1) {
                                    var o1 = e1.PromiseInspection;
                                    function i1(t1) {
                                        this.constructor$(t1);
                                    }
                                    t1("./util").inherits(i1, r1), i1.prototype._promiseResolved = function(t1, e1) {
                                        return this._values[t1] = e1, ++this._totalResolved >= this._length && (this._resolve(this._values), !0);
                                    }, i1.prototype._promiseFulfilled = function(t1, e1) {
                                        var r1 = new o1;
                                        return r1._bitField = 33554432, r1._settledValueField = t1, this._promiseResolved(e1, r1);
                                    }, i1.prototype._promiseRejected = function(t1, e1) {
                                        var r1 = new o1;
                                        return r1._bitField = 16777216, r1._settledValueField = t1, this._promiseResolved(e1, r1);
                                    }, e1.settle = function(t1) {
                                        return n1.deprecated(".settle()", ".reflect()"), new i1(t1).promise();
                                    }, e1.prototype.settle = function() {
                                        return e1.settle(this);
                                    };
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        31: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1) {
                                    var o1 = t1("./util"), i1 = t1("./errors").RangeError, s1 = t1("./errors").AggregateError, a1 = o1.isArray, u1 = {};
                                    function c1(t1) {
                                        this.constructor$(t1), this._howMany = 0, this._unwrap = !1, this._initialized = !1;
                                    }
                                    function l1(t1, e1) {
                                        if ((0 | e1) !== e1 || e1 < 0) return n1("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
                                        var r1 = new c1(t1), o1 = r1.promise();
                                        return r1.setHowMany(e1), r1.init(), o1;
                                    }
                                    o1.inherits(c1, r1), c1.prototype._init = function() {
                                        if (this._initialized) {
                                            if (0 !== this._howMany) {
                                                this._init$(void 0, -5);
                                                var t1 = a1(this._values);
                                                !this._isResolved() && t1 && this._howMany > this._canPossiblyFulfill() && this._reject(this._getRangeError(this.length()));
                                            } else this._resolve([]);
                                        }
                                    }, c1.prototype.init = function() {
                                        this._initialized = !0, this._init();
                                    }, c1.prototype.setUnwrap = function() {
                                        this._unwrap = !0;
                                    }, c1.prototype.howMany = function() {
                                        return this._howMany;
                                    }, c1.prototype.setHowMany = function(t1) {
                                        this._howMany = t1;
                                    }, c1.prototype._promiseFulfilled = function(t1) {
                                        return this._addFulfilled(t1), this._fulfilled() === this.howMany() && (this._values.length = this.howMany(), 1 === this.howMany() && this._unwrap ? this._resolve(this._values[0]) : this._resolve(this._values), !0);
                                    }, c1.prototype._promiseRejected = function(t1) {
                                        return this._addRejected(t1), this._checkOutcome();
                                    }, c1.prototype._promiseCancelled = function() {
                                        return this._values instanceof e1 || null == this._values ? this._cancel() : (this._addRejected(u1), this._checkOutcome());
                                    }, c1.prototype._checkOutcome = function() {
                                        if (this.howMany() > this._canPossiblyFulfill()) {
                                            for(var t1 = new s1, e1 = this.length(); e1 < this._values.length; ++e1)this._values[e1] !== u1 && t1.push(this._values[e1]);
                                            return t1.length > 0 ? this._reject(t1) : this._cancel(), !0;
                                        }
                                        return !1;
                                    }, c1.prototype._fulfilled = function() {
                                        return this._totalResolved;
                                    }, c1.prototype._rejected = function() {
                                        return this._values.length - this.length();
                                    }, c1.prototype._addRejected = function(t1) {
                                        this._values.push(t1);
                                    }, c1.prototype._addFulfilled = function(t1) {
                                        this._values[this._totalResolved++] = t1;
                                    }, c1.prototype._canPossiblyFulfill = function() {
                                        return this.length() - this._rejected();
                                    }, c1.prototype._getRangeError = function(t1) {
                                        var e1 = "Input array must contain at least " + this._howMany + " items but contains only " + t1 + " items";
                                        return new i1(e1);
                                    }, c1.prototype._resolveEmptyArray = function() {
                                        this._reject(this._getRangeError(0));
                                    }, e1.some = function(t1, e1) {
                                        return l1(t1, e1);
                                    }, e1.prototype.some = function(t1) {
                                        return l1(this, t1);
                                    }, e1._SomePromiseArray = c1;
                                };
                            },
                            {
                                "./errors": 12,
                                "./util": 36
                            }
                        ],
                        32: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(t1) {
                                    function e1(t1) {
                                        void 0 !== t1 ? (t1 = t1._target(), this._bitField = t1._bitField, this._settledValueField = t1._isFateSealed() ? t1._settledValue() : void 0) : (this._bitField = 0, this._settledValueField = void 0);
                                    }
                                    e1.prototype._settledValue = function() {
                                        return this._settledValueField;
                                    };
                                    var r1 = e1.prototype.value = function() {
                                        if (!this.isFulfilled()) throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
                                        return this._settledValue();
                                    }, n1 = e1.prototype.error = e1.prototype.reason = function() {
                                        if (!this.isRejected()) throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
                                        return this._settledValue();
                                    }, o1 = e1.prototype.isFulfilled = function() {
                                        return 0 != (33554432 & this._bitField);
                                    }, i1 = e1.prototype.isRejected = function() {
                                        return 0 != (16777216 & this._bitField);
                                    }, s1 = e1.prototype.isPending = function() {
                                        return 0 == (50397184 & this._bitField);
                                    }, a1 = e1.prototype.isResolved = function() {
                                        return 0 != (50331648 & this._bitField);
                                    };
                                    e1.prototype.isCancelled = function() {
                                        return 0 != (8454144 & this._bitField);
                                    }, t1.prototype.__isCancelled = function() {
                                        return 65536 == (65536 & this._bitField);
                                    }, t1.prototype._isCancelled = function() {
                                        return this._target().__isCancelled();
                                    }, t1.prototype.isCancelled = function() {
                                        return 0 != (8454144 & this._target()._bitField);
                                    }, t1.prototype.isPending = function() {
                                        return s1.call(this._target());
                                    }, t1.prototype.isRejected = function() {
                                        return i1.call(this._target());
                                    }, t1.prototype.isFulfilled = function() {
                                        return o1.call(this._target());
                                    }, t1.prototype.isResolved = function() {
                                        return a1.call(this._target());
                                    }, t1.prototype.value = function() {
                                        return r1.call(this._target());
                                    }, t1.prototype.reason = function() {
                                        var t1 = this._target();
                                        return t1._unsetRejectionIsUnhandled(), n1.call(t1);
                                    }, t1.prototype._value = function() {
                                        return this._settledValue();
                                    }, t1.prototype._reason = function() {
                                        return this._unsetRejectionIsUnhandled(), this._settledValue();
                                    }, t1.PromiseInspection = e1;
                                };
                            },
                            {}
                        ],
                        33: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1) {
                                    var n1 = t1("./util"), o1 = n1.errorObj, i1 = n1.isObject, s1 = {}.hasOwnProperty;
                                    return function(t1, a1) {
                                        if (i1(t1)) {
                                            if (t1 instanceof e1) return t1;
                                            var u1 = function(t1) {
                                                try {
                                                    return function(t1) {
                                                        return t1.then;
                                                    }(t1);
                                                } catch (t1) {
                                                    return o1.e = t1, o1;
                                                }
                                            }(t1);
                                            if (u1 === o1) {
                                                a1 && a1._pushContext();
                                                var c1 = e1.reject(u1.e);
                                                return a1 && a1._popContext(), c1;
                                            }
                                            if ("function" == typeof u1) return function(t1) {
                                                try {
                                                    return s1.call(t1, "_promise0");
                                                } catch (t1) {
                                                    return !1;
                                                }
                                            }(t1) ? (c1 = new e1(r1), t1._then(c1._fulfill, c1._reject, void 0, c1, null), c1) : function(t1, i1, s1) {
                                                var a1 = new e1(r1), u1 = a1;
                                                s1 && s1._pushContext(), a1._captureStackTrace(), s1 && s1._popContext();
                                                var c1 = n1.tryCatch(i1).call(t1, function(t1) {
                                                    a1 && (a1._resolveCallback(t1), a1 = null);
                                                }, function(t1) {
                                                    a1 && (a1._rejectCallback(t1, !1, !0), a1 = null);
                                                });
                                                return a1 && c1 === o1 && (a1._rejectCallback(c1.e, !0, !0), a1 = null), u1;
                                            }(t1, u1, a1);
                                        }
                                        return t1;
                                    };
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        34: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1) {
                                    var o1 = t1("./util"), i1 = e1.TimeoutError;
                                    function s1(t1) {
                                        this.handle = t1;
                                    }
                                    s1.prototype._resultCancelled = function() {
                                        clearTimeout(this.handle);
                                    };
                                    var a1 = function(t1) {
                                        return u1(+this).thenReturn(t1);
                                    }, u1 = e1.delay = function(t1, o1) {
                                        var i1, u1;
                                        return void 0 !== o1 ? (i1 = e1.resolve(o1)._then(a1, null, null, t1, void 0), n1.cancellation() && o1 instanceof e1 && i1._setOnCancel(o1)) : (i1 = new e1(r1), u1 = setTimeout(function() {
                                            i1._fulfill();
                                        }, +t1), n1.cancellation() && i1._setOnCancel(new s1(u1)), i1._captureStackTrace()), i1._setAsyncGuaranteed(), i1;
                                    };
                                    function c1(t1) {
                                        return clearTimeout(this.handle), t1;
                                    }
                                    function l1(t1) {
                                        throw clearTimeout(this.handle), t1;
                                    }
                                    e1.prototype.delay = function(t1) {
                                        return u1(t1, this);
                                    }, e1.prototype.timeout = function(t1, e1) {
                                        var r1, a1;
                                        t1 = +t1;
                                        var u1 = new s1(setTimeout(function() {
                                            r1.isPending() && function(t1, e1, r1) {
                                                var n1;
                                                n1 = "string" != typeof e1 ? e1 instanceof Error ? e1 : new i1("operation timed out") : new i1(e1), o1.markAsOriginatingFromRejection(n1), t1._attachExtraTrace(n1), t1._reject(n1), null != r1 && r1.cancel();
                                            }(r1, e1, a1);
                                        }, t1));
                                        return n1.cancellation() ? (a1 = this.then(), (r1 = a1._then(c1, l1, void 0, u1, void 0))._setOnCancel(u1)) : r1 = this._then(c1, l1, void 0, u1, void 0), r1;
                                    };
                                };
                            },
                            {
                                "./util": 36
                            }
                        ],
                        35: [
                            function(t1, e1, r1) {
                                "use strict";
                                e1.exports = function(e1, r1, n1, o1, i1, s1) {
                                    var a1 = t1("./util"), u1 = t1("./errors").TypeError, c1 = t1("./util").inherits, l1 = a1.errorObj, f1 = a1.tryCatch, p1 = {};
                                    function h1(t1) {
                                        setTimeout(function() {
                                            throw t1;
                                        }, 0);
                                    }
                                    function y1(t1, r1) {
                                        var o1 = 0, s1 = t1.length, a1 = new e1(i1);
                                        return function i1() {
                                            if (o1 >= s1) return a1._fulfill();
                                            var u1 = function(t1) {
                                                var e1 = n1(t1);
                                                return e1 !== t1 && "function" == typeof t1._isDisposable && "function" == typeof t1._getDisposer && t1._isDisposable() && e1._setDisposable(t1._getDisposer()), e1;
                                            }(t1[o1++]);
                                            if (u1 instanceof e1 && u1._isDisposable()) {
                                                try {
                                                    u1 = n1(u1._getDisposer().tryDispose(r1), t1.promise);
                                                } catch (t1) {
                                                    return h1(t1);
                                                }
                                                if (u1 instanceof e1) return u1._then(i1, h1, null, null, null);
                                            }
                                            i1();
                                        }(), a1;
                                    }
                                    function d1(t1, e1, r1) {
                                        this._data = t1, this._promise = e1, this._context = r1;
                                    }
                                    function m1(t1, e1, r1) {
                                        this.constructor$(t1, e1, r1);
                                    }
                                    function _1(t1) {
                                        return d1.isDisposer(t1) ? (this.resources[this.index]._setDisposable(t1), t1.promise()) : t1;
                                    }
                                    function v1(t1) {
                                        this.length = t1, this.promise = null, this[t1 - 1] = null;
                                    }
                                    d1.prototype.data = function() {
                                        return this._data;
                                    }, d1.prototype.promise = function() {
                                        return this._promise;
                                    }, d1.prototype.resource = function() {
                                        return this.promise().isFulfilled() ? this.promise().value() : p1;
                                    }, d1.prototype.tryDispose = function(t1) {
                                        var e1 = this.resource(), r1 = this._context;
                                        void 0 !== r1 && r1._pushContext();
                                        var n1 = e1 !== p1 ? this.doDispose(e1, t1) : null;
                                        return void 0 !== r1 && r1._popContext(), this._promise._unsetDisposable(), this._data = null, n1;
                                    }, d1.isDisposer = function(t1) {
                                        return null != t1 && "function" == typeof t1.resource && "function" == typeof t1.tryDispose;
                                    }, c1(m1, d1), m1.prototype.doDispose = function(t1, e1) {
                                        return this.data().call(t1, t1, e1);
                                    }, v1.prototype._resultCancelled = function() {
                                        for(var t1 = this.length, r1 = 0; r1 < t1; ++r1){
                                            var n1 = this[r1];
                                            n1 instanceof e1 && n1.cancel();
                                        }
                                    }, e1.using = function() {
                                        var t1 = arguments.length;
                                        if (t1 < 2) return r1("you must pass at least 2 arguments to Promise.using");
                                        var o1, i1 = arguments[t1 - 1];
                                        if ("function" != typeof i1) return r1("expecting a function but got " + a1.classString(i1));
                                        var u1 = !0;
                                        2 === t1 && Array.isArray(arguments[0]) ? (t1 = (o1 = arguments[0]).length, u1 = !1) : (o1 = arguments, t1--);
                                        for(var c1 = new v1(t1), p1 = 0; p1 < t1; ++p1){
                                            var h1 = o1[p1];
                                            if (d1.isDisposer(h1)) {
                                                var m1 = h1;
                                                (h1 = h1.promise())._setDisposable(m1);
                                            } else {
                                                var g1 = n1(h1);
                                                g1 instanceof e1 && (h1 = g1._then(_1, null, null, {
                                                    resources: c1,
                                                    index: p1
                                                }, void 0));
                                            }
                                            c1[p1] = h1;
                                        }
                                        var b1 = new Array(c1.length);
                                        for(p1 = 0; p1 < b1.length; ++p1)b1[p1] = e1.resolve(c1[p1]).reflect();
                                        var w1 = e1.all(b1).then(function(t1) {
                                            for(var e1 = 0; e1 < t1.length; ++e1){
                                                var r1 = t1[e1];
                                                if (r1.isRejected()) return l1.e = r1.error(), l1;
                                                if (!r1.isFulfilled()) return void w1.cancel();
                                                t1[e1] = r1.value();
                                            }
                                            O1._pushContext(), i1 = f1(i1);
                                            var n1 = u1 ? i1.apply(void 0, t1) : i1(t1), o1 = O1._popContext();
                                            return s1.checkForgottenReturns(n1, o1, "Promise.using", O1), n1;
                                        }), O1 = w1.lastly(function() {
                                            var t1 = new e1.PromiseInspection(w1);
                                            return y1(c1, t1);
                                        });
                                        return c1.promise = O1, O1._setOnCancel(c1), O1;
                                    }, e1.prototype._setDisposable = function(t1) {
                                        this._bitField = 131072 | this._bitField, this._disposer = t1;
                                    }, e1.prototype._isDisposable = function() {
                                        return (131072 & this._bitField) > 0;
                                    }, e1.prototype._getDisposer = function() {
                                        return this._disposer;
                                    }, e1.prototype._unsetDisposable = function() {
                                        this._bitField = -131073 & this._bitField, this._disposer = void 0;
                                    }, e1.prototype.disposer = function(t1) {
                                        if ("function" == typeof t1) return new m1(t1, this, o1());
                                        throw new u1;
                                    };
                                };
                            },
                            {
                                "./errors": 12,
                                "./util": 36
                            }
                        ],
                        36: [
                            function(t1, e1, o1) {
                                "use strict";
                                var i1 = t1("./es5"), s1 = "undefined" == typeof navigator, a1 = {
                                    e: {}
                                }, u1, l1 = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== n1 ? n1 : void 0 !== this ? this : null;
                                function f1() {
                                    try {
                                        var t1 = u1;
                                        return u1 = null, t1.apply(this, arguments);
                                    } catch (t1) {
                                        return a1.e = t1, a1;
                                    }
                                }
                                function p1(t1) {
                                    return u1 = t1, f1;
                                }
                                var h1 = function(t1, e1) {
                                    var r1 = {}.hasOwnProperty;
                                    function n1() {
                                        for(var n1 in this.constructor = t1, this.constructor$ = e1, e1.prototype)r1.call(e1.prototype, n1) && "$" !== n1.charAt(n1.length - 1) && (this[n1 + "$"] = e1.prototype[n1]);
                                    }
                                    return n1.prototype = e1.prototype, t1.prototype = new n1, t1.prototype;
                                };
                                function y1(t1) {
                                    return null == t1 || !0 === t1 || !1 === t1 || "string" == typeof t1 || "number" == typeof t1;
                                }
                                function d1(t1) {
                                    return "function" == typeof t1 || "object" === c1(t1) && null !== t1;
                                }
                                function m1(t1) {
                                    return y1(t1) ? new Error(P1(t1)) : t1;
                                }
                                function _1(t1, e1) {
                                    var r1, n1 = t1.length, o1 = new Array(n1 + 1);
                                    for(r1 = 0; r1 < n1; ++r1)o1[r1] = t1[r1];
                                    return o1[r1] = e1, o1;
                                }
                                function v1(t1, e1, r1) {
                                    if (!i1.isES5) return ({}).hasOwnProperty.call(t1, e1) ? t1[e1] : void 0;
                                    var n1 = Object.getOwnPropertyDescriptor(t1, e1);
                                    return null != n1 ? null == n1.get && null == n1.set ? n1.value : r1 : void 0;
                                }
                                function g1(t1, e1, r1) {
                                    if (y1(t1)) return t1;
                                    var n1 = {
                                        value: r1,
                                        configurable: !0,
                                        enumerable: !1,
                                        writable: !0
                                    };
                                    return i1.defineProperty(t1, e1, n1), t1;
                                }
                                function b1(t1) {
                                    throw t1;
                                }
                                var w1 = function() {
                                    var t1 = [
                                        Array.prototype,
                                        Object.prototype,
                                        Function.prototype
                                    ], e1 = function(e1) {
                                        for(var r1 = 0; r1 < t1.length; ++r1)if (t1[r1] === e1) return !0;
                                        return !1;
                                    };
                                    if (i1.isES5) {
                                        var r1 = Object.getOwnPropertyNames;
                                        return function(t1) {
                                            for(var n1 = [], o1 = Object.create(null); null != t1 && !e1(t1);){
                                                var s1;
                                                try {
                                                    s1 = r1(t1);
                                                } catch (t1) {
                                                    return n1;
                                                }
                                                for(var a1 = 0; a1 < s1.length; ++a1){
                                                    var u1 = s1[a1];
                                                    if (!o1[u1]) {
                                                        o1[u1] = !0;
                                                        var c1 = Object.getOwnPropertyDescriptor(t1, u1);
                                                        null != c1 && null == c1.get && null == c1.set && n1.push(u1);
                                                    }
                                                }
                                                t1 = i1.getPrototypeOf(t1);
                                            }
                                            return n1;
                                        };
                                    }
                                    var n1 = {}.hasOwnProperty;
                                    return function(r1) {
                                        if (e1(r1)) return [];
                                        var o1 = [];
                                        t: for(var i1 in r1)if (n1.call(r1, i1)) o1.push(i1);
                                        else {
                                            for(var s1 = 0; s1 < t1.length; ++s1)if (n1.call(t1[s1], i1)) continue t;
                                            o1.push(i1);
                                        }
                                        return o1;
                                    };
                                }(), O1 = /this\s*\.\s*\S+\s*=/;
                                function S1(t1) {
                                    try {
                                        if ("function" == typeof t1) {
                                            var e1 = i1.names(t1.prototype), r1 = i1.isES5 && e1.length > 1, n1 = e1.length > 0 && !(1 === e1.length && "constructor" === e1[0]), o1 = O1.test(t1 + "") && i1.names(t1).length > 0;
                                            if (r1 || n1 || o1) return !0;
                                        }
                                        return !1;
                                    } catch (t1) {
                                        return !1;
                                    }
                                }
                                function A1(t1) {
                                    function e1() {}
                                    e1.prototype = t1;
                                    for(var r1 = 8; r1--;)new e1;
                                    return t1;
                                }
                                var j1 = /^[a-z$_][a-z$_0-9]*$/i;
                                function E1(t1) {
                                    return j1.test(t1);
                                }
                                function $1(t1, e1, r1) {
                                    for(var n1 = new Array(t1), o1 = 0; o1 < t1; ++o1)n1[o1] = e1 + o1 + r1;
                                    return n1;
                                }
                                function P1(t1) {
                                    try {
                                        return t1 + "";
                                    } catch (t1) {
                                        return "[no string representation]";
                                    }
                                }
                                function x1(t1) {
                                    return t1 instanceof Error || null !== t1 && "object" === c1(t1) && "string" == typeof t1.message && "string" == typeof t1.name;
                                }
                                function N1(t1) {
                                    try {
                                        g1(t1, "isOperational", !0);
                                    } catch (t1) {}
                                }
                                function T1(t1) {
                                    return null != t1 && (t1 instanceof Error.__BluebirdErrorTypes__.OperationalError || !0 === t1.isOperational);
                                }
                                function k1(t1) {
                                    return x1(t1) && i1.propertyIsWritable(t1, "stack");
                                }
                                var C1 = "stack" in new Error ? function(t1) {
                                    return k1(t1) ? t1 : new Error(P1(t1));
                                } : function(t1) {
                                    if (k1(t1)) return t1;
                                    try {
                                        throw new Error(P1(t1));
                                    } catch (t1) {
                                        return t1;
                                    }
                                };
                                function D1(t1) {
                                    return ({}).toString.call(t1);
                                }
                                function R1(t1, e1, r1) {
                                    for(var n1 = i1.names(t1), o1 = 0; o1 < n1.length; ++o1){
                                        var s1 = n1[o1];
                                        if (r1(s1)) try {
                                            i1.defineProperty(e1, s1, i1.getDescriptor(t1, s1));
                                        } catch (t1) {}
                                    }
                                }
                                var B1 = function(t1) {
                                    return i1.isArray(t1) ? t1 : null;
                                };
                                if ("undefined" != typeof Symbol && Symbol.iterator) {
                                    var M1 = "function" == typeof Array.from ? function(t1) {
                                        return Array.from(t1);
                                    } : function(t1) {
                                        for(var e1, r1 = [], n1 = t1[Symbol.iterator](); !(e1 = n1.next()).done;)r1.push(e1.value);
                                        return r1;
                                    };
                                    B1 = function(t1) {
                                        return i1.isArray(t1) ? t1 : null != t1 && "function" == typeof t1[Symbol.iterator] ? M1(t1) : null;
                                    };
                                }
                                var I1 = void 0 !== r1 && "[object process]" === D1(r1).toLowerCase(), F1 = void 0 !== r1 && void 0 !== r1.env;
                                function L1(t1) {
                                    return F1 ? r1.env[t1] : void 0;
                                }
                                function U1() {
                                    if ("function" == typeof Promise) try {
                                        var t1 = new Promise(function() {});
                                        if ("[object Promise]" === ({}).toString.call(t1)) return Promise;
                                    } catch (t1) {}
                                }
                                function V1(t1, e1) {
                                    return t1.bind(e1);
                                }
                                var q1 = {
                                    isClass: S1,
                                    isIdentifier: E1,
                                    inheritedDataKeys: w1,
                                    getDataPropertyOrDefault: v1,
                                    thrower: b1,
                                    isArray: i1.isArray,
                                    asArray: B1,
                                    notEnumerableProp: g1,
                                    isPrimitive: y1,
                                    isObject: d1,
                                    isError: x1,
                                    canEvaluate: s1,
                                    errorObj: a1,
                                    tryCatch: p1,
                                    inherits: h1,
                                    withAppended: _1,
                                    maybeWrapAsError: m1,
                                    toFastProperties: A1,
                                    filledRange: $1,
                                    toString: P1,
                                    canAttachTrace: k1,
                                    ensureErrorObject: C1,
                                    originatesFromRejection: T1,
                                    markAsOriginatingFromRejection: N1,
                                    classString: D1,
                                    copyDescriptors: R1,
                                    hasDevTools: "undefined" != typeof chrome && chrome && "function" == typeof chrome.loadTimes,
                                    isNode: I1,
                                    hasEnvVariables: F1,
                                    env: L1,
                                    global: l1,
                                    getNativePromise: U1,
                                    domainBind: V1
                                }, W1;
                                q1.isRecentNode = q1.isNode && (W1 = r1.versions.node.split(".").map(Number), 0 === W1[0] && W1[1] > 10 || W1[0] > 0), q1.isNode && q1.toFastProperties(r1);
                                try {
                                    throw new Error;
                                } catch (t1) {
                                    q1.lastLineError = t1;
                                }
                                e1.exports = q1;
                            },
                            {
                                "./es5": 13
                            }
                        ]
                    }, {}, [
                        4
                    ])(4);
                }, "object" == c1(e1) && void 0 !== t1 ? t1.exports = u1() : (s1 = [], void 0 === (a1 = "function" == typeof (i1 = u1) ? i1.apply(e1, s1) : i1) || (t1.exports = a1)), "undefined" != typeof window && null !== window ? window.P = window.Promise : "undefined" != typeof self && null !== self && (self.P = self.Promise);
            }).call(this, r1(8), r1(11), r1(69).setImmediate);
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = t1.exports = {};
            n1.DocumentNotFoundError = null, n1.general = {}, n1.general.default = "Validator failed for path `{PATH}` with value `{VALUE}`", n1.general.required = "Path `{PATH}` is required.", n1.Number = {}, n1.Number.min = "Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).", n1.Number.max = "Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).", n1.Number.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.", n1.Date = {}, n1.Date.min = "Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).", n1.Date.max = "Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).", n1.String = {}, n1.String.enum = "`{VALUE}` is not a valid enum value for path `{PATH}`.", n1.String.match = "Path `{PATH}` is invalid ({VALUE}).", n1.String.minlength = "Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).", n1.String.maxlength = "Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).";
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                return (o1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function i1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = a1(t1);
                    if (e1) {
                        var o1 = a1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return s1(this, r1);
                };
            }
            function s1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function a1(t1) {
                return (a1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var u1 = r1(5), c1 = r1(4), l1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && o1(t1, e1);
                }(r1, t1);
                var e1 = i1(r1);
                /*!
   * OverwriteModel Error constructor.
   */ function r1(t1, n1, o1, i1) {
                    var s1, a1;
                    !function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, r1);
                    var l1 = u1.messages;
                    return a1 = null != l1.DocumentNotFoundError ? "function" == typeof l1.DocumentNotFoundError ? l1.DocumentNotFoundError(t1, n1) : l1.DocumentNotFoundError : 'No document found for query "' + c1.inspect(t1) + '" on model "' + n1 + '"', (s1 = e1.call(this, a1)).result = i1, s1.numAffected = o1, s1.filter = t1, s1.query = t1, s1;
                }
                return r1;
            }(u1);
            Object.defineProperty(l1.prototype, "name", {
                value: "DocumentNotFoundError"
            }), /*!
 * exports
 */ t1.exports = l1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                return (o1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function i1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = a1(t1);
                    if (e1) {
                        var o1 = a1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return s1(this, r1);
                };
            }
            function s1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function a1(t1) {
                return (a1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var u1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && o1(t1, e1);
                }(r1, t1);
                var e1 = i1(r1);
                function r1(t1, n1, o1) {
                    var i1;
                    !function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, r1);
                    var s1 = o1.join(", ");
                    return (i1 = e1.call(this, 'No matching document found for id "' + t1._id + '" version ' + n1 + ' modifiedPaths "' + s1 + '"')).version = n1, i1.modifiedPaths = o1, i1;
                }
                return r1;
            }(r1(5));
            Object.defineProperty(u1.prototype, "name", {
                value: "VersionError"
            }), /*!
 * exports
 */ t1.exports = u1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                return (o1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function i1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = a1(t1);
                    if (e1) {
                        var o1 = a1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return s1(this, r1);
                };
            }
            function s1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function a1(t1) {
                return (a1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var u1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && o1(t1, e1);
                }(r1, t1);
                var e1 = i1(r1);
                function r1(t1) {
                    !function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, r1);
                    return e1.call(this, "Can't save() the same doc multiple times in parallel. Document: " + t1._id);
                }
                return r1;
            }(r1(5));
            Object.defineProperty(u1.prototype, "name", {
                value: "ParallelSaveError"
            }), /*!
 * exports
 */ t1.exports = u1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                return (o1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function i1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = a1(t1);
                    if (e1) {
                        var o1 = a1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return s1(this, r1);
                };
            }
            function s1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function a1(t1) {
                return (a1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var u1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && o1(t1, e1);
                }(r1, t1);
                var e1 = i1(r1);
                /*!
   * OverwriteModel Error constructor.
   * @param {String} name
   */ function r1(t1) {
                    return function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, r1), e1.call(this, "Cannot overwrite `" + t1 + "` model once compiled.");
                }
                return r1;
            }(r1(5));
            Object.defineProperty(u1.prototype, "name", {
                value: "OverwriteModelError"
            }), /*!
 * exports
 */ t1.exports = u1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                return (o1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function i1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = a1(t1);
                    if (e1) {
                        var o1 = a1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return s1(this, r1);
                };
            }
            function s1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function a1(t1) {
                return (a1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var u1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && o1(t1, e1);
                }(r1, t1);
                var e1 = i1(r1);
                /*!
   * MissingSchema Error constructor.
   * @param {String} name
   */ function r1(t1) {
                    !function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, r1);
                    var n1 = "Schema hasn't been registered for model \"" + t1 + '".\nUse mongoose.model(name, schema)';
                    return e1.call(this, n1);
                }
                return r1;
            }(r1(5));
            Object.defineProperty(u1.prototype, "name", {
                value: "MissingSchemaError"
            }), /*!
 * exports
 */ t1.exports = u1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                return (o1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function i1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = a1(t1);
                    if (e1) {
                        var o1 = a1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return s1(this, r1);
                };
            }
            function s1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function a1(t1) {
                return (a1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var u1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && o1(t1, e1);
                }(r1, t1);
                var e1 = i1(r1);
                /*!
   * DivergentArrayError constructor.
   * @param {Array<String>} paths
   */ function r1(t1) {
                    !function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, r1);
                    var n1 = "For your own good, using `document.save()` to update an array which was selected using an $elemMatch projection OR populated using skip, limit, query conditions, or exclusion of the _id field when the operation results in a $pop or $set of the entire array is not supported. The following path(s) would have been modified unsafely:\n  " + t1.join("\n  ") + "\nUse Model.update() to update these arrays instead.";
                    return e1.call(this, n1);
                }
                return r1;
            }(r1(5));
            Object.defineProperty(u1.prototype, "name", {
                value: "DivergentArrayError"
            }), /*!
 * exports
 */ t1.exports = u1;
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(32);
            /*!
 * ignore
 */ t1.exports = function(t1) {
                var e1, r1;
                t1.$immutable ? (t1.$immutableSetter = (e1 = t1.path, r1 = t1.options.immutable, function(t1) {
                    if (null == this || null == this.$__) return t1;
                    if (this.isNew) return t1;
                    if (!("function" == typeof r1 ? r1.call(this, this) : r1)) return t1;
                    var o1 = this.$__getValue(e1);
                    if ("throw" === this.$__.strictMode && t1 !== o1) throw new n1(e1, "Path `" + e1 + "` is immutable and strict mode is set to throw.", !0);
                    return o1;
                }), t1.set(t1.$immutableSetter)) : t1.$immutableSetter && (t1.setters = t1.setters.filter(function(e1) {
                    return e1 !== t1.$immutableSetter;
                }), delete t1.$immutableSetter);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                return (o1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function i1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = a1(t1);
                    if (e1) {
                        var o1 = a1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return s1(this, r1);
                };
            }
            function s1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function a1(t1) {
                return (a1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var u1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && o1(t1, e1);
                }(r1, t1);
                var e1 = i1(r1);
                function r1(t1, n1, o1) {
                    return function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, r1), e1.call(this, 'Parameter "' + n1 + '" to ' + o1 + "() must be an object, got " + t1.toString());
                }
                return r1;
            }(r1(5));
            Object.defineProperty(u1.prototype, "name", {
                value: "ObjectParameterError"
            }), t1.exports = u1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                return (o1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function i1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = a1(t1);
                    if (e1) {
                        var o1 = a1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return s1(this, r1);
                };
            }
            function s1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function a1(t1) {
                return (a1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var u1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && o1(t1, e1);
                }(r1, t1);
                var e1 = i1(r1);
                function r1(t1) {
                    !function(t1, e1) {
                        if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                    }(this, r1);
                    return e1.call(this, "Can't validate() the same doc multiple times in parallel. Document: " + t1._id);
                }
                return r1;
            }(r1(14));
            Object.defineProperty(u1.prototype, "name", {
                value: "ParallelValidateError"
            }), /*!
 * exports
 */ t1.exports = u1;
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                function r1(t1, e1) {
                    var r1;
                    if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                        if (Array.isArray(t1) || (r1 = function(t1, e1) {
                            if (!t1) return;
                            if ("string" == typeof t1) return n1(t1, e1);
                            var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                            "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                            if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                            if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return n1(t1, e1);
                        }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                            r1 && (t1 = r1);
                            var o1 = 0, i1 = function() {};
                            return {
                                s: i1,
                                n: function() {
                                    return o1 >= t1.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t1[o1++]
                                    };
                                },
                                e: function(t1) {
                                    throw t1;
                                },
                                f: i1
                            };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }
                    var s1, a1 = !0, u1 = !1;
                    return {
                        s: function() {
                            r1 = t1[Symbol.iterator]();
                        },
                        n: function() {
                            var t1 = r1.next();
                            return a1 = t1.done, t1;
                        },
                        e: function(t1) {
                            u1 = !0, s1 = t1;
                        },
                        f: function() {
                            try {
                                a1 || null == r1.return || r1.return();
                            } finally{
                                if (u1) throw s1;
                            }
                        }
                    };
                }
                function n1(t1, e1) {
                    (null == e1 || e1 > t1.length) && (e1 = t1.length);
                    for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                    return n1;
                }
                function o1(t1) {
                    return (o1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                function i1() {
                    this._pres = new Map, this._posts = new Map;
                }
                function s1(t1, e1, r1, n1, o1, i1, s1) {
                    if (i1.useErrorHandlers) {
                        var a1 = {
                            error: e1
                        };
                        return t1.execPost(r1, n1, o1, a1, function(t1) {
                            return "function" == typeof s1 && s1(t1);
                        });
                    }
                    return "function" == typeof s1 ? s1(e1) : void 0;
                }
                function a1(t1, e1, r1) {
                    return t1.has(e1) ? t1.get(e1) : r1;
                }
                function u1(t1, e1, r1, n1) {
                    var o1;
                    try {
                        o1 = t1.apply(e1, r1);
                    } catch (t1) {
                        return n1(t1);
                    }
                    c1(o1) && o1.then(function() {
                        return n1();
                    }, function(t1) {
                        return n1(t1);
                    });
                }
                function c1(t1) {
                    return null != t1 && "function" == typeof t1.then;
                }
                function l1(t1) {
                    var r1 = !1, n1 = this;
                    return function() {
                        var o1 = arguments;
                        if (!r1) return r1 = !0, e1.nextTick(function() {
                            return t1.apply(n1, o1);
                        });
                    };
                }
                i1.prototype.execPre = function(t1, r1, n1, o1) {
                    3 === arguments.length && (o1 = n1, n1 = []);
                    var i1 = a1(this._pres, t1, []), s1 = i1.length, f1 = i1.numAsync || 0, p1 = 0, h1 = f1, y1 = !1, d1 = n1;
                    if (!s1) return e1.nextTick(function() {
                        o1(null);
                    });
                    var m1 = function t1() {
                        if (!(p1 >= s1)) {
                            var n1 = i1[p1];
                            if (n1.isAsync) {
                                var a1 = [
                                    l1(_1),
                                    l1(function(t1) {
                                        if (t1) {
                                            if (y1) return;
                                            return y1 = !0, o1(t1);
                                        }
                                        if (0 == --h1 && p1 >= s1) return o1(null);
                                    })
                                ];
                                u1(n1.fn, r1, a1, a1[0]);
                            } else if (n1.fn.length > 0) {
                                a1 = [
                                    l1(_1)
                                ];
                                for(var f1 = arguments.length >= 2 ? arguments : [
                                    null
                                ].concat(d1), m1 = 1; m1 < f1.length; ++m1)a1.push(f1[m1]);
                                u1(n1.fn, r1, a1, a1[0]);
                            } else {
                                var v1 = null, g1 = null;
                                try {
                                    g1 = n1.fn.call(r1);
                                } catch (t1) {
                                    v1 = t1;
                                }
                                if (c1(g1)) g1.then(function() {
                                    return _1();
                                }, function(t1) {
                                    return _1(t1);
                                });
                                else {
                                    if (++p1 >= s1) return h1 > 0 ? void 0 : e1.nextTick(function() {
                                        o1(v1);
                                    });
                                    t1(v1);
                                }
                            }
                        }
                    };
                    function _1(t1) {
                        if (t1) {
                            if (y1) return;
                            return y1 = !0, o1(t1);
                        }
                        if (++p1 >= s1) return h1 > 0 ? void 0 : o1(null);
                        m1.apply(r1, arguments);
                    }
                    m1.apply(null, [
                        null
                    ].concat(n1));
                }, i1.prototype.execPreSync = function(t1, e1, r1) {
                    for(var n1 = a1(this._pres, t1, []), o1 = n1.length, i1 = 0; i1 < o1; ++i1)n1[i1].fn.apply(e1, r1 || []);
                }, i1.prototype.execPost = function(t1, r1, n1, o1, i1) {
                    arguments.length < 5 && (i1 = o1, o1 = null);
                    var s1 = a1(this._posts, t1, []), f1 = s1.length, p1 = 0, h1 = null;
                    if (o1 && o1.error && (h1 = o1.error), !f1) return e1.nextTick(function() {
                        i1.apply(null, [
                            h1
                        ].concat(n1));
                    });
                    var y1 = function t1() {
                        for(var e1 = s1[p1].fn, o1 = 0, a1 = n1.length, y1 = [], d1 = 0; d1 < a1; ++d1)o1 += n1[d1] && n1[d1]._kareemIgnore ? 0 : 1, n1[d1] && n1[d1]._kareemIgnore || y1.push(n1[d1]);
                        if (h1) {
                            if (e1.length === o1 + 2) {
                                var m1 = l1(function(e1) {
                                    if (e1 && (h1 = e1), ++p1 >= f1) return i1.call(null, h1);
                                    t1();
                                });
                                u1(e1, r1, [
                                    h1
                                ].concat(y1).concat([
                                    m1
                                ]), m1);
                            } else {
                                if (++p1 >= f1) return i1.call(null, h1);
                                t1();
                            }
                        } else {
                            var _1 = l1(function(e1) {
                                return e1 ? (h1 = e1, t1()) : ++p1 >= f1 ? i1.apply(null, [
                                    null
                                ].concat(n1)) : void t1();
                            });
                            if (e1.length === o1 + 2) return ++p1 >= f1 ? i1.apply(null, [
                                null
                            ].concat(n1)) : t1();
                            if (e1.length === o1 + 1) u1(e1, r1, y1.concat([
                                _1
                            ]), _1);
                            else {
                                var v1, g1;
                                try {
                                    g1 = e1.apply(r1, y1);
                                } catch (t1) {
                                    v1 = t1, h1 = t1;
                                }
                                if (c1(g1)) return g1.then(function() {
                                    return _1();
                                }, function(t1) {
                                    return _1(t1);
                                });
                                if (++p1 >= f1) return i1.apply(null, [
                                    v1
                                ].concat(n1));
                                t1();
                            }
                        }
                    };
                    y1();
                }, i1.prototype.execPostSync = function(t1, e1, r1) {
                    for(var n1 = a1(this._posts, t1, []), o1 = n1.length, i1 = 0; i1 < o1; ++i1)n1[i1].fn.apply(e1, r1 || []);
                }, i1.prototype.createWrapperSync = function(t1, e1) {
                    var r1 = this;
                    return function() {
                        r1.execPreSync(t1, this, arguments);
                        var n1 = e1.apply(this, arguments);
                        return r1.execPostSync(t1, this, [
                            n1
                        ]), n1;
                    };
                }, i1.prototype.wrap = function(t1, e1, r1, n1, o1) {
                    var i1 = n1.length > 0 ? n1[n1.length - 1] : null, a1 = ("function" == typeof i1 && n1.slice(0, n1.length - 1), this), u1 = (o1 = o1 || {}).checkForPromise;
                    this.execPre(t1, r1, n1, function(c1) {
                        if (c1) {
                            for(var l1 = o1.numCallbackParams || 0, f1 = o1.contextParameter ? [
                                r1
                            ] : [], p1 = f1.length; p1 < l1; ++p1)f1.push(null);
                            return s1(a1, c1, t1, r1, f1, o1, i1);
                        }
                        var h1 = "function" == typeof i1 ? n1.length - 1 : n1.length, y1 = e1.length, d1 = e1.apply(r1, n1.slice(0, h1).concat(m1));
                        if (u1) {
                            if (null != d1 && "function" == typeof d1.then) return d1.then(function(t1) {
                                return m1(null, t1);
                            }, function(t1) {
                                return m1(t1);
                            });
                            if (y1 < h1 + 1) return m1(null, d1);
                        }
                        function m1() {
                            var e1 = Array.prototype.slice.call(arguments, 1);
                            if (o1.nullResultByDefault && 0 === e1.length && e1.push(null), arguments[0]) return s1(a1, arguments[0], t1, r1, e1, o1, i1);
                            a1.execPost(t1, r1, e1, function() {
                                return arguments[0] ? "function" == typeof i1 ? i1(arguments[0]) : void 0 : "function" == typeof i1 ? i1.apply(r1, arguments) : void 0;
                            });
                        }
                    });
                }, i1.prototype.filter = function(t1) {
                    for(var e1 = this, r1 = this.clone(), n1 = Array.from(r1._pres.keys()), o1 = function() {
                        var n1 = s1[i1], o1 = e1._pres.get(n1).map(function(t1) {
                            return Object.assign({}, t1, {
                                name: n1
                            });
                        }).filter(t1);
                        if (0 === o1.length) return r1._pres.delete(n1), "continue";
                        o1.numAsync = o1.filter(function(t1) {
                            return t1.isAsync;
                        }).length, r1._pres.set(n1, o1);
                    }, i1 = 0, s1 = n1; i1 < s1.length; i1++)o1();
                    for(var a1 = Array.from(r1._posts.keys()), u1 = function() {
                        var n1 = l1[c1], o1 = e1._posts.get(n1).map(function(t1) {
                            return Object.assign({}, t1, {
                                name: n1
                            });
                        }).filter(t1);
                        if (0 === o1.length) return r1._posts.delete(n1), "continue";
                        r1._posts.set(n1, o1);
                    }, c1 = 0, l1 = a1; c1 < l1.length; c1++)u1();
                    return r1;
                }, i1.prototype.hasHooks = function(t1) {
                    return this._pres.has(t1) || this._posts.has(t1);
                }, i1.prototype.createWrapper = function(t1, r1, n1, o1) {
                    var i1 = this;
                    return this.hasHooks(t1) ? function() {
                        var e1 = n1 || this, s1 = Array.prototype.slice.call(arguments);
                        i1.wrap(t1, r1, e1, s1, o1);
                    } : function() {
                        var t1 = arguments, n1 = this;
                        e1.nextTick(function() {
                            return r1.apply(n1, t1);
                        });
                    };
                }, i1.prototype.pre = function(t1, e1, r1, n1, i1) {
                    var s1 = {};
                    "object" === o1(e1) && null != e1 ? e1 = (s1 = e1).isAsync : "boolean" != typeof arguments[1] && (n1 = r1, r1 = e1, e1 = !1);
                    var u1 = a1(this._pres, t1, []);
                    if (this._pres.set(t1, u1), e1 && (u1.numAsync = u1.numAsync || 0, ++u1.numAsync), "function" != typeof r1) throw new Error('pre() requires a function, got "' + o1(r1) + '"');
                    return i1 ? u1.unshift(Object.assign({}, s1, {
                        fn: r1,
                        isAsync: e1
                    })) : u1.push(Object.assign({}, s1, {
                        fn: r1,
                        isAsync: e1
                    })), this;
                }, i1.prototype.post = function(t1, e1, r1, n1) {
                    var i1 = a1(this._posts, t1, []);
                    if ("function" == typeof e1 && (n1 = !!r1, r1 = e1, e1 = {}), "function" != typeof r1) throw new Error('post() requires a function, got "' + o1(r1) + '"');
                    return n1 ? i1.unshift(Object.assign({}, e1, {
                        fn: r1
                    })) : i1.push(Object.assign({}, e1, {
                        fn: r1
                    })), this._posts.set(t1, i1), this;
                }, i1.prototype.clone = function() {
                    var t1, e1 = new i1, n1 = r1(this._pres.keys());
                    try {
                        for(n1.s(); !(t1 = n1.n()).done;){
                            var o1 = t1.value, s1 = this._pres.get(o1).slice();
                            s1.numAsync = this._pres.get(o1).numAsync, e1._pres.set(o1, s1);
                        }
                    } catch (t1) {
                        n1.e(t1);
                    } finally{
                        n1.f();
                    }
                    var a1, u1 = r1(this._posts.keys());
                    try {
                        for(u1.s(); !(a1 = u1.n()).done;){
                            var c1 = a1.value;
                            e1._posts.set(c1, this._posts.get(c1).slice());
                        }
                    } catch (t1) {
                        u1.e(t1);
                    } finally{
                        u1.f();
                    }
                    return e1;
                }, i1.prototype.merge = function(t1, e1) {
                    var n1, o1 = (e1 = 1 === arguments.length || e1) ? this.clone() : this, i1 = r1(t1._pres.keys());
                    try {
                        var s1 = function() {
                            var e1 = n1.value, r1 = a1(o1._pres, e1, []), i1 = t1._pres.get(e1).filter(function(t1) {
                                return -1 === r1.map(function(t1) {
                                    return t1.fn;
                                }).indexOf(t1.fn);
                            }), s1 = r1.concat(i1);
                            s1.numAsync = r1.numAsync || 0, s1.numAsync += i1.filter(function(t1) {
                                return t1.isAsync;
                            }).length, o1._pres.set(e1, s1);
                        };
                        for(i1.s(); !(n1 = i1.n()).done;)s1();
                    } catch (t1) {
                        i1.e(t1);
                    } finally{
                        i1.f();
                    }
                    var u1, c1 = r1(t1._posts.keys());
                    try {
                        var l1 = function() {
                            var e1 = u1.value, r1 = a1(o1._posts, e1, []), n1 = t1._posts.get(e1).filter(function(t1) {
                                return -1 === r1.indexOf(t1);
                            });
                            o1._posts.set(e1, r1.concat(n1));
                        };
                        for(c1.s(); !(u1 = c1.n()).done;)l1();
                    } catch (t1) {
                        c1.e(t1);
                    } finally{
                        c1.f();
                    }
                    return o1;
                }, t1.exports = i1;
            }).call(this, r1(8));
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(10), o1 = function t1(e1) {
                !function(t1, e1) {
                    if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                }(this, t1), Object.assign(this, e1), null != e1 && null != e1.options && (this.options = Object.assign({}, e1.options));
            };
            Object.defineProperty(o1.prototype, "ref", n1), Object.defineProperty(o1.prototype, "refPath", n1), Object.defineProperty(o1.prototype, "localField", n1), Object.defineProperty(o1.prototype, "foreignField", n1), Object.defineProperty(o1.prototype, "justOne", n1), Object.defineProperty(o1.prototype, "count", n1), Object.defineProperty(o1.prototype, "match", n1), Object.defineProperty(o1.prototype, "options", n1), Object.defineProperty(o1.prototype, "skip", n1), Object.defineProperty(o1.prototype, "limit", n1), Object.defineProperty(o1.prototype, "perDocumentLimit", n1), t1.exports = o1;
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(3), o1 = r1(21);
            /*!
 * Gather all indexes defined in the schema, including single nested,
 * document arrays, and embedded discriminators.
 */ t1.exports = function(t1) {
                var e1 = [], r1 = new WeakMap, i1 = t1.constructor.indexTypes, s1 = new Map;
                return function t1(a1, u1, c1) {
                    if (r1.has(a1)) return;
                    r1.set(a1, !0), u1 = u1 || "";
                    for(var l1 = Object.keys(a1.paths), f1 = 0, p1 = l1; f1 < p1.length; f1++){
                        var h1 = p1[f1], y1 = a1.paths[h1];
                        if (null == c1 || !c1.paths[h1]) {
                            if (y1.$isMongooseDocumentArray || y1.$isSingleNested) {
                                if (!0 !== n1(y1, "options.excludeIndexes") && !0 !== n1(y1, "schemaOptions.excludeIndexes") && !0 !== n1(y1, "schema.options.excludeIndexes") && t1(y1.schema, u1 + h1 + "."), null != y1.schema.discriminators) for(var d1 = y1.schema.discriminators, m1 = Object.keys(d1), _1 = 0, v1 = m1; _1 < v1.length; _1++){
                                    var g1 = v1[_1];
                                    t1(d1[g1], u1 + h1 + ".", y1.schema);
                                }
                                if (y1.$isMongooseDocumentArray) continue;
                            }
                            var b1 = y1._index || y1.caster && y1.caster._index;
                            if (!1 !== b1 && null != b1) {
                                var w1 = {}, O1 = o1(b1), S1 = O1 ? b1 : {}, A1 = "string" == typeof b1 ? b1 : !!O1 && b1.type;
                                if (A1 && -1 !== i1.indexOf(A1)) w1[u1 + h1] = A1;
                                else if (S1.text) w1[u1 + h1] = "text", delete S1.text;
                                else {
                                    var j1 = -1 === Number(b1);
                                    w1[u1 + h1] = j1 ? -1 : 1;
                                }
                                delete S1.type, "background" in S1 || (S1.background = !0), null != a1.options.autoIndex && (S1._autoIndex = a1.options.autoIndex);
                                var E1 = S1 && S1.name;
                                "string" == typeof E1 && s1.has(E1) ? Object.assign(s1.get(E1), w1) : (e1.push([
                                    w1,
                                    S1
                                ]), s1.set(E1, w1));
                            }
                        }
                    }
                    r1.delete(a1), u1 ? /*!
   * Checks for indexes added to subdocs using Schema.index().
   * These indexes need their paths prefixed properly.
   *
   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]
   */ function(t1, r1) {
                        for(var n1 = t1._indexes, o1 = n1.length, i1 = 0; i1 < o1; ++i1){
                            for(var s1 = n1[i1][0], a1 = n1[i1][1], u1 = Object.keys(s1), c1 = u1.length, l1 = {}, f1 = 0; f1 < c1; ++f1){
                                var p1 = u1[f1];
                                l1[r1 + p1] = s1[p1];
                            }
                            var h1 = Object.assign({}, a1);
                            if (null != a1 && null != a1.partialFilterExpression) {
                                h1.partialFilterExpression = {};
                                for(var y1 = a1.partialFilterExpression, d1 = 0, m1 = Object.keys(y1); d1 < m1.length; d1++){
                                    var _1 = m1[d1];
                                    h1.partialFilterExpression[r1 + _1] = y1[_1];
                                }
                            }
                            e1.push([
                                l1,
                                h1
                            ]);
                        }
                    }(a1, u1) : (a1._indexes.forEach(function(t1) {
                        "background" in t1[1] || (t1[1].background = !0);
                    }), e1 = e1.concat(a1._indexes));
                }(t1), e1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            t1.exports = function(t1, e1) {
                for(var r1 in t1.add(e1.tree || {}), t1.callQueue = t1.callQueue.concat(e1.callQueue), t1.method(e1.methods), t1.static(e1.statics), e1.query)t1.query[r1] = e1.query[r1];
                for(var n1 in e1.virtuals)t1.virtuals[n1] = e1.virtuals[n1].clone();
                t1.s.hooks.merge(e1.s.hooks, !1);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(141), o1 = r1(143), i1 = r1(3), s1 = r1(75), a1 = r1(51);
            t1.exports = function(t1, e1) {
                var r1 = t1.childSchemas.find(function(t1) {
                    return !!t1.schema.options.timestamps;
                });
                if (e1 || r1) {
                    var u1 = s1(e1, "createdAt"), c1 = s1(e1, "updatedAt"), l1 = null != e1 && e1.hasOwnProperty("currentTime") ? e1.currentTime : null, f1 = {};
                    t1.$timestamps = {
                        createdAt: u1,
                        updatedAt: c1
                    }, c1 && !t1.paths[c1] && (f1[c1] = Date), u1 && !t1.paths[u1] && (f1[u1] = Date), t1.add(f1), t1.pre("save", function(t1) {
                        var e1 = i1(this, "$__.saveOptions.timestamps");
                        if (!1 === e1) return t1();
                        var r1 = null != e1 && !1 === e1.updatedAt, n1 = null != e1 && !1 === e1.createdAt, o1 = null != l1 ? l1() : (this.ownerDocument ? this.ownerDocument() : this).constructor.base.now(), s1 = this._id && this._id.auto;
                        if (!n1 && u1 && !this.get(u1) && this.isSelected(u1) && this.$set(u1, s1 ? this._id.getTimestamp() : o1), !r1 && c1 && (this.isNew || this.isModified())) {
                            var a1 = o1;
                            this.isNew && (null != u1 ? a1 = this.$__getValue(u1) : s1 && (a1 = this._id.getTimestamp())), this.$set(c1, a1);
                        }
                        t1();
                    }), t1.methods.initializeTimestamps = function() {
                        var t1 = null != l1 ? l1() : this.constructor.base.now();
                        return u1 && !this.get(u1) && this.$set(u1, t1), c1 && !this.get(c1) && this.$set(c1, t1), this;
                    }, h1[a1.builtInMiddleware] = !0;
                    var p1 = {
                        query: !0,
                        model: !1
                    };
                    t1.pre("findOneAndUpdate", p1, h1), t1.pre("replaceOne", p1, h1), t1.pre("update", p1, h1), t1.pre("updateOne", p1, h1), t1.pre("updateMany", p1, h1);
                }
                function h1(t1) {
                    var e1 = null != l1 ? l1() : this.model.base.now();
                    o1(e1, u1, c1, this.getUpdate(), this.options, this.schema), n1(e1, this.getUpdate(), this.model.schema), t1();
                }
            };
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1, e1) {
                var r1;
                if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                    if (Array.isArray(t1) || (r1 = function(t1, e1) {
                        if (!t1) return;
                        if ("string" == typeof t1) return o1(t1, e1);
                        var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                        "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                        if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                        if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return o1(t1, e1);
                    }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                        r1 && (t1 = r1);
                        var n1 = 0, i1 = function() {};
                        return {
                            s: i1,
                            n: function() {
                                return n1 >= t1.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t1[n1++]
                                };
                            },
                            e: function(t1) {
                                throw t1;
                            },
                            f: i1
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var s1, a1 = !0, u1 = !1;
                return {
                    s: function() {
                        r1 = t1[Symbol.iterator]();
                    },
                    n: function() {
                        var t1 = r1.next();
                        return a1 = t1.done, t1;
                    },
                    e: function(t1) {
                        u1 = !0, s1 = t1;
                    },
                    f: function() {
                        try {
                            a1 || null == r1.return || r1.return();
                        } finally{
                            if (u1) throw s1;
                        }
                    }
                };
            }
            function o1(t1, e1) {
                (null == e1 || e1 > t1.length) && (e1 = t1.length);
                for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                return n1;
            }
            var i1 = r1(142), s1 = r1(75);
            /*!
 * ignore
 */ function a1(t1, e1, r1) {
                if (null != e1) {
                    if (Object.keys(e1).some(function(t1) {
                        return t1.startsWith("$");
                    })) {
                        if (e1.$push) for(var o1 = 0, i1 = Object.keys(e1.$push); o1 < i1.length; o1++){
                            var a1 = i1[o1], c1 = r1.path(a1);
                            e1.$push[a1] && c1 && c1.$isMongooseDocumentArray && c1.schema.options.timestamps && function() {
                                var r1 = c1.schema.options.timestamps, n1 = s1(r1, "createdAt"), o1 = s1(r1, "updatedAt");
                                e1.$push[a1].$each ? e1.$push[a1].$each.forEach(function(e1) {
                                    null != o1 && (e1[o1] = t1), null != n1 && (e1[n1] = t1);
                                }) : (null != o1 && (e1.$push[a1][o1] = t1), null != n1 && (e1.$push[a1][n1] = t1));
                            }();
                        }
                        if (null != e1.$set) for(var l1 = 0, f1 = Object.keys(e1.$set); l1 < f1.length; l1++)u1(r1, f1[l1], e1.$set, t1);
                    }
                    var p1, h1 = n1(Object.keys(e1).filter(function(t1) {
                        return !t1.startsWith("$");
                    }));
                    try {
                        for(h1.s(); !(p1 = h1.n()).done;)u1(r1, p1.value, e1, t1);
                    } catch (t1) {
                        h1.e(t1);
                    } finally{
                        h1.f();
                    }
                }
            }
            function u1(t1, e1, r1, o1) {
                var u1 = i1(e1), c1 = t1.path(u1);
                if (c1) {
                    for(var l1 = [], f1 = u1.split("."), p1 = f1.length - 1; p1 > 0; --p1){
                        var h1 = t1.path(f1.slice(0, p1).join("."));
                        null != h1 && (h1.$isMongooseDocumentArray || h1.$isSingleNested) && l1.push({
                            parentPath: e1.split(".").slice(0, p1).join("."),
                            parentSchemaType: h1
                        });
                    }
                    if (Array.isArray(r1[e1]) && c1.$isMongooseDocumentArray) !function(t1, e1, r1) {
                        var n1 = e1.schema.options.timestamps;
                        if (n1) for(var o1 = t1.length, i1 = s1(n1, "createdAt"), u1 = s1(n1, "updatedAt"), c1 = 0; c1 < o1; ++c1)null != u1 && (t1[c1][u1] = r1), null != i1 && (t1[c1][i1] = r1), a1(r1, t1[c1], e1.schema);
                    }(r1[e1], c1, o1);
                    else if (r1[e1] && c1.$isSingleNested) !function(t1, e1, r1) {
                        var n1 = e1.schema.options.timestamps;
                        if (n1) {
                            var o1 = s1(n1, "createdAt"), i1 = s1(n1, "updatedAt");
                            null != i1 && (t1[i1] = r1), null != o1 && (t1[o1] = r1), a1(r1, t1, e1.schema);
                        }
                    }(r1[e1], c1, o1);
                    else if (l1.length > 0) {
                        var y1, d1 = n1(l1);
                        try {
                            for(d1.s(); !(y1 = d1.n()).done;){
                                var m1 = y1.value, _1 = m1.parentPath, v1 = m1.parentSchemaType, g1 = v1.schema.options.timestamps, b1 = s1(g1, "updatedAt");
                                if (g1 && null != b1) {
                                    if (v1.$isSingleNested) r1[_1 + "." + b1] = o1;
                                    else if (v1.$isMongooseDocumentArray) {
                                        var w1 = e1.substr(_1.length + 1);
                                        if (/^\d+$/.test(w1)) {
                                            r1[_1 + "." + w1][b1] = o1;
                                            continue;
                                        }
                                        var O1 = w1.indexOf(".");
                                        r1[_1 + "." + (w1 = -1 !== O1 ? w1.substr(0, O1) : w1) + "." + b1] = o1;
                                    }
                                }
                            }
                        } catch (t1) {
                            d1.e(t1);
                        } finally{
                            d1.f();
                        }
                    } else if (null != c1.schema && c1.schema != t1 && r1[e1]) {
                        var S1 = c1.schema.options.timestamps, A1 = s1(S1, "createdAt"), j1 = s1(S1, "updatedAt");
                        if (!S1) return;
                        null != j1 && (r1[e1][j1] = o1), null != A1 && (r1[e1][A1] = o1);
                    }
                }
            }
            t1.exports = a1;
        },
        function(t1, e1, r1) {
            "use strict";
            t1.exports = function(t1) {
                return t1.replace(/\.\$(\[[^\]]*\])?\./g, ".0.").replace(/\.(\[[^\]]*\])?\$$/g, ".0");
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * ignore
 */ var n1 = r1(3);
            t1.exports = /*!
 * ignore
 */ function(t1, e1, r1, o1, i1) {
                var s1 = o1, a1 = s1, u1 = n1(i1, "overwrite", !1), c1 = n1(i1, "timestamps", !0);
                if (!c1 || null == s1) return o1;
                var l1 = null != c1 && !1 === c1.createdAt, f1 = null != c1 && !1 === c1.updatedAt;
                if (u1) return o1 && o1.$set && (o1 = o1.$set, s1.$set = {}, a1 = s1.$set), f1 || !r1 || o1[r1] || (a1[r1] = t1), l1 || !e1 || o1[e1] || (a1[e1] = t1), s1;
                if (o1 = o1 || {}, Array.isArray(s1)) return s1.push({
                    $set: {
                        updatedAt: t1
                    }
                }), s1;
                if (s1.$set = s1.$set || {}, !f1 && r1 && (!o1.$currentDate || !o1.$currentDate[r1])) {
                    var p1 = !1;
                    if (-1 !== r1.indexOf(".")) for(var h1 = r1.split("."), y1 = 1; y1 < h1.length; ++y1){
                        var d1 = h1.slice(-y1).join("."), m1 = h1.slice(0, -y1).join(".");
                        if (null != o1[m1]) {
                            o1[m1][d1] = t1, p1 = !0;
                            break;
                        }
                        if (o1.$set && o1.$set[m1]) {
                            o1.$set[m1][d1] = t1, p1 = !0;
                            break;
                        }
                    }
                    p1 || (s1.$set[r1] = t1), s1.hasOwnProperty(r1) && delete s1[r1];
                }
                if (!l1 && e1) {
                    o1[e1] && delete o1[e1], o1.$set && o1.$set[e1] && delete o1.$set[e1];
                    var _1 = !1;
                    if (-1 !== e1.indexOf(".")) for(var v1 = e1.split("."), g1 = 1; g1 < v1.length; ++g1){
                        var b1 = v1.slice(-g1).join("."), w1 = v1.slice(0, -g1).join(".");
                        if (null != o1[w1]) {
                            o1[w1][b1] = t1, _1 = !0;
                            break;
                        }
                        if (o1.$set && o1.$set[w1]) {
                            o1.$set[w1][b1] = t1, _1 = !0;
                            break;
                        }
                    }
                    _1 || (s1.$setOnInsert = s1.$setOnInsert || {}, s1.$setOnInsert[e1] = t1);
                }
                0 === Object.keys(s1.$set).length && delete s1.$set;
                return s1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(14), o1 = r1(4);
            t1.exports = function(t1, e1) {
                if ("string" == typeof t1) return;
                if ("function" == typeof t1) return;
                throw new n1('Invalid ref at path "' + e1 + '". Got ' + o1.inspect(t1, {
                    depth: 0
                }));
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * ignore
 */ /*!
 * Apply query middleware
 *
 * @param {Query} query constructor
 * @param {Model} model
 */ function n1(t1, e1) {
                var r1 = {
                    useErrorHandlers: !0,
                    numCallbackParams: 1,
                    nullResultByDefault: !0
                }, o1 = e1.hooks.filter(function(t1) {
                    var e1 = function(t1) {
                        var e1 = {};
                        t1.hasOwnProperty("query") && (e1.query = t1.query);
                        t1.hasOwnProperty("document") && (e1.document = t1.document);
                        return e1;
                    }(t1);
                    return "updateOne" === t1.name ? null == e1.query || !!e1.query : "deleteOne" === t1.name ? !!e1.query || 0 === Object.keys(e1).length : "validate" !== t1.name && "remove" !== t1.name || !!e1.query;
                });
                t1.prototype._execUpdate = o1.createWrapper("update", t1.prototype._execUpdate, null, r1), t1.prototype.__distinct = o1.createWrapper("distinct", t1.prototype.__distinct, null, r1), t1.prototype.validate = o1.createWrapper("validate", t1.prototype.validate, null, r1), n1.middlewareFunctions.filter(function(t1) {
                    return "update" !== t1 && "distinct" !== t1 && "validate" !== t1;
                }).forEach(function(e1) {
                    t1.prototype["_".concat(e1)] = o1.createWrapper(e1, t1.prototype["_".concat(e1)], null, r1);
                });
            }
            t1.exports = n1, /*!
 * ignore
 */ n1.middlewareFunctions = [
                "count",
                "countDocuments",
                "deleteMany",
                "deleteOne",
                "distinct",
                "estimatedDocumentCount",
                "find",
                "findOne",
                "findOneAndDelete",
                "findOneAndRemove",
                "findOneAndReplace",
                "findOneAndUpdate",
                "remove",
                "replaceOne",
                "update",
                "updateMany",
                "updateOne",
                "validate"
            ];
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                /*!
 * Module dependencies.
 */ function n1(t1, e1) {
                    var r1;
                    if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                        if (Array.isArray(t1) || (r1 = function(t1, e1) {
                            if (!t1) return;
                            if ("string" == typeof t1) return o1(t1, e1);
                            var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                            "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                            if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                            if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return o1(t1, e1);
                        }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                            r1 && (t1 = r1);
                            var n1 = 0, i1 = function() {};
                            return {
                                s: i1,
                                n: function() {
                                    return n1 >= t1.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t1[n1++]
                                    };
                                },
                                e: function(t1) {
                                    throw t1;
                                },
                                f: i1
                            };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }
                    var s1, a1 = !0, u1 = !1;
                    return {
                        s: function() {
                            r1 = t1[Symbol.iterator]();
                        },
                        n: function() {
                            var t1 = r1.next();
                            return a1 = t1.done, t1;
                        },
                        e: function(t1) {
                            u1 = !0, s1 = t1;
                        },
                        f: function() {
                            try {
                                a1 || null == r1.return || r1.return();
                            } finally{
                                if (u1) throw s1;
                            }
                        }
                    };
                }
                function o1(t1, e1) {
                    (null == e1 || e1 > t1.length) && (e1 = t1.length);
                    for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                    return n1;
                }
                var i1, s1 = r1(7), a1 = r1(5), u1 = r1(147), c1 = r1(77), l1 = r1(2), f1 = r1(0).populateModelSymbol, p1 = s1.CastError;
                function h1(t1, e1) {
                    this.enumValues = [], this.regExp = null, s1.call(this, t1, e1, "String");
                }
                /*!
 * ignore
 */ function y1(t1) {
                    return this.castForQuery(t1);
                }
                h1.schemaName = "String", h1.defaultOptions = {}, /*!
 * Inherits from SchemaType.
 */ h1.prototype = Object.create(s1.prototype), h1.prototype.constructor = h1, Object.defineProperty(h1.prototype, "OptionsConstructor", {
                    configurable: !1,
                    enumerable: !1,
                    writable: !1,
                    value: u1
                }), /*!
 * ignore
 */ h1._cast = c1, h1.cast = function(t1) {
                    return 0 === arguments.length || (!1 === t1 && (t1 = function(t1) {
                        if (null != t1 && "string" != typeof t1) throw new Error;
                        return t1;
                    }), this._cast = t1), this._cast;
                }, h1.get = s1.get, h1.set = s1.set, /*!
 * ignore
 */ h1._checkRequired = function(t1) {
                    return (t1 instanceof String || "string" == typeof t1) && t1.length;
                }, h1.checkRequired = s1.checkRequired, h1.prototype.enum = function() {
                    if (this.enumValidator && (this.validators = this.validators.filter(function(t1) {
                        return t1.validator !== this.enumValidator;
                    }, this), this.enumValidator = !1), void 0 === arguments[0] || !1 === arguments[0]) return this;
                    var t1, e1;
                    l1.isObject(arguments[0]) ? (t1 = arguments[0].values, e1 = arguments[0].message) : (t1 = arguments, e1 = a1.messages.String.enum);
                    var r1, o1 = n1(t1);
                    try {
                        for(o1.s(); !(r1 = o1.n()).done;){
                            var i1 = r1.value;
                            void 0 !== i1 && this.enumValues.push(this.cast(i1));
                        }
                    } catch (t1) {
                        o1.e(t1);
                    } finally{
                        o1.f();
                    }
                    var s1 = this.enumValues;
                    return this.enumValidator = function(t1) {
                        return void 0 === t1 || ~s1.indexOf(t1);
                    }, this.validators.push({
                        validator: this.enumValidator,
                        message: e1,
                        type: "enum",
                        enumValues: s1
                    }), this;
                }, h1.prototype.lowercase = function(t1) {
                    return arguments.length > 0 && !t1 ? this : this.set(function(t1, e1) {
                        return "string" != typeof t1 && (t1 = e1.cast(t1)), t1 ? t1.toLowerCase() : t1;
                    });
                }, h1.prototype.uppercase = function(t1) {
                    return arguments.length > 0 && !t1 ? this : this.set(function(t1, e1) {
                        return "string" != typeof t1 && (t1 = e1.cast(t1)), t1 ? t1.toUpperCase() : t1;
                    });
                }, h1.prototype.trim = function(t1) {
                    return arguments.length > 0 && !t1 ? this : this.set(function(t1, e1) {
                        return "string" != typeof t1 && (t1 = e1.cast(t1)), t1 ? t1.trim() : t1;
                    });
                }, h1.prototype.minlength = function(t1, e1) {
                    if (this.minlengthValidator && (this.validators = this.validators.filter(function(t1) {
                        return t1.validator !== this.minlengthValidator;
                    }, this)), null != t1) {
                        var r1 = e1 || a1.messages.String.minlength;
                        r1 = r1.replace(/{MINLENGTH}/, t1), this.validators.push({
                            validator: this.minlengthValidator = function(e1) {
                                return null === e1 || e1.length >= t1;
                            },
                            message: r1,
                            type: "minlength",
                            minlength: t1
                        });
                    }
                    return this;
                }, h1.prototype.maxlength = function(t1, e1) {
                    if (this.maxlengthValidator && (this.validators = this.validators.filter(function(t1) {
                        return t1.validator !== this.maxlengthValidator;
                    }, this)), null != t1) {
                        var r1 = e1 || a1.messages.String.maxlength;
                        r1 = r1.replace(/{MAXLENGTH}/, t1), this.validators.push({
                            validator: this.maxlengthValidator = function(e1) {
                                return null === e1 || e1.length <= t1;
                            },
                            message: r1,
                            type: "maxlength",
                            maxlength: t1
                        });
                    }
                    return this;
                }, h1.prototype.match = function(t1, e1) {
                    var r1 = e1 || a1.messages.String.match;
                    return this.validators.push({
                        validator: function(e1) {
                            return !!t1 && (t1.lastIndex = 0, null == e1 || "" === e1 || t1.test(e1));
                        },
                        message: r1,
                        type: "regexp",
                        regexp: t1
                    }), this;
                }, h1.prototype.checkRequired = function(t1, e1) {
                    return s1._isRef(this, t1, e1, !0) ? !!t1 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : h1.checkRequired())(t1);
                }, h1.prototype.cast = function(t1, n1, o1) {
                    if (s1._isRef(this, t1, n1, o1)) {
                        if (null == t1) return t1;
                        if (i1 || (i1 = r1(6)), t1 instanceof i1) return t1.$__.wasPopulated = !0, t1;
                        if ("string" == typeof t1) return t1;
                        if (e1.isBuffer(t1) || !l1.isObject(t1)) throw new p1("string", t1, this.path, null, this);
                        var a1 = n1.$__fullPath(this.path), u1 = new ((n1.ownerDocument ? n1.ownerDocument() : n1).populated(a1, !0)).options[f1](t1);
                        return u1.$__.wasPopulated = !0, u1;
                    }
                    var c1 = "function" == typeof this.constructor.cast ? this.constructor.cast() : h1.cast();
                    try {
                        return c1(t1);
                    } catch (e1) {
                        throw new p1("string", t1, this.path, null, this);
                    }
                };
                var d1 = l1.options(s1.prototype.$conditionalHandlers, {
                    $all: function(t1) {
                        var e1 = this;
                        return Array.isArray(t1) ? t1.map(function(t1) {
                            return e1.castForQuery(t1);
                        }) : [
                            this.castForQuery(t1)
                        ];
                    },
                    $gt: y1,
                    $gte: y1,
                    $lt: y1,
                    $lte: y1,
                    $options: String,
                    $regex: y1,
                    $not: y1
                });
                Object.defineProperty(h1.prototype, "$conditionalHandlers", {
                    configurable: !1,
                    enumerable: !1,
                    writable: !1,
                    value: Object.freeze(d1)
                }), h1.prototype.castForQuery = function(t1, e1) {
                    var r1;
                    if (2 === arguments.length) {
                        if (!(r1 = this.$conditionalHandlers[t1])) throw new Error("Can't use " + t1 + " with String.");
                        return r1.call(this, e1);
                    }
                    return e1 = t1, "[object RegExp]" === Object.prototype.toString.call(e1) ? e1 : this._castForQuery(e1);
                }, /*!
 * Module exports.
 */ t1.exports = h1;
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
            }
            function i1(t1, e1) {
                return (i1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function s1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = u1(t1);
                    if (e1) {
                        var o1 = u1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return a1(this, r1);
                };
            }
            function a1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function u1(t1) {
                return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var c1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && i1(t1, e1);
                }(r1, t1);
                var e1 = s1(r1);
                function r1() {
                    return o1(this, r1), e1.apply(this, arguments);
                }
                return r1;
            }(r1(9)), l1 = r1(10);
            Object.defineProperty(c1.prototype, "enum", l1), Object.defineProperty(c1.prototype, "match", l1), Object.defineProperty(c1.prototype, "lowercase", l1), Object.defineProperty(c1.prototype, "trim", l1), Object.defineProperty(c1.prototype, "uppercase", l1), Object.defineProperty(c1.prototype, "minlength", l1), Object.defineProperty(c1.prototype, "maxlength", l1), /*!
 * ignore
 */ t1.exports = c1;
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
            }
            function i1(t1, e1) {
                return (i1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function s1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = u1(t1);
                    if (e1) {
                        var o1 = u1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return a1(this, r1);
                };
            }
            function a1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function u1(t1) {
                return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var c1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && i1(t1, e1);
                }(r1, t1);
                var e1 = s1(r1);
                function r1() {
                    return o1(this, r1), e1.apply(this, arguments);
                }
                return r1;
            }(r1(9)), l1 = r1(10);
            Object.defineProperty(c1.prototype, "min", l1), Object.defineProperty(c1.prototype, "max", l1), Object.defineProperty(c1.prototype, "enum", l1), /*!
 * ignore
 */ t1.exports = c1;
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(22);
            /*!
 * Given a value, cast it to a number, or throw a `CastError` if the value
 * cannot be casted. `null` and `undefined` are considered valid.
 *
 * @param {Any} value
 * @param {String} [path] optional the path to set on the CastError
 * @return {Boolean|null|undefined}
 * @throws {Error} if `value` is not one of the allowed values
 * @api private
 */ t1.exports = function(t1) {
                return null == t1 ? t1 : "" === t1 ? null : ("string" != typeof t1 && "boolean" != typeof t1 || (t1 = Number(t1)), n1.ok(!isNaN(t1)), t1 instanceof Number ? t1.valueOf() : "number" == typeof t1 ? t1 : Array.isArray(t1) || "function" != typeof t1.valueOf ? t1.toString && !Array.isArray(t1) && t1.toString() == Number(t1) ? Number(t1) : void n1.ok(!1) : Number(t1.valueOf()));
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ var n1 = r1(12), o1 = r1(7), i1 = r1(49), s1 = r1(2);
            function a1(t1, e1) {
                o1.call(this, t1, e1, "Boolean");
            }
            a1.schemaName = "Boolean", a1.defaultOptions = {}, /*!
 * Inherits from SchemaType.
 */ a1.prototype = Object.create(o1.prototype), a1.prototype.constructor = a1, /*!
 * ignore
 */ a1._cast = i1, a1.set = o1.set, a1.cast = function(t1) {
                return 0 === arguments.length || (!1 === t1 && (t1 = function(t1) {
                    if (null != t1 && "boolean" != typeof t1) throw new Error;
                    return t1;
                }), this._cast = t1), this._cast;
            }, /*!
 * ignore
 */ a1._checkRequired = function(t1) {
                return !0 === t1 || !1 === t1;
            }, a1.checkRequired = o1.checkRequired, a1.prototype.checkRequired = function(t1) {
                return this.constructor._checkRequired(t1);
            }, Object.defineProperty(a1, "convertToTrue", {
                get: function() {
                    return i1.convertToTrue;
                },
                set: function(t1) {
                    i1.convertToTrue = t1;
                }
            }), Object.defineProperty(a1, "convertToFalse", {
                get: function() {
                    return i1.convertToFalse;
                },
                set: function(t1) {
                    i1.convertToFalse = t1;
                }
            }), a1.prototype.cast = function(t1) {
                var e1 = "function" == typeof this.constructor.cast ? this.constructor.cast() : a1.cast();
                try {
                    return e1(t1);
                } catch (e1) {
                    throw new n1("Boolean", t1, this.path, e1, this);
                }
            }, a1.$conditionalHandlers = s1.options(o1.prototype.$conditionalHandlers, {}), a1.prototype.castForQuery = function(t1, e1) {
                var r1;
                return 2 === arguments.length ? (r1 = a1.$conditionalHandlers[t1]) ? r1.call(this, e1) : this._castForQuery(e1) : this._castForQuery(t1);
            }, a1.prototype._castNullish = function(t1) {
                if (void 0 === t1 && null != this.$$context && null != this.$$context._mongooseOptions && this.$$context._mongooseOptions.omitUndefined) return t1;
                var e1 = "function" == typeof this.constructor.cast ? this.constructor.cast() : a1.cast();
                return null == e1 ? t1 : !(e1.convertToFalse instanceof Set && e1.convertToFalse.has(t1)) && (!!(e1.convertToTrue instanceof Set && e1.convertToTrue.has(t1)) || t1);
            }, /*!
 * Module exports.
 */ t1.exports = a1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ var n1, o1, i1 = r1(55), s1 = r1(12), a1 = r1(19).EventEmitter, u1 = r1(157), c1 = r1(7), l1 = r1(31), f1 = r1(90), p1 = r1(3), h1 = r1(91), y1 = r1(4), d1 = r1(2), m1 = r1(92), _1 = r1(0).arrayPathSymbol, v1 = r1(0).documentArrayParent;
            function g1(t1, e1, r1, n1) {
                null != n1 && null != n1._id ? e1 = h1(e1, n1) : null != r1 && null != r1._id && (e1 = h1(e1, r1));
                var o1 = b1(e1, r1);
                o1.prototype.$basePath = t1, i1.call(this, t1, o1, r1), this.schema = e1, this.schemaOptions = n1 || {}, this.$isMongooseDocumentArray = !0, this.Constructor = o1, o1.base = e1.base;
                var s1 = this.defaultValue;
                "defaultValue" in this && void 0 === s1 || this.default(function() {
                    var t1 = s1.call(this);
                    return Array.isArray(t1) || (t1 = [
                        t1
                    ]), t1;
                });
                var a1 = this;
                this.$embeddedSchemaType = new c1(t1 + ".$", {
                    required: p1(this, "schemaOptions.required", !1)
                }), this.$embeddedSchemaType.cast = function(t1, e1, r1) {
                    return a1.cast(t1, e1, r1)[0];
                }, this.$embeddedSchemaType.$isMongooseDocumentArrayElement = !0, this.$embeddedSchemaType.caster = this.Constructor, this.$embeddedSchemaType.schema = this.schema;
            }
            /*!
 * Ignore
 */ function b1(t1, e1, n1) {
                function i1() {
                    o1.apply(this, arguments), this.$session(this.ownerDocument().$session());
                }
                o1 || (o1 = r1(26));
                var s1 = null != n1 ? n1.prototype : o1.prototype;
                for(var u1 in i1.prototype = Object.create(s1), i1.prototype.$__setSchema(t1), i1.schema = t1, i1.prototype.constructor = i1, i1.$isArraySubdocument = !0, i1.events = new a1, t1.methods)i1.prototype[u1] = t1.methods[u1];
                for(var c1 in t1.statics)i1[c1] = t1.statics[c1];
                for(var l1 in a1.prototype)i1[l1] = a1.prototype[l1];
                return i1.options = e1, i1;
            }
            /*!
 * Scopes paths selected in a query to this array.
 * Necessary for proper default application of subdocument values.
 *
 * @param {DocumentArrayPath} array - the array to scope `fields` paths
 * @param {Object|undefined} fields - the root fields selected in the query
 * @param {Boolean|undefined} init - if we are being created part of a query result
 */ function w1(t1, e1, r1) {
                if (r1 && e1) {
                    for(var n1, o1, i1, s1 = t1.path + ".", a1 = Object.keys(e1), u1 = a1.length, c1 = {}; u1--;)if ((o1 = a1[u1]).startsWith(s1)) {
                        if ("$" === (i1 = o1.substring(s1.length))) continue;
                        i1.startsWith("$.") && (i1 = i1.substr(2)), n1 || (n1 = !0), c1[i1] = e1[o1];
                    }
                    return n1 && c1 || void 0;
                }
            }
            g1.schemaName = "DocumentArray", g1.options = {
                castNonArrays: !0
            }, /*!
 * Inherits from ArrayType.
 */ g1.prototype = Object.create(i1.prototype), g1.prototype.constructor = g1, g1.prototype.OptionsConstructor = u1, g1.prototype.discriminator = function(t1, e1, r1) {
                "function" == typeof t1 && (t1 = d1.getFunctionName(t1));
                var n1 = b1(e1 = f1(this.casterConstructor, t1, e1, r1), null, this.casterConstructor);
                n1.baseCasterConstructor = this.casterConstructor;
                try {
                    Object.defineProperty(n1, "name", {
                        value: t1
                    });
                } catch (t1) {}
                return this.casterConstructor.discriminators[t1] = n1, this.casterConstructor.discriminators[t1];
            }, g1.prototype.doValidate = function(t1, e1, i1, s1) {
                n1 || (n1 = r1(18));
                var a1 = this;
                try {
                    c1.prototype.doValidate.call(this, t1, function(r1) {
                        if (r1) return r1.$isArrayValidatorError = !0, e1(r1);
                        var u1, c1 = t1 && t1.length;
                        if (!c1) return e1();
                        if (s1 && s1.updateValidator) return e1();
                        t1.isMongooseDocumentArray || (t1 = new n1(t1, a1.path, i1));
                        function f1(t1) {
                            null != t1 && ((u1 = t1) instanceof l1 || (u1.$isArrayValidatorError = !0)), --c1 || e1(u1);
                        }
                        for(var p1 = 0, h1 = c1; p1 < h1; ++p1){
                            var y1 = t1[p1];
                            if (null != y1) {
                                if (!(y1 instanceof o1)) {
                                    var d1 = m1(a1.casterConstructor, t1[p1]);
                                    y1 = t1[p1] = new d1(y1, t1, void 0, void 0, p1);
                                }
                                y1.$__validate(f1);
                            } else --c1 || e1(u1);
                        }
                    }, i1);
                } catch (t1) {
                    return t1.$isArrayValidatorError = !0, e1(t1);
                }
            }, g1.prototype.doValidateSync = function(t1, e1) {
                var r1 = c1.prototype.doValidateSync.call(this, t1, e1);
                if (null != r1) return r1.$isArrayValidatorError = !0, r1;
                var n1 = t1 && t1.length, i1 = null;
                if (n1) {
                    for(var s1 = 0, a1 = n1; s1 < a1; ++s1){
                        var u1 = t1[s1];
                        if (u1) {
                            if (!(u1 instanceof o1)) {
                                var l1 = m1(this.casterConstructor, t1[s1]);
                                u1 = t1[s1] = new l1(u1, t1, void 0, void 0, s1);
                            }
                            var f1 = u1.validateSync();
                            f1 && null == i1 && (i1 = f1);
                        }
                    }
                    return i1;
                }
            }, /*!
 * ignore
 */ g1.prototype.getDefault = function(t1) {
                var e1 = "function" == typeof this.defaultValue ? this.defaultValue.call(t1) : this.defaultValue;
                if (null == e1) return e1;
                n1 || (n1 = r1(18)), Array.isArray(e1) || (e1 = [
                    e1
                ]), e1 = new n1(e1, this.path, t1);
                for(var o1 = 0; o1 < e1.length; ++o1){
                    var i1 = new (m1(this.casterConstructor, e1[o1]))({}, e1, void 0, void 0, o1);
                    i1.init(e1[o1]), i1.isNew = !0, Object.assign(i1.$__.activePaths.default, i1.$__.activePaths.init), i1.$__.activePaths.init = {}, e1[o1] = i1;
                }
                return e1;
            }, g1.prototype.cast = function(t1, e1, i1, a1, u1) {
                if (n1 || (n1 = r1(18)), null != t1 && null != t1[_1] && t1 === a1) return t1;
                var c1, l1, f1 = {
                    transform: !1,
                    virtuals: !1
                };
                if (u1 = u1 || {}, !Array.isArray(t1)) {
                    if (!i1 && !g1.options.castNonArrays) throw new s1("DocumentArray", y1.inspect(t1), this.path, null, this);
                    return e1 && i1 && e1.markModified(this.path), this.cast([
                        t1
                    ], e1, i1, a1, u1);
                }
                t1 && t1.isMongooseDocumentArray || u1.skipDocumentArrayCast ? t1 && t1.isMongooseDocumentArray && (t1 = new n1(t1, this.path, e1)) : t1 = new n1(t1, this.path, e1), null != u1.arrayPath && (t1[_1] = u1.arrayPath);
                for(var p1 = t1.length, h1 = {
                    skipId: !0,
                    willInit: !0
                }, b1 = 0; b1 < p1; ++b1)if (t1[b1]) {
                    var O1 = m1(this.casterConstructor, t1[b1]);
                    if (!t1[b1].$__ || t1[b1] instanceof O1 && t1[b1][v1] === e1 || (t1[b1] = t1[b1].toObject({
                        transform: !1,
                        virtuals: t1[b1].schema === O1.schema
                    })), t1[b1] instanceof o1) null == t1[b1].__index && t1[b1].$setIndex(b1);
                    else if (null != t1[b1]) {
                        if (i1) e1 ? c1 || (c1 = w1(this, e1.$__.selected, i1)) : c1 = !0, l1 = new O1(null, t1, h1, c1, b1), t1[b1] = l1.init(t1[b1]);
                        else if (a1 && "function" == typeof a1.id && (l1 = a1.id(t1[b1]._id)), a1 && l1 && d1.deepEqual(l1.toObject(f1), t1[b1])) l1.set(t1[b1]), t1[b1] = l1;
                        else try {
                            l1 = new O1(t1[b1], t1, void 0, void 0, b1), t1[b1] = l1;
                        } catch (e1) {
                            var S1 = y1.inspect(t1[b1]);
                            throw new s1("embedded", S1, t1[_1], e1, this);
                        }
                    }
                }
                return t1;
            }, /*!
 * ignore
 */ g1.prototype.clone = function() {
                var t1 = Object.assign({}, this.options), e1 = new this.constructor(this.path, this.schema, t1, this.schemaOptions);
                return e1.validators = this.validators.slice(), void 0 !== this.requiredValidator && (e1.requiredValidator = this.requiredValidator), e1.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators), e1;
            }, g1.defaultOptions = {}, g1.set = c1.set, /*!
 * Module exports.
 */ t1.exports = g1;
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
            }
            function i1(t1, e1) {
                return (i1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function s1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = u1(t1);
                    if (e1) {
                        var o1 = u1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return a1(this, r1);
                };
            }
            function a1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function u1(t1) {
                return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var c1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && i1(t1, e1);
                }(r1, t1);
                var e1 = s1(r1);
                function r1() {
                    return o1(this, r1), e1.apply(this, arguments);
                }
                return r1;
            }(r1(9)), l1 = r1(10);
            Object.defineProperty(c1.prototype, "enum", l1), Object.defineProperty(c1.prototype, "enum", l1), /*!
 * ignore
 */ t1.exports = c1;
        },
        function(t1, e1, r1) {
            "use strict";
            t1.exports = function t1(e1) {
                if (!Array.isArray(e1)) return {
                    min: 0,
                    max: 0,
                    containsNonArrayItem: !0
                };
                if (0 === e1.length) return {
                    min: 1,
                    max: 1,
                    containsNonArrayItem: !1
                };
                for(var r1 = t1(e1[0]), n1 = 1; n1 < e1.length; ++n1){
                    var o1 = t1(e1[n1]);
                    o1.min < r1.min && (r1.min = o1.min), o1.max > r1.max && (r1.max = o1.max), r1.containsNonArrayItem = r1.containsNonArrayItem || o1.containsNonArrayItem;
                }
                return r1.min = r1.min + 1, r1.max = r1.max + 1, r1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1, e1) {
                var r1;
                if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                    if (Array.isArray(t1) || (r1 = function(t1, e1) {
                        if (!t1) return;
                        if ("string" == typeof t1) return o1(t1, e1);
                        var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                        "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                        if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                        if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return o1(t1, e1);
                    }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                        r1 && (t1 = r1);
                        var n1 = 0, i1 = function() {};
                        return {
                            s: i1,
                            n: function() {
                                return n1 >= t1.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t1[n1++]
                                };
                            },
                            e: function(t1) {
                                throw t1;
                            },
                            f: i1
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var s1, a1 = !0, u1 = !1;
                return {
                    s: function() {
                        r1 = t1[Symbol.iterator]();
                    },
                    n: function() {
                        var t1 = r1.next();
                        return a1 = t1.done, t1;
                    },
                    e: function(t1) {
                        u1 = !0, s1 = t1;
                    },
                    f: function() {
                        try {
                            a1 || null == r1.return || r1.return();
                        } finally{
                            if (u1) throw s1;
                        }
                    }
                };
            }
            function o1(t1, e1) {
                (null == e1 || e1 > t1.length) && (e1 = t1.length);
                for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                return n1;
            }
            function i1(t1) {
                return (i1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            var s1 = r1(12), a1 = r1(32), u1 = r1(54), c1 = r1(155), l1 = r1(3), f1 = r1(156), p1 = r1(80), h1 = r1(4), y1 = r1(21), d1 = r1(29), m1 = [
                "Polygon",
                "MultiPolygon"
            ];
            function _1(t1, e1, r1) {
                if (Array.isArray(t1)) t1.forEach(function(n1, o1) {
                    if (Array.isArray(n1) || y1(n1)) return _1(n1, e1, r1);
                    t1[o1] = e1.castForQueryWrapper({
                        val: n1,
                        context: r1
                    });
                });
                else for(var n1 = Object.keys(t1), o1 = n1.length; o1--;){
                    var i1 = n1[o1], s1 = t1[i1];
                    Array.isArray(s1) || y1(s1) ? (_1(s1, e1, r1), t1[i1] = s1) : t1[i1] = e1.castForQuery({
                        val: s1,
                        context: r1
                    });
                }
            }
            t1.exports = function t1(e1, r1, o1, v1) {
                if (Array.isArray(r1)) throw new Error("Query filter must be an object, got an array ", h1.inspect(r1));
                if (null == r1) return r1;
                r1.hasOwnProperty("_bsontype") && "ObjectID" !== r1._bsontype && delete r1._bsontype, null != e1 && null != e1.discriminators && null != r1[e1.options.discriminatorKey] && (e1 = f1(e1, r1[e1.options.discriminatorKey]) || e1);
                var g1, b1, w1, O1, S1, A1, j1 = Object.keys(r1), E1 = j1.length;
                for(o1 = o1 || {}; E1--;)if (A1 = r1[O1 = j1[E1]], "$or" === O1 || "$nor" === O1 || "$and" === O1) {
                    if (!Array.isArray(A1)) throw new s1("Array", A1, O1);
                    for(var $1 = 0; $1 < A1.length; ++$1){
                        if (null == A1[$1] || "object" !== i1(A1[$1])) throw new s1("Object", A1[$1], O1 + "." + $1);
                        A1[$1] = t1(e1, A1[$1], o1, v1);
                    }
                } else {
                    if ("$where" === O1) {
                        if ("string" !== (S1 = i1(A1)) && "function" !== S1) throw new Error("Must have a string or function for $where");
                        "function" === S1 && (r1[O1] = A1.toString());
                        continue;
                    }
                    if ("$elemMatch" === O1) A1 = t1(e1, A1, o1, v1);
                    else if ("$text" === O1) A1 = c1(A1, O1);
                    else {
                        if (!e1) continue;
                        if (!(b1 = e1.path(O1))) for(var P1 = O1.split("."), x1 = P1.length; x1--;){
                            var N1 = P1.slice(0, x1).join("."), T1 = P1.slice(x1).join("."), k1 = e1.path(N1), C1 = l1(k1, "schema.options.discriminatorKey");
                            if (null != k1 && null != l1(k1, "schema.discriminators") && null != C1 && T1 !== C1) {
                                var D1 = l1(r1, N1 + "." + C1);
                                null != D1 && (b1 = k1.schema.discriminators[D1].path(T1));
                            }
                        }
                        if (b1) {
                            if (null == A1) continue;
                            if ("Object" === A1.constructor.name) {
                                if (Object.keys(A1).some(p1)) for(var R1 = Object.keys(A1), B1 = void 0, M1 = R1.length; M1--;)if (w1 = A1[B1 = R1[M1]], "$not" === B1) {
                                    if (w1 && b1 && !b1.caster) {
                                        if ((g1 = Object.keys(w1)).length && p1(g1[0])) for(var I1 in w1)w1[I1] = b1.castForQueryWrapper({
                                            $conditional: I1,
                                            val: w1[I1],
                                            context: v1
                                        });
                                        else A1[B1] = b1.castForQueryWrapper({
                                            $conditional: B1,
                                            val: w1,
                                            context: v1
                                        });
                                        continue;
                                    }
                                    t1(b1.caster ? b1.caster.schema : e1, w1, o1, v1);
                                } else A1[B1] = b1.castForQueryWrapper({
                                    $conditional: B1,
                                    val: w1,
                                    context: v1
                                });
                                else r1[O1] = b1.castForQueryWrapper({
                                    val: A1,
                                    context: v1
                                });
                            } else if (Array.isArray(A1) && -1 === [
                                "Buffer",
                                "Array"
                            ].indexOf(b1.instance)) {
                                var F1, L1 = [], U1 = n1(A1);
                                try {
                                    for(U1.s(); !(F1 = U1.n()).done;){
                                        var V1 = F1.value;
                                        L1.push(b1.castForQueryWrapper({
                                            val: V1,
                                            context: v1
                                        }));
                                    }
                                } catch (t1) {
                                    U1.e(t1);
                                } finally{
                                    U1.f();
                                }
                                r1[O1] = {
                                    $in: L1
                                };
                            } else r1[O1] = b1.castForQueryWrapper({
                                val: A1,
                                context: v1
                            });
                        } else {
                            for(var q1 = O1.split("."), W1 = q1.length, H1 = void 0, Y1 = void 0, K1 = void 0; W1-- && (H1 = q1.slice(0, W1).join("."), !(b1 = e1.path(H1))););
                            if (b1) {
                                b1.caster && b1.caster.schema ? ((K1 = {})[Y1 = q1.slice(W1).join(".")] = A1, r1[O1] = t1(b1.caster.schema, K1, o1, v1)[Y1]) : r1[O1] = A1;
                                continue;
                            }
                            if (y1(A1)) {
                                var z1 = "";
                                if (A1.$near ? z1 = "$near" : A1.$nearSphere ? z1 = "$nearSphere" : A1.$within ? z1 = "$within" : A1.$geoIntersects ? z1 = "$geoIntersects" : A1.$geoWithin && (z1 = "$geoWithin"), z1) {
                                    var Q1 = new u1.Number("__QueryCasting__"), J1 = A1[z1];
                                    if (null != A1.$maxDistance && (A1.$maxDistance = Q1.castForQueryWrapper({
                                        val: A1.$maxDistance,
                                        context: v1
                                    })), null != A1.$minDistance && (A1.$minDistance = Q1.castForQueryWrapper({
                                        val: A1.$minDistance,
                                        context: v1
                                    })), "$within" === z1) {
                                        var G1 = J1.$center || J1.$centerSphere || J1.$box || J1.$polygon;
                                        if (!G1) throw new Error("Bad $within parameter: " + JSON.stringify(A1));
                                        J1 = G1;
                                    } else if ("$near" === z1 && "string" == typeof J1.type && Array.isArray(J1.coordinates)) J1 = J1.coordinates;
                                    else if (("$near" === z1 || "$nearSphere" === z1 || "$geoIntersects" === z1) && J1.$geometry && "string" == typeof J1.$geometry.type && Array.isArray(J1.$geometry.coordinates)) null != J1.$maxDistance && (J1.$maxDistance = Q1.castForQueryWrapper({
                                        val: J1.$maxDistance,
                                        context: v1
                                    })), null != J1.$minDistance && (J1.$minDistance = Q1.castForQueryWrapper({
                                        val: J1.$minDistance,
                                        context: v1
                                    })), d1(J1.$geometry) && (J1.$geometry = J1.$geometry.toObject({
                                        transform: !1,
                                        virtuals: !1
                                    })), J1 = J1.$geometry.coordinates;
                                    else if ("$geoWithin" === z1) {
                                        if (J1.$geometry) {
                                            d1(J1.$geometry) && (J1.$geometry = J1.$geometry.toObject({
                                                virtuals: !1
                                            }));
                                            var X1 = J1.$geometry.type;
                                            if (-1 === m1.indexOf(X1)) throw new Error('Invalid geoJSON type for $geoWithin "' + X1 + '", must be "Polygon" or "MultiPolygon"');
                                            J1 = J1.$geometry.coordinates;
                                        } else J1 = J1.$box || J1.$polygon || J1.$center || J1.$centerSphere, d1(J1) && (J1 = J1.toObject({
                                            virtuals: !1
                                        }));
                                    }
                                    _1(J1, Q1, v1);
                                    continue;
                                }
                            }
                            if (e1.nested[O1]) continue;
                            if (o1.upsert && o1.strict) {
                                if ("throw" === o1.strict) throw new a1(O1);
                                throw new a1(O1, 'Path "' + O1 + '" is not in schema, strict mode is `true`, and upsert is `true`.');
                            }
                            if ("throw" === o1.strictQuery) throw new a1(O1, 'Path "' + O1 + "\" is not in schema and strictQuery is 'throw'.");
                            o1.strictQuery && delete r1[O1];
                        }
                    }
                }
                return r1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            var o1 = r1(12), i1 = r1(49), s1 = r1(77);
            /*!
 * Casts val to an object suitable for `$text`. Throws an error if the object
 * can't be casted.
 *
 * @param {Any} val value to cast
 * @param {String} [path] path to associate with any errors that occured
 * @return {Object} casted object
 * @see https://docs.mongodb.com/manual/reference/operator/query/text/
 * @api private
 */ t1.exports = function(t1, e1) {
                if (null == t1 || "object" !== n1(t1)) throw new o1("$text", t1, e1);
                return null != t1.$search && (t1.$search = s1(t1.$search, e1 + ".$search")), null != t1.$language && (t1.$language = s1(t1.$language, e1 + ".$language")), null != t1.$caseSensitive && (t1.$caseSensitive = i1(t1.$caseSensitive, e1 + ".$castSensitive")), null != t1.$diacriticSensitive && (t1.$diacriticSensitive = i1(t1.$diacriticSensitive, e1 + ".$diacriticSensitive")), t1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
* returns discriminator by discriminatorMapping.value
*
* @param {Schema} schema
* @param {string} value
*/ t1.exports = function(t1, e1) {
                if (null == t1 || null == t1.discriminators) return null;
                for(var r1 = 0, n1 = Object.keys(t1.discriminators); r1 < n1.length; r1++){
                    var o1 = n1[r1], i1 = t1.discriminators[o1];
                    if (null != i1.discriminatorMapping && i1.discriminatorMapping.value === e1) return i1;
                }
                return null;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
            }
            function i1(t1, e1) {
                return (i1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function s1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = u1(t1);
                    if (e1) {
                        var o1 = u1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return a1(this, r1);
                };
            }
            function a1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function u1(t1) {
                return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var c1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && i1(t1, e1);
                }(r1, t1);
                var e1 = s1(r1);
                function r1() {
                    return o1(this, r1), e1.apply(this, arguments);
                }
                return r1;
            }(r1(9)), l1 = r1(10);
            Object.defineProperty(c1.prototype, "excludeIndexes", l1), Object.defineProperty(c1.prototype, "_id", l1), /*!
 * ignore
 */ t1.exports = c1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            var o1, i1 = r1(12), s1 = r1(19).EventEmitter, a1 = r1(73), u1 = r1(159), c1 = r1(7), l1 = r1(48), f1 = r1(33).castToNumber, p1 = r1(90), h1 = r1(81), y1 = r1(3), d1 = r1(92), m1 = r1(91), _1 = r1(17).internalToObjectOptions;
            function v1(t1, e1, r1) {
                t1 = m1(t1, r1), this.caster = g1(t1), this.caster.path = e1, this.caster.prototype.$basePath = e1, this.schema = t1, this.$isSingleNested = !0, c1.call(this, e1, r1, "Embedded");
            }
            /*!
 * ignore
 */ /*!
 * ignore
 */ function g1(t1, e1) {
                o1 || (o1 = r1(89));
                var n1 = function(t1, e1, r1) {
                    var n1 = this;
                    this.$parent = r1, o1.apply(this, arguments), this.$session(this.ownerDocument().$session()), r1 && (r1.on("save", function() {
                        n1.emit("save", n1), n1.constructor.emit("save", n1);
                    }), r1.on("isNew", function(t1) {
                        n1.isNew = t1, n1.emit("isNew", t1), n1.constructor.emit("isNew", t1);
                    }));
                }, i1 = null != e1 ? e1.prototype : o1.prototype;
                for(var a1 in (n1.prototype = Object.create(i1)).$__setSchema(t1), n1.prototype.constructor = n1, n1.schema = t1, n1.$isSingleNested = !0, n1.events = new s1, n1.prototype.toBSON = function() {
                    return this.toObject(_1);
                }, t1.methods)n1.prototype[a1] = t1.methods[a1];
                for(var u1 in t1.statics)n1[u1] = t1.statics[u1];
                for(var c1 in s1.prototype)n1[c1] = s1.prototype[c1];
                return n1;
            }
            /*!
 * Special case for when users use a common location schema to represent
 * locations for use with $geoWithin.
 * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/
 *
 * @param {Object} val
 * @api private
 */ t1.exports = v1, v1.prototype = Object.create(c1.prototype), v1.prototype.constructor = v1, v1.prototype.OptionsConstructor = u1, v1.prototype.$conditionalHandlers.$geoWithin = function(t1) {
                return {
                    $geometry: this.castForQuery(t1.$geometry)
                };
            }, /*!
 * ignore
 */ v1.prototype.$conditionalHandlers.$near = v1.prototype.$conditionalHandlers.$nearSphere = h1.cast$near, v1.prototype.$conditionalHandlers.$within = v1.prototype.$conditionalHandlers.$geoWithin = h1.cast$within, v1.prototype.$conditionalHandlers.$geoIntersects = h1.cast$geoIntersects, v1.prototype.$conditionalHandlers.$minDistance = f1, v1.prototype.$conditionalHandlers.$maxDistance = f1, v1.prototype.$conditionalHandlers.$exists = l1, v1.prototype.cast = function(t1, e1, r1, o1) {
                if (t1 && t1.$isSingleNested && t1.parent === e1) return t1;
                if (null != t1 && ("object" !== n1(t1) || Array.isArray(t1))) throw new a1(this.path, t1);
                var i1, s1 = d1(this.caster, t1), u1 = y1(e1, "$__.selected", {}), c1 = this.path, l1 = Object.keys(u1).reduce(function(t1, e1) {
                    return e1.startsWith(c1 + ".") && (t1[e1.substr(c1.length + 1)] = u1[e1]), t1;
                }, {});
                return r1 ? ((i1 = new s1(void 0, l1, e1)).init(t1), i1) : 0 === Object.keys(t1).length ? new s1({}, l1, e1, void 0, {
                    priorDoc: o1
                }) : new s1(t1, l1, e1, void 0, {
                    priorDoc: o1
                });
            }, v1.prototype.castForQuery = function(t1, e1, r1) {
                var n1;
                if (2 === arguments.length) {
                    if (!(n1 = this.$conditionalHandlers[t1])) throw new Error("Can't use " + t1);
                    return n1.call(this, e1);
                }
                if (null == (e1 = t1)) return e1;
                this.options.runSetters && (e1 = this._applySetters(e1));
                var o1 = d1(this.caster, e1), s1 = null != r1 && null != r1.strict ? r1.strict : void 0;
                try {
                    e1 = new o1(e1, s1);
                } catch (t1) {
                    if (!(t1 instanceof i1)) throw new i1("Embedded", e1, this.path, t1, this);
                    throw t1;
                }
                return e1;
            }, v1.prototype.doValidate = function(t1, e1, r1, n1) {
                var o1 = d1(this.caster, t1);
                if (n1 && n1.skipSchemaValidators) return t1 instanceof o1 || (t1 = new o1(t1, null, r1)), t1.validate(e1);
                c1.prototype.doValidate.call(this, t1, function(r1) {
                    return r1 ? e1(r1) : t1 ? void t1.validate(e1) : e1(null);
                }, r1, n1);
            }, v1.prototype.doValidateSync = function(t1, e1, r1) {
                if (!r1 || !r1.skipSchemaValidators) {
                    var n1 = c1.prototype.doValidateSync.call(this, t1, e1);
                    if (n1) return n1;
                }
                if (t1) return t1.validateSync();
            }, v1.prototype.discriminator = function(t1, e1, r1) {
                return e1 = p1(this.caster, t1, e1, r1), this.caster.discriminators[t1] = g1(e1, this.caster), this.caster.discriminators[t1];
            }, v1.defaultOptions = {}, v1.set = c1.set, /*!
 * ignore
 */ v1.prototype.clone = function() {
                var t1 = Object.assign({}, this.options), e1 = new this.constructor(this.schema, this.path, t1);
                return e1.validators = this.validators.slice(), void 0 !== this.requiredValidator && (e1.requiredValidator = this.requiredValidator), e1.caster.discriminators = Object.assign({}, this.caster.discriminators), e1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
            }
            function i1(t1, e1) {
                return (i1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function s1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = u1(t1);
                    if (e1) {
                        var o1 = u1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return a1(this, r1);
                };
            }
            function a1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function u1(t1) {
                return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var c1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && i1(t1, e1);
                }(r1, t1);
                var e1 = s1(r1);
                function r1() {
                    return o1(this, r1), e1.apply(this, arguments);
                }
                return r1;
            }(r1(9)), l1 = r1(10);
            Object.defineProperty(c1.prototype, "_id", l1), t1.exports = c1;
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                /*!
 * Module dependencies.
 */ function n1(t1) {
                    return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                var o1, i1 = r1(85), s1 = r1(161), a1 = r1(7), u1 = r1(79), c1 = r1(2), l1 = r1(0).populateModelSymbol, f1 = i1.Binary, p1 = a1.CastError;
                function h1(t1, e1) {
                    a1.call(this, t1, e1, "Buffer");
                }
                /*!
 * ignore
 */ function y1(t1) {
                    return this.castForQuery(t1);
                }
                h1.schemaName = "Buffer", h1.defaultOptions = {}, /*!
 * Inherits from SchemaType.
 */ h1.prototype = Object.create(a1.prototype), h1.prototype.constructor = h1, h1.prototype.OptionsConstructor = s1, /*!
 * ignore
 */ h1._checkRequired = function(t1) {
                    return !(!t1 || !t1.length);
                }, h1.set = a1.set, h1.checkRequired = a1.checkRequired, h1.prototype.checkRequired = function(t1, e1) {
                    return a1._isRef(this, t1, e1, !0) ? !!t1 : this.constructor._checkRequired(t1);
                }, h1.prototype.cast = function(t1, s1, u1) {
                    var h1;
                    if (a1._isRef(this, t1, s1, u1)) {
                        if (null == t1) return t1;
                        if (o1 || (o1 = r1(6)), t1 instanceof o1) return t1.$__.wasPopulated = !0, t1;
                        if (e1.isBuffer(t1)) return t1;
                        if (!c1.isObject(t1)) throw new p1("Buffer", t1, this.path, null, this);
                        var y1 = s1.$__fullPath(this.path);
                        return (h1 = new ((s1.ownerDocument ? s1.ownerDocument() : s1).populated(y1, !0)).options[l1](t1)).$__.wasPopulated = !0, h1;
                    }
                    if (t1 && t1._id && (t1 = t1._id), t1 && t1.isMongooseBuffer) return t1;
                    if (e1.isBuffer(t1)) return t1 && t1.isMongooseBuffer || (t1 = new i1(t1, [
                        this.path,
                        s1
                    ]), null != this.options.subtype && (t1._subtype = this.options.subtype)), t1;
                    if (t1 instanceof f1) {
                        if (h1 = new i1(t1.value(!0), [
                            this.path,
                            s1
                        ]), "number" != typeof t1.sub_type) throw new p1("Buffer", t1, this.path, null, this);
                        return h1._subtype = t1.sub_type, h1;
                    }
                    if (null === t1) return t1;
                    var d1 = n1(t1);
                    if ("string" === d1 || "number" === d1 || Array.isArray(t1) || "object" === d1 && "Buffer" === t1.type && Array.isArray(t1.data)) return "number" === d1 && (t1 = [
                        t1
                    ]), h1 = new i1(t1, [
                        this.path,
                        s1
                    ]), null != this.options.subtype && (h1._subtype = this.options.subtype), h1;
                    throw new p1("Buffer", t1, this.path, null, this);
                }, h1.prototype.subtype = function(t1) {
                    return this.options.subtype = t1, this;
                }, h1.prototype.$conditionalHandlers = c1.options(a1.prototype.$conditionalHandlers, {
                    $bitsAllClear: u1,
                    $bitsAnyClear: u1,
                    $bitsAllSet: u1,
                    $bitsAnySet: u1,
                    $gt: y1,
                    $gte: y1,
                    $lt: y1,
                    $lte: y1
                }), h1.prototype.castForQuery = function(t1, e1) {
                    var r1;
                    if (2 === arguments.length) {
                        if (!(r1 = this.$conditionalHandlers[t1])) throw new Error("Can't use " + t1 + " with Buffer.");
                        return r1.call(this, e1);
                    }
                    e1 = t1;
                    var n1 = this._castForQuery(e1);
                    return n1 ? n1.toObject({
                        transform: !1,
                        virtuals: !1
                    }) : n1;
                }, /*!
 * Module exports.
 */ t1.exports = h1;
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
            }
            function i1(t1, e1) {
                return (i1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function s1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = u1(t1);
                    if (e1) {
                        var o1 = u1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return a1(this, r1);
                };
            }
            function a1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function u1(t1) {
                return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var c1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && i1(t1, e1);
                }(r1, t1);
                var e1 = s1(r1);
                function r1() {
                    return o1(this, r1), e1.apply(this, arguments);
                }
                return r1;
            }(r1(9)), l1 = r1(10);
            Object.defineProperty(c1.prototype, "subtype", l1), /*!
 * ignore
 */ t1.exports = c1;
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module requirements.
 */ var n1 = r1(5), o1 = r1(163), i1 = r1(7), s1 = r1(164), a1 = r1(2), u1 = i1.CastError;
            function c1(t1, e1) {
                i1.call(this, t1, e1, "Date");
            }
            /*!
 * Date Query casting.
 *
 * @api private
 */ function l1(t1) {
                return this.cast(t1);
            }
            c1.schemaName = "Date", c1.defaultOptions = {}, /*!
 * Inherits from SchemaType.
 */ c1.prototype = Object.create(i1.prototype), c1.prototype.constructor = c1, c1.prototype.OptionsConstructor = o1, /*!
 * ignore
 */ c1._cast = s1, c1.set = i1.set, c1.cast = function(t1) {
                return 0 === arguments.length || (!1 === t1 && (t1 = function(t1) {
                    if (null != t1 && !(t1 instanceof Date)) throw new Error;
                    return t1;
                }), this._cast = t1), this._cast;
            }, c1.prototype.expires = function(t1) {
                return this._index && "Object" === this._index.constructor.name || (this._index = {}), this._index.expires = t1, a1.expires(this._index), this;
            }, /*!
 * ignore
 */ c1._checkRequired = function(t1) {
                return t1 instanceof Date;
            }, c1.checkRequired = i1.checkRequired, c1.prototype.checkRequired = function(t1, e1) {
                return i1._isRef(this, t1, e1, !0) ? !!t1 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : c1.checkRequired())(t1);
            }, c1.prototype.min = function(t1, e1) {
                if (this.minValidator && (this.validators = this.validators.filter(function(t1) {
                    return t1.validator !== this.minValidator;
                }, this)), t1) {
                    var r1 = e1 || n1.messages.Date.min;
                    "string" == typeof r1 && (r1 = r1.replace(/{MIN}/, t1 === Date.now ? "Date.now()" : t1.toString()));
                    var o1 = this;
                    this.validators.push({
                        validator: this.minValidator = function(e1) {
                            var r1 = t1;
                            "function" == typeof t1 && t1 !== Date.now && (r1 = r1.call(this));
                            var n1 = r1 === Date.now ? r1() : o1.cast(r1);
                            return null === e1 || e1.valueOf() >= n1.valueOf();
                        },
                        message: r1,
                        type: "min",
                        min: t1
                    });
                }
                return this;
            }, c1.prototype.max = function(t1, e1) {
                if (this.maxValidator && (this.validators = this.validators.filter(function(t1) {
                    return t1.validator !== this.maxValidator;
                }, this)), t1) {
                    var r1 = e1 || n1.messages.Date.max;
                    "string" == typeof r1 && (r1 = r1.replace(/{MAX}/, t1 === Date.now ? "Date.now()" : t1.toString()));
                    var o1 = this;
                    this.validators.push({
                        validator: this.maxValidator = function(e1) {
                            var r1 = t1;
                            "function" == typeof r1 && r1 !== Date.now && (r1 = r1.call(this));
                            var n1 = r1 === Date.now ? r1() : o1.cast(r1);
                            return null === e1 || e1.valueOf() <= n1.valueOf();
                        },
                        message: r1,
                        type: "max",
                        max: t1
                    });
                }
                return this;
            }, c1.prototype.cast = function(t1) {
                var e1 = "function" == typeof this.constructor.cast ? this.constructor.cast() : c1.cast();
                try {
                    return e1(t1);
                } catch (e1) {
                    throw new u1("date", t1, this.path, e1, this);
                }
            }, c1.prototype.$conditionalHandlers = a1.options(i1.prototype.$conditionalHandlers, {
                $gt: l1,
                $gte: l1,
                $lt: l1,
                $lte: l1
            }), c1.prototype.castForQuery = function(t1, e1) {
                if (2 !== arguments.length) return this._castForQuery(t1);
                var r1 = this.$conditionalHandlers[t1];
                if (!r1) throw new Error("Can't use " + t1 + " with Date.");
                return r1.call(this, e1);
            }, /*!
 * Module exports.
 */ t1.exports = c1;
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
            }
            function i1(t1, e1) {
                return (i1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function s1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = u1(t1);
                    if (e1) {
                        var o1 = u1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return a1(this, r1);
                };
            }
            function a1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function u1(t1) {
                return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var c1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && i1(t1, e1);
                }(r1, t1);
                var e1 = s1(r1);
                function r1() {
                    return o1(this, r1), e1.apply(this, arguments);
                }
                return r1;
            }(r1(9)), l1 = r1(10);
            Object.defineProperty(c1.prototype, "min", l1), Object.defineProperty(c1.prototype, "max", l1), Object.defineProperty(c1.prototype, "expires", l1), /*!
 * ignore
 */ t1.exports = c1;
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(22);
            t1.exports = function(t1) {
                var e1;
                return null == t1 || "" === t1 ? null : t1 instanceof Date ? (n1.ok(!isNaN(t1.valueOf())), t1) : (n1.ok("boolean" != typeof t1), e1 = t1 instanceof Number || "number" == typeof t1 ? new Date(t1) : "string" == typeof t1 && !isNaN(Number(t1)) && (Number(t1) >= 275761 || Number(t1) < -271820) ? new Date(Number(t1)) : "function" == typeof t1.valueOf ? new Date(t1.valueOf()) : new Date(t1), isNaN(e1.valueOf()) ? void n1.ok(!1) : e1);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                /*!
 * Module dependencies.
 */ var n1, o1 = r1(166), i1 = r1(7), s1 = r1(86), a1 = r1(13), u1 = r1(2), c1 = r1(0).populateModelSymbol, l1 = i1.CastError;
                function f1(t1, e1) {
                    var r1 = "string" == typeof t1 && 24 === t1.length && /^[a-f0-9]+$/i.test(t1), n1 = e1 && e1.suppressWarning;
                    !r1 && void 0 !== t1 || n1 || (console.warn("mongoose: To create a new ObjectId please try `Mongoose.Types.ObjectId` instead of using `Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if you're trying to create a hex char path in your schema."), console.trace()), i1.call(this, t1, e1, "ObjectID");
                }
                /*!
 * ignore
 */ function p1(t1) {
                    return this.cast(t1);
                }
                /*!
 * ignore
 */ function h1() {
                    return new a1;
                }
                function y1(t1) {
                    if (n1 || (n1 = r1(6)), this instanceof n1) {
                        if (void 0 === t1) {
                            var e1 = new a1;
                            return this.$__._id = e1, e1;
                        }
                        this.$__._id = t1;
                    }
                    return t1;
                }
                /*!
 * Module exports.
 */ f1.schemaName = "ObjectId", f1.defaultOptions = {}, /*!
 * Inherits from SchemaType.
 */ f1.prototype = Object.create(i1.prototype), f1.prototype.constructor = f1, f1.prototype.OptionsConstructor = o1, f1.get = i1.get, f1.set = i1.set, f1.prototype.auto = function(t1) {
                    return t1 && (this.default(h1), this.set(y1)), this;
                }, /*!
 * ignore
 */ f1._checkRequired = function(t1) {
                    return t1 instanceof a1;
                }, /*!
 * ignore
 */ f1._cast = s1, f1.cast = function(t1) {
                    return 0 === arguments.length || (!1 === t1 && (t1 = function(t1) {
                        if (!(t1 instanceof a1)) throw new Error(t1 + " is not an instance of ObjectId");
                        return t1;
                    }), this._cast = t1), this._cast;
                }, f1.checkRequired = i1.checkRequired, f1.prototype.checkRequired = function(t1, e1) {
                    return i1._isRef(this, t1, e1, !0) ? !!t1 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : f1.checkRequired())(t1);
                }, f1.prototype.cast = function(t1, o1, s1) {
                    if (i1._isRef(this, t1, o1, s1)) {
                        if (null == t1) return t1;
                        if (n1 || (n1 = r1(6)), t1 instanceof n1) return t1.$__.wasPopulated = !0, t1;
                        if (t1 instanceof a1) return t1;
                        if ("objectid" === (t1.constructor.name || "").toLowerCase()) return new a1(t1.toHexString());
                        if (e1.isBuffer(t1) || !u1.isObject(t1)) throw new l1("ObjectId", t1, this.path, null, this);
                        var p1 = o1.$__fullPath(this.path), h1 = (o1.ownerDocument ? o1.ownerDocument() : o1).populated(p1, !0), y1 = t1;
                        return o1.$__.populated && o1.$__.populated[p1] && o1.$__.populated[p1].options && o1.$__.populated[p1].options.options && o1.$__.populated[p1].options.options.lean || ((y1 = new h1.options[c1](t1)).$__.wasPopulated = !0), y1;
                    }
                    var d1 = "function" == typeof this.constructor.cast ? this.constructor.cast() : f1.cast();
                    try {
                        return d1(t1);
                    } catch (e1) {
                        throw new l1("ObjectId", t1, this.path, e1, this);
                    }
                }, f1.prototype.$conditionalHandlers = u1.options(i1.prototype.$conditionalHandlers, {
                    $gt: p1,
                    $gte: p1,
                    $lt: p1,
                    $lte: p1
                }), h1.$runBeforeSetters = !0, t1.exports = f1;
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
            }
            function i1(t1, e1) {
                return (i1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function s1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = u1(t1);
                    if (e1) {
                        var o1 = u1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return a1(this, r1);
                };
            }
            function a1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function u1(t1) {
                return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var c1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && i1(t1, e1);
                }(r1, t1);
                var e1 = s1(r1);
                function r1() {
                    return o1(this, r1), e1.apply(this, arguments);
                }
                return r1;
            }(r1(9)), l1 = r1(10);
            Object.defineProperty(c1.prototype, "auto", l1), /*!
 * ignore
 */ t1.exports = c1;
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                /*!
 * Module dependencies.
 */ var n1, o1 = r1(7), i1 = o1.CastError, s1 = r1(20), a1 = r1(168), u1 = r1(2), c1 = r1(0).populateModelSymbol;
                function l1(t1, e1) {
                    o1.call(this, t1, e1, "Decimal128");
                }
                /*!
 * ignore
 */ function f1(t1) {
                    return this.cast(t1);
                }
                l1.schemaName = "Decimal128", l1.defaultOptions = {}, /*!
 * Inherits from SchemaType.
 */ l1.prototype = Object.create(o1.prototype), l1.prototype.constructor = l1, /*!
 * ignore
 */ l1._cast = a1, l1.set = o1.set, l1.cast = function(t1) {
                    return 0 === arguments.length || (!1 === t1 && (t1 = function(t1) {
                        if (null != t1 && !(t1 instanceof s1)) throw new Error;
                        return t1;
                    }), this._cast = t1), this._cast;
                }, /*!
 * ignore
 */ l1._checkRequired = function(t1) {
                    return t1 instanceof s1;
                }, l1.checkRequired = o1.checkRequired, l1.prototype.checkRequired = function(t1, e1) {
                    return o1._isRef(this, t1, e1, !0) ? !!t1 : ("function" == typeof this.constructor.checkRequired ? this.constructor.checkRequired() : l1.checkRequired())(t1);
                }, l1.prototype.cast = function(t1, a1, f1) {
                    if (o1._isRef(this, t1, a1, f1)) {
                        if (null == t1) return t1;
                        if (n1 || (n1 = r1(6)), t1 instanceof n1) return t1.$__.wasPopulated = !0, t1;
                        if (t1 instanceof s1) return t1;
                        if (e1.isBuffer(t1) || !u1.isObject(t1)) throw new i1("Decimal128", t1, this.path, null, this);
                        var p1 = a1.$__fullPath(this.path), h1 = (a1.ownerDocument ? a1.ownerDocument() : a1).populated(p1, !0), y1 = t1;
                        return a1.$__.populated && a1.$__.populated[p1] && a1.$__.populated[p1].options && a1.$__.populated[p1].options.options && a1.$__.populated[p1].options.options.lean || ((y1 = new h1.options[c1](t1)).$__.wasPopulated = !0), y1;
                    }
                    var d1 = "function" == typeof this.constructor.cast ? this.constructor.cast() : l1.cast();
                    try {
                        return d1(t1);
                    } catch (e1) {
                        throw new i1("Decimal128", t1, this.path, e1, this);
                    }
                }, l1.prototype.$conditionalHandlers = u1.options(o1.prototype.$conditionalHandlers, {
                    $gt: f1,
                    $gte: f1,
                    $lt: f1,
                    $lte: f1
                }), /*!
 * Module exports.
 */ t1.exports = l1;
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                function n1(t1) {
                    return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                var o1 = r1(20), i1 = r1(22);
                t1.exports = function(t1) {
                    return null == t1 ? t1 : "object" === n1(t1) && "string" == typeof t1.$numberDecimal ? o1.fromString(t1.$numberDecimal) : t1 instanceof o1 ? t1 : "string" == typeof t1 ? o1.fromString(t1) : e1.isBuffer(t1) ? new o1(t1) : "number" == typeof t1 ? o1.fromString(String(t1)) : "function" == typeof t1.valueOf && "string" == typeof t1.valueOf() ? o1.fromString(t1.valueOf()) : void i1.ok(!1);
                };
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            (function(e1) {
                /*!
 * ignore
 */ function n1(t1) {
                    return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                function o1(t1, e1) {
                    var r1;
                    if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                        if (Array.isArray(t1) || (r1 = function(t1, e1) {
                            if (!t1) return;
                            if ("string" == typeof t1) return i1(t1, e1);
                            var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                            "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                            if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                            if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return i1(t1, e1);
                        }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                            r1 && (t1 = r1);
                            var n1 = 0, o1 = function() {};
                            return {
                                s: o1,
                                n: function() {
                                    return n1 >= t1.length ? {
                                        done: !0
                                    } : {
                                        done: !1,
                                        value: t1[n1++]
                                    };
                                },
                                e: function(t1) {
                                    throw t1;
                                },
                                f: o1
                            };
                        }
                        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }
                    var s1, a1 = !0, u1 = !1;
                    return {
                        s: function() {
                            r1 = t1[Symbol.iterator]();
                        },
                        n: function() {
                            var t1 = r1.next();
                            return a1 = t1.done, t1;
                        },
                        e: function(t1) {
                            u1 = !0, s1 = t1;
                        },
                        f: function() {
                            try {
                                a1 || null == r1.return || r1.return();
                            } finally{
                                if (u1) throw s1;
                            }
                        }
                    };
                }
                function i1(t1, e1) {
                    (null == e1 || e1 > t1.length) && (e1 = t1.length);
                    for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                    return n1;
                }
                function s1(t1, e1) {
                    for(var r1 = 0; r1 < e1.length; r1++){
                        var n1 = e1[r1];
                        n1.enumerable = n1.enumerable || !1, n1.configurable = !0, "value" in n1 && (n1.writable = !0), Object.defineProperty(t1, n1.key, n1);
                    }
                }
                function a1(t1, e1, r1) {
                    return (a1 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t1, e1, r1) {
                        var n1 = function(t1, e1) {
                            for(; !Object.prototype.hasOwnProperty.call(t1, e1) && null !== (t1 = f1(t1)););
                            return t1;
                        }(t1, e1);
                        if (n1) {
                            var o1 = Object.getOwnPropertyDescriptor(n1, e1);
                            return o1.get ? o1.get.call(r1) : o1.value;
                        }
                    })(t1, e1, r1 || t1);
                }
                function u1(t1, e1) {
                    return (u1 = Object.setPrototypeOf || function(t1, e1) {
                        return t1.__proto__ = e1, t1;
                    })(t1, e1);
                }
                function c1(t1) {
                    var e1 = function() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                        } catch (t1) {
                            return !1;
                        }
                    }();
                    return function() {
                        var r1, n1 = f1(t1);
                        if (e1) {
                            var o1 = f1(this).constructor;
                            r1 = Reflect.construct(n1, arguments, o1);
                        } else r1 = n1.apply(this, arguments);
                        return l1(this, r1);
                    };
                }
                function l1(t1, e1) {
                    return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                        if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t1;
                    }(t1) : e1;
                }
                function f1(t1) {
                    return (f1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                        return t1.__proto__ || Object.getPrototypeOf(t1);
                    })(t1);
                }
                var p1 = r1(87), h1 = r1(170), y1 = r1(7), d1 = function(t1) {
                    !function(t1, e1) {
                        if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                        t1.prototype = Object.create(e1 && e1.prototype, {
                            constructor: {
                                value: t1,
                                writable: !0,
                                configurable: !0
                            }
                        }), e1 && u1(t1, e1);
                    }(h1, t1);
                    var r1, n1, i1, l1 = c1(h1);
                    function h1(t1, e1) {
                        var r1;
                        return function(t1, e1) {
                            if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
                        }(this, h1), (r1 = l1.call(this, t1, e1, "Map")).$isSchemaMap = !0, r1;
                    }
                    return r1 = h1, n1 = [
                        {
                            key: "set",
                            value: function(t1, e1) {
                                return y1.set(t1, e1);
                            }
                        },
                        {
                            key: "cast",
                            value: function(t1, r1, n1) {
                                if (t1 instanceof p1) return t1;
                                if (n1) {
                                    var i1 = new p1({}, this.path, r1, this.$__schemaType);
                                    if (t1 instanceof e1.Map) {
                                        var s1, a1 = o1(t1.keys());
                                        try {
                                            for(a1.s(); !(s1 = a1.n()).done;){
                                                var u1 = s1.value;
                                                i1.$init(u1, i1.$__schemaType.cast(t1.get(u1), r1, !0));
                                            }
                                        } catch (t1) {
                                            a1.e(t1);
                                        } finally{
                                            a1.f();
                                        }
                                    } else for(var c1 = 0, l1 = Object.keys(t1); c1 < l1.length; c1++){
                                        var f1 = l1[c1];
                                        i1.$init(f1, i1.$__schemaType.cast(t1[f1], r1, !0));
                                    }
                                    return i1;
                                }
                                return new p1(t1, this.path, r1, this.$__schemaType);
                            }
                        },
                        {
                            key: "clone",
                            value: function() {
                                var t1 = a1(f1(h1.prototype), "clone", this).call(this);
                                return null != this.$__schemaType && (t1.$__schemaType = this.$__schemaType.clone()), t1;
                            }
                        }
                    ], s1(r1.prototype, n1), i1 && s1(r1, i1), h1;
                }(y1);
                d1.prototype.OptionsConstructor = h1, d1.defaultOptions = {}, t1.exports = d1;
            }).call(this, r1(11));
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                if (!(t1 instanceof e1)) throw new TypeError("Cannot call a class as a function");
            }
            function i1(t1, e1) {
                return (i1 = Object.setPrototypeOf || function(t1, e1) {
                    return t1.__proto__ = e1, t1;
                })(t1, e1);
            }
            function s1(t1) {
                var e1 = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0;
                    } catch (t1) {
                        return !1;
                    }
                }();
                return function() {
                    var r1, n1 = u1(t1);
                    if (e1) {
                        var o1 = u1(this).constructor;
                        r1 = Reflect.construct(n1, arguments, o1);
                    } else r1 = n1.apply(this, arguments);
                    return a1(this, r1);
                };
            }
            function a1(t1, e1) {
                return !e1 || "object" !== n1(e1) && "function" != typeof e1 ? function(t1) {
                    if (void 0 === t1) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t1;
                }(t1) : e1;
            }
            function u1(t1) {
                return (u1 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t1) {
                    return t1.__proto__ || Object.getPrototypeOf(t1);
                })(t1);
            }
            var c1 = function(t1) {
                !function(t1, e1) {
                    if ("function" != typeof e1 && null !== e1) throw new TypeError("Super expression must either be null or a function");
                    t1.prototype = Object.create(e1 && e1.prototype, {
                        constructor: {
                            value: t1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e1 && i1(t1, e1);
                }(r1, t1);
                var e1 = s1(r1);
                function r1() {
                    return o1(this, r1), e1.apply(this, arguments);
                }
                return r1;
            }(r1(9)), l1 = r1(10);
            Object.defineProperty(c1.prototype, "of", l1), t1.exports = c1;
        },
        function(t1, e1, r1) {
            "use strict";
            (function(t1) {
                /*!
 * Module dependencies.
 */ function n1(t1) {
                    return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                        return typeof t1;
                    } : function(t1) {
                        return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                    })(t1);
                }
                var o1 = r1(15).get().Binary, i1 = r1(20), s1 = r1(13), a1 = r1(29);
                /*!
 * ignore
 */ function u1(e1) {
                    return e1 && "object" === n1(e1) && !(e1 instanceof Date) && !(e1 instanceof s1) && (!Array.isArray(e1) || e1.length > 0) && !(e1 instanceof t1) && !(e1 instanceof i1) && !(e1 instanceof o1);
                }
                e1.flatten = /*!
 * ignore
 */ function e1(r1, n1, o1, i1) {
                    var s1;
                    s1 = r1 && a1(r1) && !t1.isBuffer(r1) ? Object.keys(r1.toObject({
                        transform: !1,
                        virtuals: !1
                    })) : Object.keys(r1 || {});
                    var c1 = s1.length, l1 = {};
                    n1 = n1 ? n1 + "." : "";
                    for(var f1 = 0; f1 < c1; ++f1){
                        var p1 = s1[f1], h1 = r1[p1];
                        l1[n1 + p1] = h1;
                        var y1 = i1 && i1.path && i1.path(n1 + p1), d1 = i1 && i1.nested && i1.nested[n1 + p1];
                        if (!y1 || "Mixed" !== y1.instance) {
                            if (u1(h1)) {
                                if (o1 && o1.skipArrays && Array.isArray(h1)) continue;
                                var m1 = e1(h1, n1 + p1, o1, i1);
                                for(var _1 in m1)l1[_1] = m1[_1];
                                Array.isArray(h1) && (l1[n1 + p1] = h1);
                            }
                            if (d1) for(var v1 = Object.keys(i1.paths), g1 = 0, b1 = v1; g1 < b1.length; g1++){
                                var w1 = b1[g1];
                                w1.startsWith(n1 + p1 + ".") && !l1.hasOwnProperty(w1) && (l1[w1] = void 0);
                            }
                        }
                    }
                    return l1;
                }, e1.modifiedPaths = function e1(r1, n1, o1) {
                    var i1 = Object.keys(r1 || {}), s1 = i1.length;
                    o1 = o1 || {}, n1 = n1 ? n1 + "." : "";
                    for(var c1 = 0; c1 < s1; ++c1){
                        var l1 = i1[c1], f1 = r1[l1];
                        o1[n1 + l1] = !0, a1(f1) && !t1.isBuffer(f1) && (f1 = f1.toObject({
                            transform: !1,
                            virtuals: !1
                        })), u1(f1) && e1(f1, n1 + l1, o1);
                    }
                    return o1;
                };
            }).call(this, r1(1).Buffer);
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(3);
            /*!
 * Like `schema.path()`, except with a document, because impossible to
 * determine path type without knowing the embedded discriminator key.
 */ t1.exports = function t1(e1, r1, o1) {
                for(var i1 = (o1 = o1 || {}).typeOnly, s1 = r1.split("."), a1 = null, u1 = "adhocOrUndefined", c1 = 0; c1 < s1.length; ++c1){
                    var l1 = s1.slice(0, c1 + 1).join(".");
                    if (null != (a1 = e1.schema.path(l1))) {
                        if ("Mixed" === a1.instance) return i1 ? "real" : a1;
                        if (u1 = e1.schema.pathType(l1), (a1.$isSingleNested || a1.$isMongooseDocumentArrayElement) && null != a1.schema.discriminators) {
                            var f1 = a1.schema.discriminators, p1 = e1.get(l1 + "." + n1(a1, "schema.options.discriminatorKey"));
                            if (null == p1 || null == f1[p1]) continue;
                            var h1 = s1.slice(c1 + 1).join(".");
                            return t1(e1.get(l1), h1, o1);
                        }
                    } else u1 = "adhocOrUndefined";
                }
                return i1 ? u1 : a1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * ignore
 */ /*!
 * Returns this documents _id cast to a string.
 */ function n1() {
                return null != this._id ? String(this._id) : null;
            }
            t1.exports = function(t1) {
                !t1.paths.id && !t1.options.noVirtualId && t1.options.id && t1.virtual("id").get(n1);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            var n1 = r1(58);
            /*!
 * ignore
 */ t1.exports = function(t1) {
                var e1 = Object.keys(t1), r1 = e1.length, o1 = null;
                if (1 === r1 && "_id" === e1[0]) o1 = !!t1[e1[r1]];
                else for(; r1--;)if ("_id" !== e1[r1] && n1(t1[e1[r1]])) {
                    o1 = !t1[e1[r1]];
                    break;
                }
                return o1;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies
 */ function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            function o1(t1, e1) {
                var r1;
                if ("undefined" == typeof Symbol || null == t1[Symbol.iterator]) {
                    if (Array.isArray(t1) || (r1 = function(t1, e1) {
                        if (!t1) return;
                        if ("string" == typeof t1) return i1(t1, e1);
                        var r1 = Object.prototype.toString.call(t1).slice(8, -1);
                        "Object" === r1 && t1.constructor && (r1 = t1.constructor.name);
                        if ("Map" === r1 || "Set" === r1) return Array.from(t1);
                        if ("Arguments" === r1 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r1)) return i1(t1, e1);
                    }(t1)) || e1 && t1 && "number" == typeof t1.length) {
                        r1 && (t1 = r1);
                        var n1 = 0, o1 = function() {};
                        return {
                            s: o1,
                            n: function() {
                                return n1 >= t1.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: t1[n1++]
                                };
                            },
                            e: function(t1) {
                                throw t1;
                            },
                            f: o1
                        };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var s1, a1 = !0, u1 = !1;
                return {
                    s: function() {
                        r1 = t1[Symbol.iterator]();
                    },
                    n: function() {
                        var t1 = r1.next();
                        return a1 = t1.done, t1;
                    },
                    e: function(t1) {
                        u1 = !0, s1 = t1;
                    },
                    f: function() {
                        try {
                            a1 || null == r1.return || r1.return();
                        } finally{
                            if (u1) throw s1;
                        }
                    }
                };
            }
            function i1(t1, e1) {
                (null == e1 || e1 > t1.length) && (e1 = t1.length);
                for(var r1 = 0, n1 = new Array(e1); r1 < e1; r1++)n1[r1] = t1[r1];
                return n1;
            }
            var s1 = r1(176), a1 = r1(3), u1 = r1(34), c1 = r1(58), l1 = r1(28);
            /*!
 * Set each path query option to lean
 *
 * @param {Object} option
 */ function f1(t1) {
                return function(e1) {
                    e1.options || (e1.options = {}), e1.options.lean = t1;
                };
            }
            /*!
 * Handle the `WriteOpResult` from the server
 */ /*!
 * Prepare a set of path options for query population.
 *
 * @param {Query} query
 * @param {Object} options
 * @return {Array}
 */ e1.preparePopulationOptions = function(t1, e1) {
                var r1 = t1.options.populate, n1 = Object.keys(r1).reduce(function(t1, e1) {
                    return t1.concat([
                        r1[e1]
                    ]);
                }, []);
                return null != e1.lean && n1.filter(function(t1) {
                    return null == a1(t1, "options.lean");
                }).forEach(f1(e1.lean)), n1;
            }, /*!
 * Prepare a set of path options for query population. This is the MongooseQuery
 * version
 *
 * @param {Query} query
 * @param {Object} options
 * @return {Array}
 */ e1.preparePopulationOptionsMQ = function(t1, e1) {
                var r1 = t1._mongooseOptions.populate, n1 = Object.keys(r1).reduce(function(t1, e1) {
                    return t1.concat([
                        r1[e1]
                    ]);
                }, []);
                null != e1.lean && n1.filter(function(t1) {
                    return null == a1(t1, "options.lean");
                }).forEach(f1(e1.lean));
                var o1 = a1(t1, "options.session", null);
                null != o1 && n1.forEach(function(t1) {
                    null != t1.options ? "session" in t1.options || (t1.options.session = o1) : t1.options = {
                        session: o1
                    };
                });
                var i1 = t1._fieldsForExec();
                return n1.forEach(function(t1) {
                    t1._queryProjection = i1;
                }), n1;
            }, /*!
 * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,
 * it returns an instance of the given model.
 *
 * @param {Model}  model
 * @param {Object} doc
 * @param {Object} fields
 *
 * @return {Document}
 */ e1.createModel = function(t1, r1, n1, o1) {
                t1.hooks.execPreSync("createModel", r1);
                var i1 = t1.schema ? t1.schema.discriminatorMapping : null, s1 = i1 && i1.isRoot ? i1.key : null, a1 = r1[s1];
                if (s1 && a1 && t1.discriminators) {
                    var c1 = t1.discriminators[a1] || u1(t1, a1);
                    if (c1) {
                        var f1 = l1(o1);
                        return e1.applyPaths(f1, c1.schema), new c1(void 0, f1, !0);
                    }
                }
                return new t1(void 0, n1, {
                    skipId: !0,
                    isNew: !1,
                    willInit: !0
                });
            }, /*!
 * ignore
 */ e1.applyPaths = function(t1, e1) {
                var r1, i1, u1;
                if (t1) {
                    for(u1 = (i1 = Object.keys(t1)).length; u1--;)if ("+" !== i1[u1][0]) {
                        var l1 = t1[i1[u1]];
                        if (c1(l1)) {
                            r1 = !l1;
                            break;
                        }
                    }
                }
                var f1 = [], p1 = [], h1 = [];
                switch(function e1(o1, u1) {
                    if (u1 || (u1 = ""), -1 !== h1.indexOf(o1)) return [];
                    h1.push(o1);
                    var c1 = [];
                    return o1.eachPath(function(o1, l1) {
                        u1 && (o1 = u1 + "." + o1);
                        var h1 = function(e1, o1) {
                            var s1 = "+" + e1, u1 = t1 && s1 in t1;
                            u1 && delete t1[s1];
                            if ("boolean" != typeof o1.selected) return;
                            if (u1) return delete t1[s1], void (!1 === r1 && i1.length > 1 && !~i1.indexOf(e1) && (t1[e1] = 1));
                            for(var c1 = e1.split("."), l1 = "", h1 = 0; h1 < c1.length; ++h1)if (l1 += l1.length ? "." + c1[h1] : c1[h1], -1 !== p1.indexOf(l1)) return;
                            if (!r1 && a1(o1, "options.$skipDiscriminatorCheck", !1)) for(var y1 = "", d1 = 0; d1 < c1.length; ++d1){
                                y1 += (0 === y1.length ? "" : ".") + c1[d1];
                                var m1 = a1(t1, y1, !1) || a1(t1, y1 + ".$", !1);
                                if (m1 && "object" !== n1(m1)) return;
                            }
                            return (o1.selected ? f1 : p1).push(e1), e1;
                        }(o1, l1);
                        if (null != h1 && c1.push(h1), l1.schema) {
                            var y1 = e1(l1.schema, o1);
                            !1 === r1 && s1(t1, o1, l1.schema, f1, y1);
                        }
                    }), h1.pop(), c1;
                }(e1), r1){
                    case !0:
                        var y1, d1 = o1(p1);
                        try {
                            for(d1.s(); !(y1 = d1.n()).done;){
                                var m1 = y1.value;
                                t1[m1] = 0;
                            }
                        } catch (t1) {
                            d1.e(t1);
                        } finally{
                            d1.f();
                        }
                        break;
                    case !1:
                        e1 && e1.paths._id && e1.paths._id.options && !1 === e1.paths._id.options.select && (t1._id = 0);
                        var _1, v1 = o1(f1);
                        try {
                            for(v1.s(); !(_1 = v1.n()).done;){
                                var g1 = _1.value;
                                t1[g1] = t1[g1] || 1;
                            }
                        } catch (t1) {
                            v1.e(t1);
                        } finally{
                            v1.f();
                        }
                        break;
                    case void 0:
                        if (null == t1) break;
                        for(var b1 = 0, w1 = Object.keys(t1 || {}); b1 < w1.length; b1++){
                            var O1 = w1[b1];
                            O1.startsWith("+") && delete t1[O1];
                        }
                        var S1, A1 = o1(p1);
                        try {
                            for(A1.s(); !(S1 = A1.n()).done;){
                                var j1 = S1.value;
                                t1[j1] = 0;
                            }
                        } catch (t1) {
                            A1.e(t1);
                        } finally{
                            A1.f();
                        }
                }
            }, e1.handleDeleteWriteOpResult = function(t1) {
                return function(e1, r1) {
                    if (e1) return t1(e1);
                    var n1 = Object.assign({}, r1.result);
                    return null != a1(r1, "result.n", null) && (n1.deletedCount = r1.result.n), null != r1.deletedCount && (n1.deletedCount = r1.deletedCount), t1(null, n1);
                };
            };
        },
        function(t1, e1, r1) {
            "use strict";
            t1.exports = function(t1, e1, r1, n1, o1) {
                var i1 = Object.keys(t1).reduce(function(t1, r1) {
                    return t1 || r1.startsWith(e1 + ".");
                }, !1), s1 = e1 + "." + r1.options.discriminatorKey;
                i1 || 1 !== o1.length || o1[0] !== s1 || n1.splice(n1.indexOf(s1), 1);
            };
        },
        function(t1, e1, r1) {
            "use strict";
            function n1(t1) {
                return (n1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                })(t1);
            }
            t1.exports = function(t1) {
                return !!t1 && ("object" === n1(t1) || "function" == typeof t1) && "function" == typeof t1.then;
            };
        },
        function(t1, e1, r1) {
            "use strict";
            /*!
 * Module dependencies.
 */ var n1 = r1(6), o1 = r1(19).EventEmitter, i1 = r1(5), s1 = r1(52), a1 = r1(13), u1 = i1.ValidationError, c1 = r1(76), l1 = r1(21);
            function f1(t1, e1, r1, o1, u1) {
                if (!(this instanceof f1)) return new f1(t1, e1, r1, o1, u1);
                if (l1(e1) && !e1.instanceOfSchema && (e1 = new s1(e1)), e1 = this.schema || e1, !this.schema && e1.options._id && void 0 === (t1 = t1 || {})._id && (t1._id = new a1), !e1) throw new i1.MissingSchemaError;
                for(var p1 in this.$__setSchema(e1), n1.call(this, t1, r1, o1, u1), c1(this, e1, {
                    decorateDoc: !0
                }), e1.methods)this[p1] = e1.methods[p1];
                for(var h1 in e1.statics)this[h1] = e1.statics[h1];
            }
            /*!
 * Inherit from the NodeJS document
 */ f1.prototype = Object.create(n1.prototype), f1.prototype.constructor = f1, /*!
 * ignore
 */ f1.events = new o1, /*!
 * Browser doc exposes the event emitter API
 */ f1.$emitter = new o1, [
                "on",
                "once",
                "emit",
                "listeners",
                "removeListener",
                "setMaxListeners",
                "removeAllListeners",
                "addListener"
            ].forEach(function(t1) {
                f1[t1] = function() {
                    return f1.$emitter[t1].apply(f1.$emitter, arguments);
                };
            }), /*!
 * Module exports.
 */ f1.ValidationError = u1, t1.exports = f1;
        }
    ]);
});

},{}],"7dT0d":[function(require,module,exports) {
(function(name, root, factory) {
    module.exports = factory();
    module.exports["default"] = factory();
})("slugify", this, function() {
    var charMap = JSON.parse('{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","\xa2":"cent","\xa3":"pound","\xa4":"currency","\xa5":"yen","\xa9":"(c)","\xaa":"a","\xae":"(r)","\xba":"o","\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xc6":"AE","\xc7":"C","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xcc":"I","\xcd":"I","\xce":"I","\xcf":"I","\xd0":"D","\xd1":"N","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xdd":"Y","\xde":"TH","\xdf":"ss","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a","\xe6":"ae","\xe7":"c","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xf0":"d","\xf1":"n","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xfd":"y","\xfe":"th","\xff":"y","\u0100":"A","\u0101":"a","\u0102":"A","\u0103":"a","\u0104":"A","\u0105":"a","\u0106":"C","\u0107":"c","\u010C":"C","\u010D":"c","\u010E":"D","\u010F":"d","\u0110":"DJ","\u0111":"dj","\u0112":"E","\u0113":"e","\u0116":"E","\u0117":"e","\u0118":"e","\u0119":"e","\u011A":"E","\u011B":"e","\u011E":"G","\u011F":"g","\u0122":"G","\u0123":"g","\u0128":"I","\u0129":"i","\u012A":"i","\u012B":"i","\u012E":"I","\u012F":"i","\u0130":"I","\u0131":"i","\u0136":"k","\u0137":"k","\u013B":"L","\u013C":"l","\u013D":"L","\u013E":"l","\u0141":"L","\u0142":"l","\u0143":"N","\u0144":"n","\u0145":"N","\u0146":"n","\u0147":"N","\u0148":"n","\u014C":"O","\u014D":"o","\u0150":"O","\u0151":"o","\u0152":"OE","\u0153":"oe","\u0154":"R","\u0155":"r","\u0158":"R","\u0159":"r","\u015A":"S","\u015B":"s","\u015E":"S","\u015F":"s","\u0160":"S","\u0161":"s","\u0162":"T","\u0163":"t","\u0164":"T","\u0165":"t","\u0168":"U","\u0169":"u","\u016A":"u","\u016B":"u","\u016E":"U","\u016F":"u","\u0170":"U","\u0171":"u","\u0172":"U","\u0173":"u","\u0174":"W","\u0175":"w","\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017A":"z","\u017B":"Z","\u017C":"z","\u017D":"Z","\u017E":"z","\u018F":"E","\u0192":"f","\u01A0":"O","\u01A1":"o","\u01AF":"U","\u01B0":"u","\u01C8":"LJ","\u01C9":"lj","\u01CB":"NJ","\u01CC":"nj","\u0218":"S","\u0219":"s","\u021A":"T","\u021B":"t","\u0259":"e","\u02DA":"o","\u0386":"A","\u0388":"E","\u0389":"H","\u038A":"I","\u038C":"O","\u038E":"Y","\u038F":"W","\u0390":"i","\u0391":"A","\u0392":"B","\u0393":"G","\u0394":"D","\u0395":"E","\u0396":"Z","\u0397":"H","\u0398":"8","\u0399":"I","\u039A":"K","\u039B":"L","\u039C":"M","\u039D":"N","\u039E":"3","\u039F":"O","\u03A0":"P","\u03A1":"R","\u03A3":"S","\u03A4":"T","\u03A5":"Y","\u03A6":"F","\u03A7":"X","\u03A8":"PS","\u03A9":"W","\u03AA":"I","\u03AB":"Y","\u03AC":"a","\u03AD":"e","\u03AE":"h","\u03AF":"i","\u03B0":"y","\u03B1":"a","\u03B2":"b","\u03B3":"g","\u03B4":"d","\u03B5":"e","\u03B6":"z","\u03B7":"h","\u03B8":"8","\u03B9":"i","\u03BA":"k","\u03BB":"l","\u03BC":"m","\u03BD":"n","\u03BE":"3","\u03BF":"o","\u03C0":"p","\u03C1":"r","\u03C2":"s","\u03C3":"s","\u03C4":"t","\u03C5":"y","\u03C6":"f","\u03C7":"x","\u03C8":"ps","\u03C9":"w","\u03CA":"i","\u03CB":"y","\u03CC":"o","\u03CD":"y","\u03CE":"w","\u0401":"Yo","\u0402":"DJ","\u0404":"Ye","\u0406":"I","\u0407":"Yi","\u0408":"J","\u0409":"LJ","\u040A":"NJ","\u040B":"C","\u040F":"DZ","\u0410":"A","\u0411":"B","\u0412":"V","\u0413":"G","\u0414":"D","\u0415":"E","\u0416":"Zh","\u0417":"Z","\u0418":"I","\u0419":"J","\u041A":"K","\u041B":"L","\u041C":"M","\u041D":"N","\u041E":"O","\u041F":"P","\u0420":"R","\u0421":"S","\u0422":"T","\u0423":"U","\u0424":"F","\u0425":"H","\u0426":"C","\u0427":"Ch","\u0428":"Sh","\u0429":"Sh","\u042A":"U","\u042B":"Y","\u042C":"","\u042D":"E","\u042E":"Yu","\u042F":"Ya","\u0430":"a","\u0431":"b","\u0432":"v","\u0433":"g","\u0434":"d","\u0435":"e","\u0436":"zh","\u0437":"z","\u0438":"i","\u0439":"j","\u043A":"k","\u043B":"l","\u043C":"m","\u043D":"n","\u043E":"o","\u043F":"p","\u0440":"r","\u0441":"s","\u0442":"t","\u0443":"u","\u0444":"f","\u0445":"h","\u0446":"c","\u0447":"ch","\u0448":"sh","\u0449":"sh","\u044A":"u","\u044B":"y","\u044C":"","\u044D":"e","\u044E":"yu","\u044F":"ya","\u0451":"yo","\u0452":"dj","\u0454":"ye","\u0456":"i","\u0457":"yi","\u0458":"j","\u0459":"lj","\u045A":"nj","\u045B":"c","\u045D":"u","\u045F":"dz","\u0490":"G","\u0491":"g","\u0492":"GH","\u0493":"gh","\u049A":"KH","\u049B":"kh","\u04A2":"NG","\u04A3":"ng","\u04AE":"UE","\u04AF":"ue","\u04B0":"U","\u04B1":"u","\u04BA":"H","\u04BB":"h","\u04D8":"AE","\u04D9":"ae","\u04E8":"OE","\u04E9":"oe","\u0531":"A","\u0532":"B","\u0533":"G","\u0534":"D","\u0535":"E","\u0536":"Z","\u0537":"E\'","\u0538":"Y\'","\u0539":"T\'","\u053A":"JH","\u053B":"I","\u053C":"L","\u053D":"X","\u053E":"C\'","\u053F":"K","\u0540":"H","\u0541":"D\'","\u0542":"GH","\u0543":"TW","\u0544":"M","\u0545":"Y","\u0546":"N","\u0547":"SH","\u0549":"CH","\u054A":"P","\u054B":"J","\u054C":"R\'","\u054D":"S","\u054E":"V","\u054F":"T","\u0550":"R","\u0551":"C","\u0553":"P\'","\u0554":"Q\'","\u0555":"O\'\'","\u0556":"F","\u0587":"EV","\u0621":"a","\u0622":"aa","\u0623":"a","\u0624":"u","\u0625":"i","\u0626":"e","\u0627":"a","\u0628":"b","\u0629":"h","\u062A":"t","\u062B":"th","\u062C":"j","\u062D":"h","\u062E":"kh","\u062F":"d","\u0630":"th","\u0631":"r","\u0632":"z","\u0633":"s","\u0634":"sh","\u0635":"s","\u0636":"dh","\u0637":"t","\u0638":"z","\u0639":"a","\u063A":"gh","\u0641":"f","\u0642":"q","\u0643":"k","\u0644":"l","\u0645":"m","\u0646":"n","\u0647":"h","\u0648":"w","\u0649":"a","\u064A":"y","\u064B":"an","\u064C":"on","\u064D":"en","\u064E":"a","\u064F":"u","\u0650":"e","\u0652":"","\u0660":"0","\u0661":"1","\u0662":"2","\u0663":"3","\u0664":"4","\u0665":"5","\u0666":"6","\u0667":"7","\u0668":"8","\u0669":"9","\u067E":"p","\u0686":"ch","\u0698":"zh","\u06A9":"k","\u06AF":"g","\u06CC":"y","\u06F0":"0","\u06F1":"1","\u06F2":"2","\u06F3":"3","\u06F4":"4","\u06F5":"5","\u06F6":"6","\u06F7":"7","\u06F8":"8","\u06F9":"9","\u0E3F":"baht","\u10D0":"a","\u10D1":"b","\u10D2":"g","\u10D3":"d","\u10D4":"e","\u10D5":"v","\u10D6":"z","\u10D7":"t","\u10D8":"i","\u10D9":"k","\u10DA":"l","\u10DB":"m","\u10DC":"n","\u10DD":"o","\u10DE":"p","\u10DF":"zh","\u10E0":"r","\u10E1":"s","\u10E2":"t","\u10E3":"u","\u10E4":"f","\u10E5":"k","\u10E6":"gh","\u10E7":"q","\u10E8":"sh","\u10E9":"ch","\u10EA":"ts","\u10EB":"dz","\u10EC":"ts","\u10ED":"ch","\u10EE":"kh","\u10EF":"j","\u10F0":"h","\u1E62":"S","\u1E63":"s","\u1E80":"W","\u1E81":"w","\u1E82":"W","\u1E83":"w","\u1E84":"W","\u1E85":"w","\u1E9E":"SS","\u1EA0":"A","\u1EA1":"a","\u1EA2":"A","\u1EA3":"a","\u1EA4":"A","\u1EA5":"a","\u1EA6":"A","\u1EA7":"a","\u1EA8":"A","\u1EA9":"a","\u1EAA":"A","\u1EAB":"a","\u1EAC":"A","\u1EAD":"a","\u1EAE":"A","\u1EAF":"a","\u1EB0":"A","\u1EB1":"a","\u1EB2":"A","\u1EB3":"a","\u1EB4":"A","\u1EB5":"a","\u1EB6":"A","\u1EB7":"a","\u1EB8":"E","\u1EB9":"e","\u1EBA":"E","\u1EBB":"e","\u1EBC":"E","\u1EBD":"e","\u1EBE":"E","\u1EBF":"e","\u1EC0":"E","\u1EC1":"e","\u1EC2":"E","\u1EC3":"e","\u1EC4":"E","\u1EC5":"e","\u1EC6":"E","\u1EC7":"e","\u1EC8":"I","\u1EC9":"i","\u1ECA":"I","\u1ECB":"i","\u1ECC":"O","\u1ECD":"o","\u1ECE":"O","\u1ECF":"o","\u1ED0":"O","\u1ED1":"o","\u1ED2":"O","\u1ED3":"o","\u1ED4":"O","\u1ED5":"o","\u1ED6":"O","\u1ED7":"o","\u1ED8":"O","\u1ED9":"o","\u1EDA":"O","\u1EDB":"o","\u1EDC":"O","\u1EDD":"o","\u1EDE":"O","\u1EDF":"o","\u1EE0":"O","\u1EE1":"o","\u1EE2":"O","\u1EE3":"o","\u1EE4":"U","\u1EE5":"u","\u1EE6":"U","\u1EE7":"u","\u1EE8":"U","\u1EE9":"u","\u1EEA":"U","\u1EEB":"u","\u1EEC":"U","\u1EED":"u","\u1EEE":"U","\u1EEF":"u","\u1EF0":"U","\u1EF1":"u","\u1EF2":"Y","\u1EF3":"y","\u1EF4":"Y","\u1EF5":"y","\u1EF6":"Y","\u1EF7":"y","\u1EF8":"Y","\u1EF9":"y","\u2013":"-","\u2018":"\'","\u2019":"\'","\u201C":"\\"","\u201D":"\\"","\u201E":"\\"","\u2020":"+","\u2022":"*","\u2026":"...","\u20A0":"ecu","\u20A2":"cruzeiro","\u20A3":"french franc","\u20A4":"lira","\u20A5":"mill","\u20A6":"naira","\u20A7":"peseta","\u20A8":"rupee","\u20A9":"won","\u20AA":"new shequel","\u20AB":"dong","\u20AC":"euro","\u20AD":"kip","\u20AE":"tugrik","\u20AF":"drachma","\u20B0":"penny","\u20B1":"peso","\u20B2":"guarani","\u20B3":"austral","\u20B4":"hryvnia","\u20B5":"cedi","\u20B8":"kazakhstani tenge","\u20B9":"indian rupee","\u20BA":"turkish lira","\u20BD":"russian ruble","\u20BF":"bitcoin","\u2120":"sm","\u2122":"tm","\u2202":"d","\u2206":"delta","\u2211":"sum","\u221E":"infinity","\u2665":"love","\u5143":"yuan","\u5186":"yen","\uFDFC":"rial","\uFEF5":"laa","\uFEF7":"laa","\uFEF9":"lai","\uFEFB":"la"}');
    var locales = JSON.parse('{"bg":{"\u0419":"Y","\u0426":"Ts","\u0429":"Sht","\u042A":"A","\u042C":"Y","\u0439":"y","\u0446":"ts","\u0449":"sht","\u044A":"a","\u044C":"y"},"de":{"\xc4":"AE","\xe4":"ae","\xd6":"OE","\xf6":"oe","\xdc":"UE","\xfc":"ue","\xdf":"ss","%":"prozent","&":"und","|":"oder","\u2211":"summe","\u221E":"unendlich","\u2665":"liebe"},"es":{"%":"por ciento","&":"y","<":"menor que",">":"mayor que","|":"o","\xa2":"centavos","\xa3":"libras","\xa4":"moneda","\u20A3":"francos","\u2211":"suma","\u221E":"infinito","\u2665":"amor"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","\xa2":"centime","\xa3":"livre","\xa4":"devise","\u20A3":"franc","\u2211":"somme","\u221E":"infini","\u2665":"amour"},"pt":{"%":"porcento","&":"e","<":"menor",">":"maior","|":"ou","\xa2":"centavo","\u2211":"soma","\xa3":"libra","\u221E":"infinito","\u2665":"amor"},"uk":{"\u0418":"Y","\u0438":"y","\u0419":"Y","\u0439":"y","\u0426":"Ts","\u0446":"ts","\u0425":"Kh","\u0445":"kh","\u0429":"Shch","\u0449":"shch","\u0413":"H","\u0433":"h"},"vi":{"\u0110":"D","\u0111":"d"},"da":{"\xd8":"OE","\xf8":"oe","\xc5":"AA","\xe5":"aa","%":"procent","&":"og","|":"eller","$":"dollar","<":"mindre end",">":"st\xf8rre end"},"nb":{"&":"og","\xc5":"AA","\xc6":"AE","\xd8":"OE","\xe5":"aa","\xe6":"ae","\xf8":"oe"},"it":{"&":"e"},"nl":{"&":"en"},"sv":{"&":"och","\xc5":"AA","\xc4":"AE","\xd6":"OE","\xe5":"aa","\xe4":"ae","\xf6":"oe"}}');
    function replace(string, options) {
        if (typeof string !== "string") throw new Error("slugify: string argument expected");
        options = typeof options === "string" ? {
            replacement: options
        } : options || {};
        var locale = locales[options.locale] || {};
        var replacement = options.replacement === undefined ? "-" : options.replacement;
        var trim = options.trim === undefined ? true : options.trim;
        var slug = string.normalize().split("")// replace characters based on charMap
        .reduce(function(result, ch) {
            var appendChar = locale[ch];
            if (appendChar === undefined) appendChar = charMap[ch];
            if (appendChar === undefined) appendChar = ch;
            if (appendChar === replacement) appendChar = " ";
            return result + appendChar// remove not allowed characters
            .replace(options.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "");
        }, "");
        if (options.strict) slug = slug.replace(/[^A-Za-z0-9\s]/g, "");
        if (trim) slug = slug.trim();
        // Replace spaces with replacement character, treating multiple consecutive
        // spaces as a single space.
        slug = slug.replace(/\s+/g, replacement);
        if (options.lower) slug = slug.toLowerCase();
        return slug;
    }
    replace.extend = function(customMap) {
        Object.assign(charMap, customMap);
    };
    return replace;
});

},{}]},["dafvh","f2QDv"], "f2QDv", "parcelRequire11c7")

//# sourceMappingURL=index.js.map
